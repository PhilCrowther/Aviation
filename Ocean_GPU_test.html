<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Ocean WebGPU test</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link type="text/css" rel="stylesheet" href="styles/main.css">
</head>
<body>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.166.0/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.166.0/examples/jsm/",
			"three/nodes": "https://unpkg.com/three@0.166.0/examples/jsm/nodes/Nodes.js"
		}
	}
</script>

<script type="module">
import * as THREE from 'three';
import {texture, textureStore, wgslFn, instanceIndex, MeshBasicNodeMaterial, positionLocal, code, uniform, float} from 'three/nodes';
import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
import StorageTexture from 'three/addons/renderers/common/StorageTexture.js';

//= VARIABLES ==================================================================
//- Time
let oldTim, nowTim, difTim = 0;
//- Constants ------------------------------------------------------------------
var DegRad = Math.PI/180;	// Convert Degrees to Radians
//- Ocean Module ---------------------------------------------------------------
let rez = 512.;	// Texture Size
//- Instruction Addresses
let initSpectrumComp,pingPhaseComp,pongPhaseComp,pingSpectrumComp,pongSpectrumComp;
let	initDspHrzComp, pingDspHrzComp, pongDspHrzComp,pingDspVrtComp, pongDspVrtComp;
//- PingPong
let pingPhase = true;
//- Uniform
let subTFSzUniform = uniform(0);

//- Time -----------------------------------------------------------------------
//let wavTim = 0;
let wavTim = uniform(0.);
let wavSpd = 1.0;	// Animation speed - use in main program (lower is faster)

//= BASIC SETUP ================================================================
let	scene = new THREE.Scene();
	scene.background = new THREE.Color(0x1f1f1f);
//- Renderer
let	renderer = new WebGPURenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	document.body.appendChild(renderer.domElement);
//- Camera
let	camera = new THREE.PerspectiveCamera(55.0,window.innerWidth/window.innerHeight,0.5,5000);
	camera.position.set(0,0,150);
//- Controls
	window.addEventListener('resize',onWindowResize);
//- Clock
let clock = new THREE.Clock();

//= PROGRAM ====================================================================
	initAll();

//= INITIALIZE =================================================================

function initAll() {
	initOcean(wavTim);
}

//= RENDER =====================================================================

function rendAll() {
	// Update time
	nowTim = clock.getElapsedTime();
	difTim = nowTim-oldTim;
//	wavTim = difTim*wavSpd || 0.0;
	wavTim.value = difTim || 0.0;
	oldTim = nowTim;
	//
	moveOcean(wavTim);
	//
	renderer.renderAsync(scene, camera);
}

//= OCEAN ======================================================================

//- INIT -----------------------------------------------------------------------

function initOcean(wavTim) {
	//- Create Eight Buffers ---------------------------------------------------
	let initSpectrumTexture = new StorageTexture(rez,rez);
		initSpectrumTexture.type = THREE.FloatType;	
	let pingPhaseTexture = new StorageTexture(rez,rez);
		pingPhaseTexture.type = THREE.FloatType;
	let pongPhaseTexture = new StorageTexture(rez,rez);
		pongPhaseTexture.type = THREE.FloatType;
	let compSpectrumTexture = new StorageTexture(rez,rez);
		compSpectrumTexture.type = THREE.FloatType;
	let pingTransformTexture = new StorageTexture(rez,rez);
		pingTransformTexture.type = THREE.FloatType;
	let pongTransformTexture = new StorageTexture(rez,rez);
		pongTransformTexture.type = THREE.FloatType;
	let dispMapTexture = new StorageTexture(rez,rez);
		dispMapTexture.type = THREE.FloatType;
	let normMapTexture = new StorageTexture(rez,rez);
		normMapTexture.type = THREE.FloatType;
	// Create Initial Phase Array
	let phaseArray = new window.Float32Array(4*(rez**2));
	for (let y = 0; y < rez; y++) {
		for (let x = 0; x < rez; x++) {
			phaseArray[y*rez*4+x*4] = Math.random()*2.0*Math.PI;
			phaseArray[y*rez*4+x*4+1] = 0.0;
			phaseArray[y*rez*4+x*4+2] = 0.0;
			phaseArray[y*rez*4+x*4+3] = 1.0;	// make visible
		}
	}
	let phaseArrayTexture = new THREE.DataTexture(phaseArray,rez,rez,THREE.RGBAFormat);	
	phaseArrayTexture.minFilter = phaseArrayTexture.magFilter = THREE.NearestFilter;
	phaseArrayTexture.wrapS = phaseArrayTexture.wrapT = THREE.ClampToEdgeWrapping;
	phaseArrayTexture.type = THREE.FloatType;
	phaseArrayTexture.needsUpdate = true;
	//= Shader Subroutines =====================================================
	let subroutines = code(`
		fn square(x: f32) -> f32 {
			return x * x;
		}
		fn omega(k: f32) -> f32 {
			return sqrt(9.81*k*(1.+square(k/370.)));
		}
		fn tanH(x: f32) -> f32 {
			return (1.-exp(-2.*x))/(1.+exp(-2.*x));
		}
		fn multiplyComplex(a: vec2f, b: vec2f) -> vec2f {
			return vec2f(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);
		}
		fn multiplyByI(z: vec2f) -> vec2f {
			return vec2f(-z.y, z.x);
		}
		fn getIdx(index: u32) -> vec2u {
			var posX = index % ${rez};	// width
			var posY = index / ${rez};	// height
			return vec2u(u32(posX),u32(posY));
		}
	`);
	//= Shader 1 ===============================================================
	//	Set intitial wave frequency at a texel coordinate (AS V2)
	let initSpectrum = wgslFn(`
		fn initSpectrum(
			sizeTex: f32,
			storTex: texture_storage_2d<rgba32float, write>,
			indxTex: u32
		) -> void {
			// Variables
			var PI: f32 = 3.14159265359;
			var u_wind = vec2<f32>(10.,10.);
			var u_grdres: f32 = 512.;
			var u_grdsiz:f32 = 512.;
			//- Compute vUv
			var idx = getIdx(indxTex);
			//- My Shader
			var pixel_coord = vec2<f32>(idx.xy)-0.5;
			var n: f32 = pixel_coord.x-u_grdres;	// use "else" value first
			if (pixel_coord.x < u_grdres*0.5) {n = pixel_coord.x;}	// use "if" value second
			var m: f32 = pixel_coord.y-u_grdres;	// use "else" value first
			if (pixel_coord.y < u_grdres*0.5) {m = pixel_coord.y;}	// use "if" value second
			let K = vec2<f32>(n,m)*2.*PI/u_grdsiz;
			//-
			var k: f32 = length(K);
			var l_wind: f32 = length(u_wind);
			var Omega: f32 = 0.84;
			var kp: f32 = 9.81 * square(Omega/l_wind);
			var c: f32 = omega(k)/k;
			var cp: f32 = omega(kp)/kp;
			var Lpm: f32 = exp(-1.25*square(kp/k));
			var gamma: f32 = 1.7;
			var sigma: f32 = 0.08*(1.+4.*pow(Omega,-3.));
			var Gamma: f32 = exp(-square(sqrt(k/kp)-1.)/2.*square(sigma));
			var Jp: f32 = pow(gamma,Gamma);
			var Fp: f32 = Lpm*Jp*exp(-Omega/sqrt(10.)*(sqrt(k/kp)-1.));
			var alphap: f32 = 0.006 * sqrt(Omega);
			var Bl: f32 = 0.5*alphap*cp/c*Fp;
			var z0: f32 = 0.000037*square(l_wind)/9.81*pow(l_wind/cp,0.9);
			var uStar: f32 = 0.41*l_wind/log(10./z0);
			var alpham: f32 = 0.01*(1.+3.*log(uStar/0.23));	// use "else" value first
			if (uStar < 0.23) {alpham = 0.01*(1.+log(uStar/0.23));}	// use "if" value second
			var Fm: f32 = exp(-0.25*square(k/370.-1.));
			var Bh: f32 = 0.5*alpham*0.23/c*Fm*Lpm;
			var a0: f32 = log(2.)/4.;
			var am: f32 = 0.13*uStar/0.23;
			var Delta: f32 = tanH(a0+4.*pow(c/cp,2.5)+am*pow(0.23/c,2.5));
			var cosPhi: f32 = dot(normalize(u_wind),normalize(K));
			var S: f32 = 1./(2.*PI)*pow(k,-4.)*(Bl+Bh)*(1.+Delta*(2.*cosPhi*cosPhi-1.));
			var dk: f32 = 2.*PI/u_grdsiz;
			var h: f32 = sqrt(S/2.)*dk;
			if (K.x == 0. && K.y == 0.) {h = 0.;}	
			textureStore(storTex,idx,vec4<f32>(h,0.,0.,1.));	// use 1 for a value to make visible
		}
	`, [subroutines]);
	//= Shader 2 ===============================================================
	//	Current Phase (AS V2)
	let compPhase = wgslFn(`	
		fn compPhase(
			sizeTex: f32,
			readTex: texture_2d<f32>,
			storTex: texture_storage_2d<rgba32float,write>,
			indxTex: u32,
			timeTex: f32
		) -> void {	
			// Variables
			var PI = 3.14159265359;
			var u_grdres: f32 = 512.;
			var u_grdsiz: f32 = 512.;
			//- Compute vUv
			var idx = getIdx(indxTex);
			//- My Shader
			var pixel_coord = vec2<f32>(idx.xy)-0.5;
			var n: f32 = pixel_coord.x-u_grdres;	// use "else" value first
			if (pixel_coord.x < u_grdres*0.5) {n = pixel_coord.x;}	// use "if" value second
			var m: f32 = pixel_coord.y-u_grdres;	// use "else" value first
			if (pixel_coord.y < u_grdres*0.5) {m = pixel_coord.y;}	// use "if" value second
			var waveVector = vec2<f32>(n,m)*2.*PI/u_grdsiz;
			//-
			var phase: f32 = textureLoad(readTex,idx,0).r;
			var deltaPhase: f32 = omega(length(waveVector))*timeTex;
			phase = ((phase+deltaPhase) % (2.*PI));
			textureStore(storTex,idx,vec4<f32>(phase,0,0,1));	// use 1 for a value to make visible
		}
	`, [subroutines]);
	//= Shader 3 ===============================================================
	//	Current Spectrum (AS V2)
	let compSpectrum = wgslFn(`
		fn compSpectrum(
			sizeTex: f32,
			readTx1: texture_2d<f32>,
			readTx2: texture_2d<f32>,
			storTex: texture_storage_2d<rgba32float,write>,
			indxTex: u32
		) -> void {
			// Variables
			var PI: f32 = 3.14159265359;
			var u_grdres: f32 = 512.;
			var u_grdsiz: f32 = 512.;
			var u_choppy: f32 = 1.;
			//- Compute vUv and neg vUv
			var posX = f32(indxTex) % sizeTex;	// width
			var posY = f32(indxTex) / sizeTex;	// height
			var idx = vec2u(u32(posX), u32(posY));
			var posXN = f32(sizeTex-posX) % sizeTex;	// neg width (AS)
			var posYN = f32(sizeTex-posY) / sizeTex;	// neg height
			var idxN = vec2u(u32(posXN),u32(posYN));			
			//- My Shader
			var pixel_coord = vec2<f32>(idx.xy) - 0.5;
			var n: f32 = pixel_coord.x-u_grdres;	// use "else" value first
			if (pixel_coord.x < u_grdres*0.5) {n = pixel_coord.x;}	// use "if" value second
			var m: f32 = pixel_coord.y-u_grdres;	// use "else" value first
			if (pixel_coord.y < u_grdres*0.5) {m = pixel_coord.y;}	// use "if" value second
			var waveVector = vec2<f32>(n,m)*2.*PI/u_grdsiz;
			//
			var phase = textureLoad(readTx1,idx,0).r;
			var phaseVector = vec2<f32>(cos(phase),sin(phase));
			var h0 = vec2<f32>(textureLoad(readTx2,idx,0).rg);
			var h0Star = vec2<f32>(textureLoad(readTx2,idxN,0).rg);
			h0Star.y = h0Star.y*(-1.);
			var h = vec2<f32>(multiplyComplex(h0,phaseVector)+multiplyComplex(h0Star,vec2<f32>(phaseVector.x,-phaseVector.y)));
			var hX = vec2<f32>(-multiplyByI(h*(waveVector.x/length(waveVector)))*u_choppy);
			var hZ = vec2<f32>(-multiplyByI(h*(waveVector.y/length(waveVector)))*u_choppy);
			if (waveVector.x == 0. && waveVector.y == 0.) {
				h = vec2<f32>(0.,0.);
				hX = vec2<f32>(0.,0.);
				hZ = vec2<f32>(0.,0.);
			}
			textureStore(storTex,idx,vec4<f32>(hX+multiplyByI(h),hZ));
	} 
	`, [subroutines]);
	//= Shader 4A ==============================================================
	//	Displacement Map (AS V2)
	let compDspHrz = wgslFn(`
		fn compDspHrz(
			sizeTex: f32,
			readTex: texture_2d<f32>,
			storTex: texture_storage_2d<rgba32float,write>,
			indxTex: u32,
			subTFSz: f32
		) -> void {
			// Variables
			var PI: f32 = 3.14159265359;
			//- Compute vUv
			var idx = getIdx(indxTex);
			var idxf = vec2<f32>(idx);		// ### add this to change format
			//
			var index: f32 = idxf.x*512.-0.5;	// ### ref idxf
			var evenIndex: f32 = floor(index/subTFSz)*(subTFSz*0.5)+((index)%(subTFSz*0.5));
			let even = vec4<f32>( textureLoad( readTex, vec2u(u32(evenIndex+0.5),idx.y)/512, 0 ).rgba);
			let odd  = vec4<f32>( textureLoad( readTex, vec2u(u32(evenIndex+512.*0.5+0.5),idx.y)/512, 0 ).rgba );		
			var twiddleArgument: f32 = -2.*PI*(index/subTFSz);
			var twiddle = vec2<f32>(cos(twiddleArgument),sin(twiddleArgument));
			var outputA = vec2<f32>(even.xy+multiplyComplex(twiddle,odd.xy));
			var outputB = vec2<f32>(even.zw+multiplyComplex(twiddle,odd.zw));
			textureStore(storTex,idx,vec4<f32>(outputA,outputB));
		}
	`, [subroutines]);
	//= Shader 4B ==============================================================
	let compDspVrt = wgslFn(`
		fn compDspVrt(
			sizeTex: f32,
			readTex: texture_2d<f32>,
			storTex: texture_storage_2d<rgba32float,write>,
			indxTex: u32,
			subTFSz: f32
		) -> void {
			// Variables
			var PI: f32 = 3.14159265359;
			//- Compute vUv
			var idx = getIdx(indxTex);
			var idxf = vec2<f32>(idx);		// ### change this to format
			//
			var index: f32 = idxf.y*512.-0.5;	// ### ref idxf
			var evenIndex: f32 = floor(index/subTFSz)*(subTFSz*0.5)+((index)%(subTFSz*0.5));
			let even = vec4<f32>(textureLoad(readTex,vec2u(idx.x,u32(evenIndex+0.5))/512,0).rgba);
			let odd =  vec4<f32>(textureLoad(readTex,vec2u(idx.x,u32(evenIndex+512.*0.5+0.5))/512,0).rgba);
			var twiddleArgument: f32 = -2.*PI*(index/subTFSz);
			var twiddle = vec2<f32>(cos(twiddleArgument),sin(twiddleArgument));
			var outputA = vec2<f32>(even.xy+multiplyComplex(twiddle,odd.xy));
			var outputB = vec2<f32>(even.zw+multiplyComplex(twiddle,odd.zw));
			textureStore(storTex,idx,vec4<f32>(outputA,outputB));
		}
	`, [subroutines]);
	//= Instructions ===========================================================
	//- Shader 1. Initial Frequency
	initSpectrumComp = initSpectrum({
		sizeTex: rez,
		storTex: textureStore(initSpectrumTexture),
		indxTex: instanceIndex
	}).compute(rez**2);
	//- Shader 2. Initial Phase
	pingPhaseComp = compPhase({
		sizeTex: rez,
		readTex: texture(phaseArrayTexture),
		storTex: textureStore(pingPhaseTexture),
		indxTex: instanceIndex,
		timeTex: wavTim
	}).compute(rez**2);
	pongPhaseComp = compPhase({
		sizeTex: rez,
		readTex: texture(phaseArrayTexture),
		storTex: textureStore(pongPhaseTexture),
		indxTex: instanceIndex,
		timeTex: wavTim
	}).compute(rez**2);
	//- Shader 3. New Phase
	pingSpectrumComp = compSpectrum({
		sizeTex: rez,
		readTx1: texture(phaseArrayTexture),
		readTx2: texture(pingPhaseTexture),
		storTex: textureStore(compSpectrumTexture),
		indxTex: instanceIndex
	}).compute(rez**2);
	pongSpectrumComp = compSpectrum({
		sizeTex: rez,
		readTx1: texture(phaseArrayTexture),
		readTx2: texture(pongPhaseTexture),
		storTex: textureStore(compSpectrumTexture),
		indxTex: instanceIndex
	}).compute(rez**2);	
	//- Shader 4. Displacement	
	//- Shader 4A
	initDspHrzComp = compDspHrz({
		sizeTex: rez,
		readTex: texture(compSpectrumTexture),
		storTex: textureStore(pongTransformTexture),
		indxTex: instanceIndex,	
		subTFSz: subTFSzUniform
	}).compute(rez**2);
	pingDspHrzComp = compDspHrz({
		sizeTex: rez,
		readTex: texture(pingTransformTexture),
		storTex: textureStore(pongTransformTexture),
		indxTex: instanceIndex,
		subTFSz: subTFSzUniform
	}).compute(rez**2);
	pongDspHrzComp = compDspHrz({
		sizeTex: rez,
		readTex: texture(pongTransformTexture),
		storTex: textureStore(pingTransformTexture),
		indxTex: instanceIndex,
		subTFSz: subTFSzUniform
	}).compute(rez**2);	
	//- Shader 4B
	pingDspVrtComp = compDspVrt({
		sizeTex: rez,
		readTex: texture(pingTransformTexture),
		storTex: textureStore(pongTransformTexture),
		indxTex: instanceIndex,
		subTFSz: subTFSzUniform
	}).compute(rez**2);
	pongDspVrtComp = compDspVrt({
		sizeTex: rez,
		readTex: texture(pongTransformTexture),
		storTex: textureStore(pingTransformTexture),
		indxTex: instanceIndex,
		subTFSz: subTFSzUniform
	}).compute(rez**2)
	//= Render =================================================================
	renderer.compute(initSpectrumComp);
	//= Display ================================================================
	let siz = 50, seg = 256;
	//- Plane 1 ----------------------------------------------------------------
	let mat1 = new MeshBasicNodeMaterial({
		colorNode: texture(initSpectrumTexture),
	});
	let mesh1 = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), mat1);
	mesh1.position.set(-1.52*siz,0.51*siz,0);
	scene.add(mesh1);
	//- Phase -----------------------------------------------------------------
	let matP = new MeshBasicNodeMaterial({
		colorNode: texture(phaseArrayTexture),
	});
	let meshP = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), matP);
	meshP.position.set(-0.51*siz,0.51*siz,0);
	scene.add(meshP);
	//- Plane 2a ----------------------------------------------------------------
	let mat2a = new MeshBasicNodeMaterial({
		colorNode: texture(pingPhaseTexture),
	});
	let mesh2a = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), mat2a);
	mesh2a.position.set(0.51*siz,0.51*siz,0);
	scene.add(mesh2a);
	//- Plane 2b ----------------------------------------------------------------
	let mat2b = new MeshBasicNodeMaterial({
		colorNode: texture(pongPhaseTexture),
	});
	let mesh2b = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), mat2b);
	mesh2b.position.set(1.52*siz,0.51*siz,0);
	scene.add(mesh2b);
	//- Plane 3 ----------------------------------------------------------------
	let mat3 = new MeshBasicNodeMaterial({
		colorNode: texture(compSpectrumTexture),
	});
	let mesh3 = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), mat3);
	mesh3.position.set(-1.52*siz,-0.51*siz,0);
	scene.add(mesh3);
	//- Plane 4a ----------------------------------------------------------------
	let mat4a = new MeshBasicNodeMaterial({
		colorNode: texture(pingTransformTexture),
	});
	let mesh4a = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), mat4a);
	mesh4a.position.set(-0.51*siz,-0.51*siz,0);
	scene.add(mesh4a);
	//- Plane 4b ----------------------------------------------------------------
	let mat4b = new MeshBasicNodeMaterial({
		colorNode: texture(pongTransformTexture),
	});
	let mesh4b = new THREE.Mesh(new THREE.PlaneGeometry(siz,siz,seg,seg), mat4b);
	mesh4b.position.set(0.51*siz,-0.51*siz,0);
	scene.add(mesh4b);
}

//- MOVE -----------------------------------------------------------------------
function moveOcean(wavTim) {
	// 2. New Phase to PingPhase or PongPhase
	renderer.compute(pingPhase ? pingPhaseComp : pongPhaseComp);
	pingPhase = !pingPhase;
	// 3. New Spectrum from PingPhase or PongPhase
	renderer.compute(pingPhase ? pingSpectrumComp : pongSpectrumComp);
	// 4. Displacement Map (iterations = 9*2
	let iterations = Math.log2(rez); // log2(512) = 9
	let pingPong = false;
	for (let i = 0; i < iterations; i++) {	// Horizontal Ping/Pong
		pingPong = !pingPong;
		subTFSzUniform.value = Math.pow(2,(i%iterations+1));
		if (i == 0) renderer.computeAsync(initDspHrzComp);	// if first rep, then New Spectrum to PingHrz
		else {	// Otherwise, Ping/Pong
			renderer.compute(pingPong ? pingDspHrzComp : pongDspHrzComp);
		}
	}
	for (let i = 0; i < iterations; i++) {	// Vertical Ping/Pong
		pingPong = !pingPong;
		subTFSzUniform.value = Math.pow(2,(i%iterations+1));
		renderer.compute(pingPong ? pingDspVrtComp : pongDspVrtComp);	// Ping/Pong
	}
}

//= WINDOW RESIZE ==============================================================

function onWindowResize() {
	renderer.setSize(window.innerWidth, window.innerHeight);
	const aspect = window.innerWidth / window.innerHeight;
	const frustumHeight = camera.top - camera.bottom;
	camera.left = - frustumHeight * aspect / 2;
	camera.right = frustumHeight * aspect / 2;
	camera.updateProjectionMatrix();
	rendAll();
}

</script>
</body>
</html>
