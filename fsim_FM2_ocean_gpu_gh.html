<!DOCTYPE html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 29 Jan 2025

A demo of a flight simulation of an animated airplane model over animated ocean using WebGPU and NodeMaterials.
-->

<head>
<title>fsim FM2 ocean gpu r172</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Throttle: <span id="Air_Pwr"></span></div>
		<div>AirSpeed: <span id="Air_Spd"></span> mph</div>
		<div>Altitude: <span id="Air_Alt"></span> ft</div>
		<div>Heading : <span id="Air_Hdg"></span> deg</div>
		<div>CoefLift: <span id="Air_CfL"></span></div>
	</div>
	<div class="overlay2">
		<div><span id="On_Paws"></span></div>
		<div><span id="Air_AtP"></span></div>
		<div><span id="On_Inf0"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Inf1"></span></div>
		<div><span id="On_Inf2"></span></div>
		<div><span id="On_Inf3"></span></div>
		<div><span id="On_Inf4"></span></div>
		<div><span id="On_Inf5"></span></div>
		<div><span id="On_Inf6"></span></div>
		<div><span id="On_Inf7"></span></div>
		<div><span id="On_Inf8"></span></div>
		<div><span id="On_Inf9"></span></div>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script src="https://PhilCrowther.github.io/Aviation/data/fsim_FM2_ocean_gpu.js"></script>
<script src="https://PhilCrowther.github.io/Aviation/models/fm2/data/data.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.172.0/build/three.webgpu.js",
			"three/webgpu": "https://unpkg.com/three@0.172.0/build/three.webgpu.js",
			"three/tsl": "https://unpkg.com/three@0.172.0/build/three.tsl.js",
			"three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
			"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.8/dist/main.js"
		}
	}
</script>

<script type="module">

// Basic Modules
import * as THREE from "three";
import {color,texture,attribute,range,positionLocal,uv,mix,uniform,
		rotateUV,	//r168
		time,		// r170
} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement} from "three/addons/objects/LensflareMesh.js";
import Stats from "stats-gl";
// Special Modules
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdWtr4b.js"; // r171
import {Ocean} from "https://PhilCrowther.github.io/Aviation/jsm/Ocean4t2.js"; // r171 computeAsync works with r170
import {Flight,Mod360,PoM360,MaxVal,makMsh} from "https://PhilCrowther.github.io/Aviation/jsm/Flight4a.js";
import {loadACanimX,loadACanimV,moveACanimX,moveACanimV} from "https://PhilCrowther.github.io/Aviation/jsm/AnimFM2.js";
import {loadBullet,moveBullet,
		loadXACBul,moveXACBul,
		loadXSHBul,moveXSHBul,
		loadGunObj,moveGunObj
} from "https://PhilCrowther.github.io/Aviation/jsm/GunASG.js";
import {initVulkan,initShpWak} from "https://PhilCrowther.github.io/Aviation/jsm/Smoke.js";

//= GENERAL ===================================================================

/*	This flight simulation demo uses the most advanced version of three.js */

//=	FEATURES
//-	Flight Smulation
//	* Realistic Flight Simulation and AutoPilot (Flight Module)
//	* Taildragger takeoff and landing
//	* Static and Moving Landing Surfaces
//-	Scenery:
//	* Animated and Textured iFFT Ocean (Ocean and GrdMap Modules)
//	* Islands, including Volcano with Animated Smoke
//	* SunFlare
//-	My Airplane:
//	* Detailed Airplane Model - External and Internal (created in Blender)
//	* Animated Controls and Gauges - External and Internal (AnimFM2 Module)
//	* Animated Pilot
//	* 3D Sounds
//-	Traffic:
//	* Animated Traffic - Airplane and Carrier
//	* Landable Moving Carrier with animated Flag and Wake
//-	Controls:
//	* Multi-Positional Camera

//=	TO DO:
//-	Program:
//	* Move Variables to Data File (not variables which include three.js functions)
//	* Reset to starting position (r)
//	* Convert waving flag to GPU shader
//	* Flame and Smoke Trail for Damaged Airplane
//  * Add plane to simulate black/red out and for transitions
//  * XP Guns are firing even when SndFlg = 0
//-	Flight Module:
//	* Add supercharger/turbocharger effect
//	* Fix Autopilot
//= OK
//- Program:
//	* My Guns seem to be aimed too high - but if fly level, guns shoot at horizon

//=====================================|========================================
//																			   =
//							   INDEX TO SECTIONS							   =
//																			   =
//==============================================================================

//	VARIABLES (also see Data File)
//	1. MAIN VARIABLES
//	2. SKYBOX VARIABLES
//	3. GEOMAT VARIABLES
//	4. OBJECT VARIABLES
//		GRDWTR MODULE
//		OCEAN MODULE
//		WARFARE MODULE (AA Guns)
//	5. MY AIRPLANE VARIABLES
//		FLIGHT MODULE
//		ANIMFM2 MODULE
//		WARFARE MODULE (My Guns)
//	6. SOUND VARIABLES
//	7. CAMERA VARIABLES
//  8. OUTPUT VAIABLES
//	9. INPUT VARIABLES

//	PROGRAM
//	1. MAIN			Main Program
//	2. SKYBOX		SkyCube
//	3. GEOMAT		Grids and Textures
//	4. OBJECTS		Static and Moving Objects and Animations
//	5. MY AIRPLANE	My Airplane and Animations
//	6. SOUNDS		All Sounds
//	7. CAMERA		Camera Views
//	8. OUTPUTS		Screen Text and Numbers
//	9. INPUTS		Key and Mouse Inputs

//=====================================|========================================
//																			   =
//								   VARIABLES								   =
//																			   =
//==============================================================================

//= 1. MAIN VARIABLES ==========//==============================================

//- INPUTS ---------------------//----------------------------------------------
//- AIRPLANE: Start ............................................................
let BegLoc = 1;					// Starting Location (0 = Island; 1 = CVE; 2 = Air)
let CamSel = 0;					// Camera Selection (0 = External; 1 = Internal)
let BegTmp = 303.15;			// K = 86F
//- AIRPLANE: Flight ...........................................................
let PYBmul = new THREE.Vector3(0.004,1.0,0.001); // Control Multiplier for FM2
let	MosMul = new THREE.Vector3(1.0,1.0,1.0); // Adjustment to PYBmul (default = 1)
let PwrMul = 0.0005;			// Power % Input - Mouse Multiplier
let PwrDif = 0;					// Power % Input - Value
let InpBrk = 0;					// Brakes
//- Input Lag ..................................................................
//- (x = diverted, y = released, z = stored)
//-  Mouse
let LagPwr = new THREE.Vector3(1-1/30,1/15,0);	// Power
let LagCfL = new THREE.Vector3(1-1/30,1/15,0);	// CfL
let LagBnk = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- Keys
let LagAtP = new THREE.Vector3(0.967,0,0.099);	// CfL - Autopilot
//- POINTER LOCK CONTROLS ------------------------------------------------------
//- Key Vaulues (XZ = Autopilot Pitch/Bank; Y = Yaw Mouse Button or Key) .......
let	KeyVal = new THREE.Vector3(0.5,0.05,0.25); // (Yaw = turn rate in 15 deg bank)

//- CONSTANTS ------------------//----------------------------------------------
//	Conversions (Loaded from Data File)
//	Time
let	DLTime = 1/60;				// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;
let GrvDLT = GrvMPS*DLTim2;
//	Set Zero Values
let V3Zero = new THREE.Vector3(0,0,0);
let E3Zero = new THREE.Euler(0,0,0);

//- INPUT VALUES ---------------//----------------------------------------------
//- Display
let PawsOn = 0;					// Pause
let InfoOn = 0;					// Info
let SndFlg = 0;					// Sound (0 = off; 1 = on)
let StatOn = 1;					// Stats (0 = off, 1 = on)
let LnFFlg = 1;					// Lensflare
//	Program Flags
let LodFlg = 0;					// Set at end of initialization
let LodSnd = 0;					// Set when sound initialized
let MYGFlg = 0;					// My Guns (1 = firing)
//	Altitude Adjustment
let AltAdj = 0.99;				// Raises objects above map as altitude increases
let AltDif = 0;

//- SUN VALUES -----------------//----------------------------------------------
const SunCol = "white";			// Sun
let SunInt = 3;					// Default intensity of light/sun
//- Rotation and Position (fixed)
let SunDst = 50;				// Distance (for shadows)
let SunLat = 23;				// Direction - Vert (+/- 90) deg
let SunLon = 312;				// Direction - Horz (0->360) deg
//- Computations
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);
//	Shadows
let ShdBox = 6;					// Size of shadow box
let ShdBLR = 5;
let ShdBTB = 4;
let ShdDst = 1500;				// Shadow Distance (meters)

//- STANDARD SETUP -------------//----------------------------------------------
// 	Scene
const scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
// 	Light
const ambLight = new THREE.AmbientLight(SunCol,0.2);
	scene.add(ambLight);
//- SunLight
const sunLight = new THREE.DirectionalLight(SunCol,SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = SunDst*0.75;
	sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -ShdBLR;
	sunLight.shadow.camera.right = ShdBLR+1;
	sunLight.shadow.camera.top = ShdBTB;
	sunLight.shadow.camera.bottom = -ShdBTB;
//	sunLight.shadow.bias = -0.0002; // WebGPU
	sunLight.shadow.bias = -0.0005; // WebGPU
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
const camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//	Renderer
const renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);	
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
//	ToneMapping does not seem helpful
	document.body.appendChild(renderer.domElement);
let maxAnisotropy = renderer.getMaxAnisotropy();
// 	Clock
const clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
// 	Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
// 	Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
const txtrLoader = new THREE.TextureLoader(loadingManager);
const imagLoader = new THREE.ImageLoader(loadingManager);
const cubeLoader = new THREE.CubeTextureLoader(loadingManager);
const gltfLoader = new GLTFLoader(loadingManager);
// 	Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= 2. SKYBOX VARIABLES ========//==============================================

const FogCol = 0xbab4a6;		// Sky (for Fog only)
//- SkyBox
const SBxSrc = "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/";
//-	LensFlare
const LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
const LF1Src = "https://threejs.org/examples/textures/lensflare/lensflare3.png";
let LF0Txt, LF1Txt = 0;
let envMap = 0;

//= 3. GEOMAT VARIABLES ========//==============================================

//- GRDWTR TEXTURES ------------//----------------------------------------------
const WtrCol = 0x1060ff;		// Water (Nodes)
//- Textures
const DifSrc = "https://PhilCrowther.github.io/Aviation/textures/ocean/transition1F.png";
const RufSrc = "https://PhilCrowther.github.io/Aviation/textures/ocean/transition5.png";
const NrmSrc = "https://threejs.org/examples/textures/waternormals.jpg"; // Size = 1024x1024
//- Canvas (for splitting up textures)
let ImgSiz = 512;				// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext("2d",{willReadFrequently: true});
	context.translate(0, ImgSiz); // Flips vertical for three.js
	context.scale(1,-1);

//- GRDWTR MODULE --------------//----------------------------------------------
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
const GrdSiz = 1600;			// 1600 = 1 mile
const GrdRes = 512;
const GrdSeg = 256;				// Segments per Plane (256 = OK, 512 = too much)
const WavMax = 5;					// Maximum wave height (set height of outer waves)
let grids = 0;
let grd_ = {
		MSP: new THREE.Vector3(), // MSX, MPY, MSZ (meters) (from Flight)
		RCs: 16,				// Squares in each of first 2 grids
		Siz: GrdSiz,			// Size of smallest square
		Stp: 4,					// Squares in each of first 2 grids
		Seg: GrdSeg,			// Segments for smallest square
		Grx: [],				// Index of Grids (0-2)
		Geo: [],				// Master Index of Basic Geometries
		Col: new THREE.Color(WtrCol), // Color
		Dsp: 0,					// Grid 0 Displacement Map (from Ocean)
		Nrm: 0,					// Grid 0-1 Normal Map (from Ocean)
		NMS: new THREE.Vector2(),	// Grid 0-1 Normal Map Scale (from Ocean)
		Df0: [],				// Grid 0-1 Diffuse Maps
		Rf0: [],				// Grid 0-1 Roughness Maps
		Mt0: [],				// Grid 0 Materials
		Mt1: [],				// Grid 1 Materials
		Dif: 0,					// Grid 2 Diffuse Map
		Ruf: 0,					// Grid 2 Roughness Maps
		Gr2: 0,					// Grid 2 Normal Map
		Mat: [],				// Grid 2 Materials
		WMx: WavMax,			// Max wave height, used to lower outer squares
	};
//	Since textures must be loaded in the Main Program and since design of materials 
//	and goemetry can vary, some of the Grid initialization is handled in the Main Program
//  by the LoadGeoMat and InitGeoMat routines

//- OCEAN MODULE ---------------//----------------------------------------------
let WndSpd = 10.0;
let WndHdg = 90;
let Choppy = 1.5;
let AnmSpd = 0.5;				// Can vary with GrdSiz
let waves = 0;
let wav_ = {
		// Sources
		Res: GrdRes,			// Resolution - segments per square (default = 512)
		Siz: GrdSiz,			// Size of Smallest Square = default = 3200m = 2 miles
		WSp: WndSpd,			// Wind Speed
		WHd: WndHdg,			// Wind Heading (0=0,Spd; 90=Spd,0; 180=0,-Spd; 270=-Spd,0)
		Chp: Choppy,			// default = 1
		// Animated Maps
		Dsp: 0,					// The Displacement Map
		Nrm: 0,					// The Normal Map
		NMS: new THREE.Vector2(1,1), // Normal Map Scale (flip Y for left-handed maps)
		Spd: AnmSpd
	};

//= 4. OBJECT VARIABLES ========//==============================================

// Sample Variable
//let var_ = {
//		ObjNum: 1,				// Number of Objects
//		ObjSrc: [0],			// Source File
//		ObjTxt: [0],			// Texture Source File
//		ObjAdr: [0],			// Object Address
//		ObjSiz: [],				// Scale (e.g. Ft2Mtr)
//		RndOrd: [0],			// renderOrder
//		ObjRot: [new THREE.Euler(0,0,0)], // Object Rotation (in radians)
//		MapPos: [new THREE.Vector3(0,0,0)], // Map Position - Absolute or Relative
//		ObjRef: [0],			// Child: Reference to Parent or Group
//		ObjGrp: [0],			// Group: new makMsh()
		// Moving
//		SpdMPS: [0],			// Speed - if Moving (mtr/sec)
//		MapSpd: [new THREE.Vector3()], // Map Speed (mtr/sec)
		// Animations (Varies by Object)
//		ObjDst: [0],			// Object distance (meters) used to activate effects
//		MixNam: [0],			// Animation Mixer
//		AnmNam: [0]				// Animation
//	};

//= STATIC OBJECTS =============//==============================================
//- Islands --------------------//----------------------------------------------
let isl_ = {
		ObjNum: 2,
		ObjSrc: ["https://PhilCrowther.github.io/Aviation/scenery/models/homebase_ctr0.glb",
				 "https://PhilCrowther.github.io/Aviation/scenery/models/giaros.glb"],
		ObjTxt: ["https://PhilCrowther.github.io/Aviation/scenery/textures/homebase.png",
				 "https://PhilCrowther.github.io/Aviation/scenery/textures/giaros.png"],
		ObjAdr: [],
		ObjSiz: [MtrMil,1.5*MtrMil], // Scale
		RndOrd: [0,0],			// renderOrder (not used)
		ObjRot: [new THREE.Euler(),
				 new THREE.Euler()], // Rotation
		MapPos: [new THREE.Vector3(610,30,5275),
				 new THREE.Vector3(-1610,10,2440)],
		ObjGrp: [new makMsh(),new makMsh()], // Group
	};
//- Static Objects: Linked -----//----------------------------------------------
//- 0 = Hangar;
let fxd_ = {
		ObjNum: 1,
		ObjSrc: ["https://PhilCrowther.github.io/Aviation/scenery/models/hangar.glb"],
		ObjTxt: [0],
		ObjAdr: [0],			// Loaded Object
		ObjSiz: [Ft2Mtr],		// Scale
		RndOrd: [0],			// renderOrder
		ObjRot: [new THREE.Euler()], // Rotation
		MapPos: [new THREE.Vector3(-562,-22.5,-363)], // Relative Position
		ObjRef: [isl_.ObjGrp[0]],
	};

//= AA Guns ====================//==============================================
//	Bofors anti-aircraft guns - 40 mm (1.57 in)
let AAANum = 16;				// Number of bullets
let AAASpd = 850;				// Muzzle Velocity [mps = 2,800 fps]
let AAADLT = 4.0;				// Life of bullet [23,490 ft range/2800 fps]
let AAASpc = 4*AAADLT/AAANum;	// Bullet spacing
//	Adjust y-Rotation
let AARYBg = [90,0];			// Starting Y-Rotation
let AARYDf = [0,0];				// Y-Rotation Adjustment
//
let gun_ = {
		ObjNum: 2,
		ObjAdr: [new makMsh(),new makMsh()], // Gun Object
		ObjRot: [new THREE.Euler(45,90,0),
				 new THREE.Euler(30,0,0)], // Rotation (degrees)
		MapPos: [new THREE.Vector3(48,8,5638), // Absolute Position (near hangar)
				 new THREE.Vector3(-1225,5,3355)], // Absolute Position (near Giaros)
		// For Each Bullet String
		AAAFlg: [1,1],			// 1 = Gun Firing
		AAANum: AAANum,			// Number of Bullets
		AAASpd: AAASpd,			// Bullet Speed (mps)
		AAADLT: AAADLT,			// Life of bullet
		AAASpc: AAASpc,			// Bullet Spacing
		AAASp2: [AAASpc,AAASpc], // Bullet spacing time remaining
		// Bullets for each gun
		AAAPtr: [[],[]],		// Addresses of bullet objects
		AAAMpS: [[0],[0]],		// Map Speed (V3)
		AAAMpP: [[0],[0]],		// Map Position (V3)	
		AAATim: [[],[]],		// Time in flight
		// Smoke
		SmkSrc: "https://PhilCrowther.github.io/Aviation/textures/fx/aaa.png",
		SmkMap: [0,0],
		SmkMat: [0,0],
		SmkPtr: [0,0],			// AAA Smoke
		SmkRot: [0,165],		// Z-rotation of smoke
		SmkMpP: [new THREE.Vector3(), // Map Position
				 new THREE.Vector3()],
		SmkTim: [0,0],
		// Sounds
		SndFlg: [1,1],			// Gun Firing
		SndSrc: "https://PhilCrowther.github.io/Aviation/sounds/fx/aaa.mp3",
		SndPtr: [0,0],
		SndMsh: [new makMsh(),new makMsh()],
		SndVol: 15,				// Volume
	};


//- MOVING VEHICLES ------------//----------------------------------------------

//. Moving Airplanes ...........//..............................................
const XPPath = "https://PhilCrowther.github.io/Aviation/models/vehicles/";
const XP1Nam = "fm2_flyt_xp.glb"; // Name of airplane model file (rotated blender file)
const XP2Nam = "A6M_flyt_xp.glb"; // Name of airplane model file (rotated blender file)
//- Aircraft Guns
//	M2 Browning .50 caliber
let BulSpd = 887;				// Muzzle velocity [mps = 2910 fps]
let BulDLT = 0.5;				// Bullet Maximum Time in Flight
let BulNum = 16;				// Number of bullets
let BulSpc = 4*BulDLT/BulNum;	// Bullet spacing
//- Firing
let XPGMax = 120;				// Guns Firing (2 secs)
let XPGFlg = XPGMax;
let XPGMin = -600;				// Guns Not Firing (10 secs)
let xac_ = {
		ObjNum: 2,				// Number of airplanes
		ObjSrc: [XPPath+XP1Nam, // Model Source file
				 XPPath+XP2Nam],
		ObjTxt: [0,0],			// Texture Source File (not used)
		ObjAdr: [0,0],			// Object Address
		ObjSiz: [Ft2Mtr,Ft2Mtr], // Scale
		RndOrd: [0,0],			// renderOrder (not used)
		ObjRot: [new THREE.Euler(0,0,30), // Rotation
				 new THREE.Euler(0,0,30)],
		MapPos: [new THREE.Vector3(180,1524,5300), // meters
				 new THREE.Vector3(180,1524,5300)],
		ObjRef: [0,0],			// 0 = not linked
		// Speed
		SpdMPS: [91.5,91,5],	// Speed (mtr/sec) (91.5 ms = 329 kph = 205 mph)
		MapSpd: [new THREE.Vector3(), // not used
				 new THREE.Vector3()],
		// Basic Animations
		ObjDst: [0,0],			// Object distance (meters) used to activate effects
		MixSpn: [0,0],			// Animation Mixer - Prop
		MixPit: [0,0],			// Animation Mixer - Pitch
		AnmPit: [0,0],			// Animation
		MixBnk: [0,0],			// Animation Mixer - Bank
		AnmBnk: [0,0],			// Animation
		// Guns
		BulSpd: BulSpd,			// Muzzle Velocity (mps)
		BulDLT: BulDLT,			// Max Bullet Time in Flight
		BulNum: BulNum,			// Number of bullets
		BulSpc: BulSpc,			// Bullet spacing
		BulSp2: [BulSpc,BulSpc],
		BulFlg: [0,1],			// 1 = Guns Firing
		BulPtr: [[],[]],		// Bullet Objects
		BulMpS: [[0],[0]],		// Bullet Map Speed (V3)
		BulMpP: [[0],[0]],		// Bullet Map Position (V3)
		BulTim: [[],[]],		// Bullet Time in Flight
		// Engine Sounds
		EngSrc: ["fm2.wav",
				 "fm2.wav"],
		EngPtr: [0,0],
		EngMsh: [new makMsh(),new makMsh()],
		EngVol: [0.1,0.1],		// Volume
		// Gun Sounds
		SndSrc: ["fm2_gun.mp3",	// File (my guns)
				 "fm2_gun.mp3"],
		SndPtr: [0,0],
		SndVol: [0.5,0.5],		// Volume
		SndMsh: [new makMsh(),new makMsh()],		
	};

//. Moving Ships ...............//..............................................
//- Firing
let XSGMax = 600;				// Guns Firing (2 secs)
let XSGFlg = XSGMax;
let XSGMin = -600;				// Guns Not Firing (10 secs)
//-	Variables
let xsh_ = {
		ObjNum: 2,				// Number of ships
		ObjSrc: ["https://PhilCrowther.github.io/Aviation/models/vehicles/CVE_noflag.glb",
				 "https://PhilCrowther.github.io/Aviation/models/vehicles/fletcher.glb"], // Source File
		ObjTxt: [0,0],			// Texture Source File (not used)
		ObjAdr: [0,0],			// Object Address
		ObjSiz: [Ft2Mtr,		// Scale
				 Ft2Mtr],
		RndOrd: [0,0],			// renderOrder (not used)
		ObjRot: [new THREE.Euler(),  // Object Rotation
				 new THREE.Euler()],
		MapPos: [new THREE.Vector3(-4100,0.1,150),  // Object Map Position (meters) [used by Mesh]
				 new THREE.Vector3(-4200,0.2,350)],
		ObjGrp: [new makMsh(),	// Group
				 new makMsh()],
		// Speed
		SpdMPS: [9,11],			// Speed (mtr/sec) (9 ms = 34 kph = 20 mph) [top speed = 21 mph]
		MapSpd: [new THREE.Vector3(),  // Object Map Speed (mtr/sec) used by airplane if landed
				 new THREE.Vector3()],
		// Animations
		ObjDst: [0,0],			// Object distance (meters) used to activate effects
		MixRdr: [0,0],			// Animation Mixer - Radar
		AnmRdr: [0,0],			// Animation
		ShpPit: [0,0],			// Ship Pitch
		ShpLok: [new makMsh(),0], // Deck Lock
		// AA Guns
		GunPtr: [new makMsh(),new makMsh()], // Gun Object
		GunRot: [new THREE.Euler(0,90,0), // Gun Rotation
				 new THREE.Euler(45,315,0)],
		GunPos: [new THREE.Vector3(0,0,0), // Relative Map Position (meters) [used by Mesh]
				 new THREE.Vector3(0,0,0)],	
		AAASpd: AAASpd,			// Muzzle Velocity (mps)
		AAANum: AAANum,			// Number of bullets
		AAADLT: AAADLT,			// Max Bullet Time in Flight
		AAASpc: AAASpc,			// Bullet spacing
		AAASp2: [AAASpc,AAASpc],
		AAAFlg: [0,1],			// 1 = Guns Firing
		AAAPtr: [[],[]],		// Bullet Objects
		AAAMpS: [[0],[0]],		// Bullet Map Speed (V3)
		AAAMpP: [[0],[0]],		// Bullet Map Position (V3)
		AAATim: [[],[]],		// Bullet Time in Flight
		// Smoke
		SmkSrc: "https://PhilCrowther.github.io/Aviation/textures/fx/aaa.png",
		SmkMap: [0,0],
		SmkMat: [0,0],
		SmkPtr: [0,0],			// AAA Smoke
		SmkRot: [0,165],		// Z-rotation of smoke
		SmkMpP: [new THREE.Vector3(), // Map Position
				 new THREE.Vector3()],
		SmkTim: [0,0],
		// Smoke Sounds
		SndFlg: [1,1],			// Gun Firing
		SndSrc: "https://PhilCrowther.github.io/Aviation/sounds/fx/aaa.mp3",
		SndPtr: [0,0],
		SndMsh: [new makMsh(),new makMsh()],
		SndVol: 15				// Volume
	};

//- ANIMATED OBJECTS -----------//----------------------------------------------
//. Smoke ......................//..............................................
//	Can use this for Volcano or to Show Battle Damage
let vlk_ = {
		ObjNum: 1,				// Number of Smokes
		ObjSrc: [0],
		ObjTxt: ["https://PhilCrowther.github.io/Aviation/textures/fx/smoke1r.png"],
		VlkTxt: [0],
		ObjAdr: [0],
		ObjSiz: [4000],			// Scale
		RndOrd: [1],			// renderOrder
		ObjRot: [new THREE.Euler()], // Rotation (not used)
		MapPos: [new THREE.Vector3(50,75,25)], // Map Position
		ObjRef: [isl_.ObjGrp[0]], // Parent Object
		// Moving	
		SpdMPS: [0],			// 0 = not moving
		MapSpd: [new THREE.Vector3()]
	};
//. Wakes ......................//..............................................
//	Used for Ships and Torpedoes
let wak_ = {
		ObjNum: 2,				// Number of Wakes
		ObjSrc: [0,0],
		ObjTxt: ["https://PhilCrowther.github.io/Aviation/textures/fx/smoke1.png",
				 "https://PhilCrowther.github.io/Aviation/textures/fx/smoke1.png"],
		WakTxt: [0,0],
		ObjAdr: [0,0],
		ObjSiz: [4000,4000],	// Scale
		RndOrd: [1,1],			// renderOrder
		MapPos: [new THREE.Vector3(50,75,25),  // Map Position
				 new THREE.Vector3(50,75,25)],
		ObjRef: [xsh_.ObjGrp[0], // Parent Object
				 xsh_.ObjGrp[1]],
	};
//. Flags ......................//..............................................
//	Can attach to Ships or Flagpoles
let	flg_ = {
		ObjNum:	1,				// Number of Flags
		// Material and Geometry
		ObjSrc: [0],			// Geometry Address (can use this for all flags)
		ObjTxt: ["https://PhilCrowther.github.io/Aviation/models/vehicles/textures/USA_48.png"],
		ObjAdr: [0],
		ObjSiz: [0.125],		// Scale (flag height = 2 meters)
		RndOrd: [0],			// renderOrder (not used)
		ObjRot: [new THREE.Euler(0,97.5*DegRad,0)], // Adjust to make the flag visible at start
		MapPos: [new THREE.Vector3(44.2,92.47,-58.93).multiplyScalar(Ft2Mtr)], // Relative Map Position
		ObjRef: [xsh_.ObjGrp[0]], // Parent Object
		// Animation
		ObjDst: [152.4],		// Visibility Distance from Parent (meters)
		ObjAdj: [0]
	};

//- MINIMUM ALTITUDE -----------//----------------------------------------------
let alt_ = {
		Num: 2,
		Ref: [isl_.ObjGrp[0],xsh_.ObjGrp[0]],
		Var: [0,xsh_],
		Typ: [0,1], 			// 0 = stationary, 1 = moving
		Alt: [7.57,13.1],
		Lft: [-635,-13.2],
		Rgt: [-585,13.2],
		Fnt: [410,70.5],
		Bak: [-335,-70.5]
	};
//- Carrier Deck Lock Down
	xsh_.ShpLok[0].position.y = 1.4+(alt_.Alt[1]-xsh_.MapPos[0].y);
	xsh_.ObjGrp[0].add(xsh_.ShpLok[0]);

//= 5. MY AIRPLANE VARIABLES ===//==============================================

//- Flight Module --------------//----------------------------------------------
let	flight = 0;
let air_ = {
		// General Variables
		DLTime: DLTime,			// Seconds per frame (can vary)
		GrvMPS: GrvMPS,			// Gravity (ups)
		AirDSL: 0,				// Air Density (varies with altitude)
		// Designators
		AirDat: data_,			// Aircraft Data
		// Airplane Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Euler(), // Rotation (in degrees)
		AirObj: new makMsh(),	// Airplane Object 
		AirPBY: new makMsh(),	// Changes in radians
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(), // Change
		// Airplane Speed
		SpdKPH: 0,				// Speed in KPH
		SpdMPS: 0,				// Speed - meters per second
		SpdMPF: 0, 				// Speed - meters per frame	
		// Airplane Map Speed and Position		
		MapSpd: new THREE.Vector3(), // Map Speed (meters)
		MapPos: new THREE.Vector3(), // Map Position (meters)
		MapSPS: new THREE.Vector3(), // MSX, MPY, MSZ (meters)	
		// Variables Obtained from Flight
		PwrPct: 0,				// % of Primary Power (0 to 1) (Main and Flight)
		SupPct: 0,				// Percent of Supplemental Power (War Enmergency or Afterburner)
		CfLift: 0,				// Coefficient of Lift (user input) - determines lift
		CfFlap: 0,				// Coefficient of Lift due to flaps (user input)
		FlpPct: 0,				// Percent of Flaps
		LngPct: 0,				// Percent of Landing Gear
		BrkPct: 0,				// Percent of Air Brakes
		SplPct: 0,				// Percent of Spoiler
		AGBank: 0,				// Aileron Bank on Ground
		BrkVal: 0,				// Brakes
		GrdZed: 0,				// Ground level (default)
		GrdFlg: 0,				// Ground Flag (1 = on ground)
		ACPAdj: 0,				// Airplane pitch adjustment
		// Values for the Selected Airplane Type (obtained from Flight)
		CfLMax: 0,				// Maximum Coefficient of Lift
		FlpCfL: 0,				// Max Flap Cfl (0.2*CfLMax)
		ACMass: 0,				// Airplane Mass
		Weight: 0,				// Used by AutoPilot
		PYBmul: new THREE.Vector3().copy(PYBmul), // Airplane Pitch/Yaw/Bank Multiplier
		BnkMax: 0,				// Maximum bank rate
		// AutoPilot - Additional Variables
		AutoOn: 0,				// Autopilot Flag
		InpKey: new THREE.Vector3(), // Inputs - Keys (replace InpKey)
		OldRot: new THREE.Euler(), // Old Rotation (radians)
		CfLDif: 0,				// Change in CfL
		MaxBnk: 0,				// Max Bank (display only)
		HdgDif: 0,				// Horizontal Turn Rate (display only)
		// Air Density and IAS Comps
		BegTmp: BegTmp,			// Beginning Sea Level Temperature (K)
		BegPrs: 1013.25,		// Beginning Sea Level Air Pressure (mB) - not used
		SpdIAS: 0,				// Indicated Airspeed
		// Ship Pitch and Bank
		MovFlg: 0,				// If Sitting on Moving Ship
		ShpPit: 0,
		ShpBnk: 0,
	}
//	Adjustments
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY); // PBY includes air_.ACPAdj
	scene.add(air_.AirObj);	// Airplane

//- Load Models and Animations -//----------------------------------------------
//	File Path
const AirSrc = "https://PhilCrowther.github.io/Aviation/models/fm2/"; // Used to load models and sounds
//	Animation Mixers
let aoarng = 20;				// AoA range (model)
//	Animation Mixers - External Model
const AirFNm = "fm2_flyt_caf_npa.glb"; // Name of airplane model file (rotated blender file)
let mxr_ = {
		// File Name
		FNm: AirSrc + AirFNm,
		// GLTF
		GLT: 0,
		// Address
		Adr: new makMsh(),
		// Prop, Rudder, Elevator, AileronL, AileronR,  FlapL, FlapR
		Prp:0, Rdr:0, Elv:0, AiL:0, AiR:0, FlL:0, FlR:0,
		// Wheel: HingeL, HingeR, StrutBL, StrutBR, StrutTL, StrutTR, ShockL, ShockR, UpperL, UpperR
		WHL:0, WHR:0, WBL:0, WBR:0, WTL:0, WTR:0, WSL:0, WSR:0, WUL:0, WUR:0,
		// Canopy, Tailhook, SpinProp XP
		Cnp:0, THk:0
	}
//	Animation Mixers - Internal Model
const VCFile = "fm2_flyt_vcp_npa.glb"; // Name of airplane model file (rotated blender file)
let vxr_ = {
		// File Name
		FNm: AirSrc + VCFile,
		// GLTF
		GLT: 0,
		// Address
		Adr: new makMsh(),
		// Propeller, AileronL, AileronR, Canopy
		Prp:0, AiL:0, AiR:0, Cnp:0,
		// Gauge: Compass Heading, AI Arrow, AI Bank, AI Pitch, ManPrs
		GaH:0, GaA:0, GaB:0, GaP:0, GaM:0,
		// Pointer: Alt, Alt*1k, MPH, TrnInd, Ball, VSI, RPM, Heading
		PtA:0, PtB:0, PtS:0, PtT:0, PtC:0, PtV:0, PtR:0, PtH:0,
		// ArmL (T), ArmR (PB), HandL (T), HandR (P), HandR (B), 
		ArL:0, ArR:0, HLT:0, HRP:0, HRB:0,
		// LegL, LegR, RudderL, RudderR, Head
		LgL:0, LgR:0, RdL:0, RdR:0, Hed:0,
		// Old Heading, Old Altitude
		HdO:0, AlO:0,
		// Camera Distance from Reference Point
		Cam: -0.1
	}	
//- FM2 Animations -------------//----------------------------------------------
//	Loadd from "https://PhilCrowther.github.io/Aviation/data/fsim_FM2_ocean_gpu.js">

//- My Guns --------------------//----------------------------------------------
// Sounds
let myg_ = {
		// Data
		BulSpd: BulSpd,			// Muzzle Velocity (mps)
		BulDLT: BulDLT,			// Max Bullet Time in Flight
		BulNum: BulNum,			// Number of bullets
		BulSpc: BulSpc,			// Bullet spacing
		BulSp2: BulSpc,
		// Object
		BulPtr: [0],			// Bullet Objects
		BulMpS: [0],			// Bullet Speed
		BulTim: [0],			// Bullet Time in Flight
		// Sound
		ObjNum: 2,
		SndSrc: "fm2_gun.mp3",	// File (my guns)
		SndPtr: [0,0],
		SndVol: 0.5,			// Volume
		SndMsh: [new makMsh(),new makMsh()],
	}

//=	6. SOUND VARIABLES =========//==============================================
//- My Engine and Prop
let AirMsh = new makMsh();		// For Engine and Prop
//- My Engine
const EngSrc = "fm2.wav";		// File (my engine)
let EngVol = 0.1;				// Volume
let EngSnd = 0;
//- My Prop
const PrpSrc = "fm2_prop.wav";	// File (my prop)
let PrpVol = 0.5;				// Volume
let PrpSnd = 0;

//= 7. CAMERA VARIABLES ========//==============================================
//- Create Cockpit Attach Point
const CamPVC = new makMsh();
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirPBY.add(CamPVC); 	// Attach CamPVC to AirPBY (### not AirObj)
//- Camera Inputs (External Camera linked to air_.AirPBY; 1 Internal Camera Linked to cam_.PVC)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];			// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CamFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
//- Shared Variables
let cam_ = {
		CamSel: CamSel,			// View Selector (0 = External, 1 = Internal)
		CamNum: CamNum,
		OrbFlg: 0,				// Orbit Flag (1 = Orbiting)
		// Camera
		CamLLD: new THREE.Vector3().copy(CamLLD[CamSel]), // cam_.MshRot Lat, Lon, Dst
		CamAdj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		CamMMD: new THREE.Vector3().copy(CamMMD[CamSel]), // In/Out - min,max,spd
		// Rotator
		MshRot: new makMsh(),	// Camera Rotator
		CamMMR: new THREE.Vector3().copy(CamMMR[CamSel]), // Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		CamPar: CamPar[CamSel],	// Center of Rotation	
		CamFlg: CamFlg[CamSel],	// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		CamLnk: CamLnk[CamSel],
		MshObj: new makMsh(),
		MshDeg: new makMsh(),
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.MshRot.rotation.order = "YXZ";
	cam_.MshObj.rotation.order = "YXZ";
	cam_.MshDeg.rotation.order = "YXZ";
	cam_.CamPar.add(cam_.MshRot); // Attach Rotator
	cam_.MshObj.add(cam_.MshDeg);
//- Adjust Camera x.rotation
let CmAdjX = 0;					// Airborne Pitch Adjustment
let CmGrdF = 0;					// Camera Ground Flag (1 = On Ground)
let CmMulX = 35;				// Pitch Adjustment Multiplier
let CmLagX = 0;					// Transition Offset

//-	Camera View Keys -----------//----------------------------------------------
let U45flg = 0;					// Up 45 degrees
let D45flg = 0;					// Down 45 degrees
let	L45flg = 0;					// Left 45 degrees
let R45flg = 0;					// Right 45 degrees
let L90flg = 0;					// Left 90 degrees
let R90flg = 0;					// Right 90 degrees

//= 8. OUTPUT VARIABLES ========//==============================================

//- HTML OVERLAY TEXT ----------//----------------------------------------------
//	Loaded from "https://PhilCrowther.github.io/Aviation/data/fsim_FM2_ocean_gpu.js">

//- INFO DATA ------------------------------------------------------------------
//	Loaded from "https://PhilCrowther.github.io/Aviation/data/fsim_FM2_ocean_gpu.js">

//= 9. INPUT VARIABLES =========//==============================================

//- DEFAULT KEY BINDINGS -------//----------------------------------------------
//	Loadd from "https://PhilCrowther.github.io/Aviation/data/fsim_FM2_ocean_gpu.js">

//- POINTER LOCK CONTROL -------//----------------------------------------------
//	Variables
let InpMos = new THREE.Vector2(); // Inputs - Mouse
let _changeEvent = {type: "change"};
let _lockEvent = {type: "lock"};
let _unlockEvent = {type: "unlock"};
//	Class
class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement, plc_) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.addEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener("pointerlockerror", onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//. Setup ......................................................................
let controls = new PointerLockControls(camera, renderer.domElement,air_);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener( "unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

//=====================================|========================================
//																			   =
//									PROGRAM									   =
//																			   =
//==============================================================================

//= 1. MAIN PROGRAMS ===========//==============================================

	loadAll();
	
//-	0 LOAD ALL------------------//----------------------------------------------

function loadAll() {
	WaitScreen();				// load loading screen
	loadSkyBox();
	loadGeoMat();
	loadAirObj();
	AltDif = air_.MapPos.y*AltAdj; // Used by everything
	loadObject();				// load objects	
}

//- WAIT SCREEN ----------------//----------------------------------------------

function WaitScreen() {
	// Set up the loading screen scene - it can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//-	INITIALIZE -----------------//----------------------------------------------

function initAll() {
	initSkyBox();
	// Objects
	initAirObj();
	AltDif = air_.MapPos.y*AltAdj; // Used by everything
	initObject();				// Determine relative XZ location of all objects
	// Grid
	waves = new Ocean(renderer,wav_); // Init Ocean
	grd_.MSP.y = air_.MapSPS.y;
	grd_.Dsp = wav_.Dsp;
	grd_.NMS = wav_.NMS;
	grd_.Nrm = wav_.Nrm;
	grids = new GrdMap(grd_,scene);
	// Other
	initCamera(camera,cam_);	// position camera
	prntHUDval();				// print HUD values
	PawsText();
	AutoText();
	InfoText();
	// Show stats
	if (StatOn) {				// show stats
		StatOn = new Stats({
			precision: 3,
			horizontal: false
		});
		StatOn.init(renderer);
		StatOn.domElement.style.cssText = "position:absolute;top:75%;left:95%;";
		container.appendChild(StatOn.dom);
	}	
	LodFlg = 1;
}

//- RENDER ---------------------//----------------------------------------------

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;					// Stop the function here.
	}
	if (controls.isLocked === true && !LodSnd) loadSounds();
	if (!PawsOn && LodFlg && controls.isLocked === true) {
		// Update time
		nowTim = clock.getElapsedTime();
		difTim = nowTim-oldTim;
		oldTim = nowTim;
		moveCamera(camera,cam_);
		// Move Objects
		moveAirObj();			// Move aircaft
		AltDif = air_.MapPos.y*AltAdj; // Used by everything
		moveMinAlt();			// If on CVE, changes air_.Spd
		moveObject();			// Move objects
		// Move Grids
		waves.update();			// Move Ocean
		grd_.MSP.copy(air_.MapSPS);
		grids.update(grd_);		// Move Grids
		// Other
		moveSounds();
		prntHUDval();			// print HUD values
		if (StatOn) StatOn.update(); // update stats
		// Shadow Tests (confirms that shadow values changed)
		// console.log(sunLight.shadow.mapSize.width);
		// console.log(sunLight.shadow.camera.far);
	}
	if (controls.isLocked === false && LodSnd) {
		stopSounds();
		SndFlg = MYGFlg = 0;
	}
	renderer.renderAsync(scene, camera); // ### WebGPU requires Async
}

//= 2. SKYBOX ==================//==============================================

//- Load SkyBox ----------------------------------------------------------------
function loadSkyBox() {
	envMap = cubeLoader
		.setPath(SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	// LensFlare
	if (LnFFlg) {				// SunFlare	
		LF0Txt = txtrLoader.load(LF0Src);
		LF1Txt = txtrLoader.load(LF1Src);
	}
}

//- Init SkyBox ----------------------------------------------------------------
function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight("white");
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(LF0Txt,256,0));
			LF.addElement(new LensflareElement(LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

//= 3. GEOMAT ===================//==============================================
// Can't be exported since uses html context to split images
// Or can you pass address of loader to module?

function loadGeoMat() {
	// Load Diffuse Texture
	if (DifSrc) {
		// Grid0 and Grid1 - Static Color Texture - Divided into 4 Parts
		imagLoader.load(DifSrc, function(image) { // Load, Split and Save Textures
			context.drawImage(image,0,0,ImgSiz,ImgSiz);
			let idx = 0;
			let siz = ImgSiz/4;
			for (let z = 0; z < 4; z++) {
				for (let x = 0; x < 4; x++) {
					let ImgDat = context.getImageData(siz*x, siz*z, siz, siz);
					let texture = new THREE.DataTexture(ImgDat.data, siz, siz);
					texture.format = THREE.RGBAFormat;
					texture.magFilter = THREE.LinearFilter;
					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.generateMipmaps = true;
					texture.needsUpdate = true;
					grd_.Df0[idx] = texture;
					idx++;
				}
			}
		});
		// Grid2 - Static Color Map Texture
		txtrLoader.load(DifSrc, function(texture) {	// Load and Save entire Texture
			texture.format = THREE.RGBAFormat;
			texture.magFilter = THREE.LinearFilter;
			texture.minFilter = THREE.LinearMipMapLinearFilter;
			texture.generateMipmaps = true;
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.offset.set(0,0);
			texture.needsUpdate = true;
			grd_.Dif = texture;
		});
	}
	// Load Roughness Texture
	if (RufSrc) {
		// Grid0 and Grid1 - Static Color Texture - Divided into 4 Parts
		imagLoader.load(RufSrc, function(image) { // Load, Split and Save Textures
			context.drawImage(image,0,0,ImgSiz,ImgSiz);
			let idx = 0;
			let siz = ImgSiz/4;
			for (let z = 0; z < 4; z++) {
				for (let x = 0; x < 4; x++) {
					let ImgDat = context.getImageData(siz*x, siz*z, siz, siz);
					let texture = new THREE.DataTexture(ImgDat.data, siz, siz);
					texture.format = THREE.RGBAFormat;
					texture.magFilter = THREE.LinearFilter;
					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.generateMipmaps = true;
					texture.needsUpdate = true;
					grd_.Rf0[idx] = texture;
					idx++;
				}
			}
		});
		// Grid2 - Static Color Map Texture
		txtrLoader.load(RufSrc, function(texture) {	// Load and Save entire Texture
			texture.format = THREE.RGBAFormat;
			texture.magFilter = THREE.LinearFilter;
			texture.minFilter = THREE.LinearMipMapLinearFilter;
			texture.generateMipmaps = true;
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.offset.set(0,0);
			texture.needsUpdate = true;
			grd_.Ruf = texture;
		});
	}
	// Grid2 - Static Normal Map
	txtrLoader.load(NrmSrc, function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.offset.set(0,0);
		texture.repeat.set(grd_.Stp*grd_.Stp/2,grd_.Stp*grd_.Stp/2);
		texture.needsUpdate = true;
		grd_.Gr2 = texture;
	});
}

//= 4. OBJECTS =================//==============================================

function loadObject() {
	loadStatic();
	loadMoving();
	loadAnmFlg();
	loadAAAGun();
}

function initObject() {
	initStatic();
	initMoving();
}

function moveObject() {
	moveStatic();
	moveMoving();
	moveAnmObj();
	moveAAAGun();
}

//- Static Objects -------------------------------------------------------------

function loadStatic() {
	loadIsland();
	if (fxd_.ObjNum) loadFxdObj();
}

function initStatic() {
	initIsland();
}

function moveStatic() {
	moveIsland();
	if (fxd_.ObjNum) moveFxdObj();
}

//- Moving Objects -------------------------------------------------------------

function loadMoving() {
	loadMovPln();
	loadMovShp();
}

function initMoving() {
	initMovPln();
	initMovShp();
}

function moveMoving() {
	moveMovPln();
	moveMovShp();
}

//- Animated Attachments -------------------------------------------------------

function loadAnmObj() {
	loadAnmFlg();
}

function moveAnmObj() {
	moveAnmFlg();
}

//- AAA Guns -------------------------------------------------------------------

function loadAAAGun() {
	if (gun_.ObjNum) {
		gun_.SmkMap = txtrLoader.load(gun_.SmkSrc);
		loadGunObj(gun_,scene);
	}
}

function moveAAAGun() {
	if (gun_.ObjNum) {
		for (let n = 0; n < gun_.ObjNum; n ++) {	
			// Adjust Y-Rotation
			AARYDf[n] = Mod360(AARYDf[n]+0.005); // Range 0 to 360
			gun_.ObjRot[n].y = AARYBg[n] + 5*Math.sin(AARYDf[n]); // Offset = -45 to +45
		}
		moveGunObj(gun_,air_,AltDif,DLTime,GrvDLT,SndFlg);
	}
}

//= ISLANDS ====================//==============================================

//-	Load Islands ---------------------------------------------------------------
function loadIsland() {
	for (let i = 0; i < isl_.ObjNum; i++) {
		isl_.ObjGrp[i].position.copy(isl_.MapPos[i]);
		scene.add(isl_.ObjGrp[i]);
	}
	for (let i = 0; i < isl_.ObjNum; i++) {
	// Transparent Island Objects
		txtrLoader.load(isl_.ObjTxt[i], function (IslTxt) {	
			let mat = new THREE.MeshLambertNodeMaterial({colorNode: texture(IslTxt), transparent: true});
			gltfLoader.load(isl_.ObjSrc[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender island must include a UV map
					if (child.isMesh) {
						child.material = mat;
						child.receiveShadow = true;
					}
				});
				isl_.ObjAdr[i] = gltf.scene;
				isl_.ObjAdr[i].scale.setScalar(isl_.ObjSiz[i]);
				isl_.ObjAdr[i].rotation.copy(isl_.ObjRot[i]);
				isl_.ObjGrp[i].add(isl_.ObjAdr[i]);
			});
		});
	}
	// Specific Atached Objects
	loadVulkan();				// Load Volcano Smoke
}

//-	Init Islands ---------------------------------------------------------------
function initIsland() {
	let X,Y,Z;
	for (let i = 0; i < isl_.ObjNum; i++) {
		// Set Relative Position
		// (cause Objects to elevate above water as we climb to prevent flicker)
		X = isl_.MapPos[i].x-air_.MapPos.x;
		Y = isl_.MapPos[i].y-AltDif;
		Z = air_.MapPos.z-isl_.MapPos[i].z;
		isl_.ObjGrp[i].position.set(X,Y,Z);
	}
}

//-	Move Islands ---------------------------------------------------------------
function moveIsland() {
	let X,Y,Z;
	for (let i = 0; i < isl_.ObjNum; i ++) {
		// Compute New Relative Position
		// (cause Islands to elevate above water as we climb to prevent flicker)
		X = isl_.MapPos[i].x-air_.MapPos.x;
		Y = isl_.MapPos[i].y-AltDif;
		Z = air_.MapPos.z-isl_.MapPos[i].z;
		isl_.ObjGrp[i].position.set(X,Y,Z);
	}
}

//= VOLCANO SMOKE ==============//==============================================

//- Load Volcano ---------------------------------------------------------------
function loadVulkan() {
	vlk_.VlkTxt[0] = txtrLoader.load(vlk_.ObjTxt[0]);
	initVulkan(vlk_);
}

//= STATIC OBJECTS =============//==============================================

//- Load Objects ---------------//----------------------------------------------
function loadFxdObj() {
	for (let i = 0; i < fxd_.ObjNum; i++) {
		gltfLoader.load(fxd_.ObjSrc[i], function (gltf) {
			fxd_.ObjAdr[i] = gltf.scene;
			fxd_.ObjAdr[i].scale.setScalar(fxd_.ObjSiz[i]);
			fxd_.ObjAdr[i].rotation.copy(fxd_.ObjRot[i]);
			fxd_.ObjAdr[i].position.copy(fxd_.MapPos[i]);
			fxd_.ObjRef[i].add(fxd_.ObjAdr[i]);
		});
	}
}

//- Move Objects ---------------//----------------------------------------------
function moveFxdObj() {
	for (let i = 0; i < fxd_.ObjNum; i++) {
		fxd_.ObjAdr[i].position.y = fxd_.MapPos[i].y + AltDif*0.01;
	}
}

//= MOVING AIRPLANES ===========//==============================================

//-	Load Airplane --------------------------------------------------------------
function loadMovPln() {
	for (let n = 0; n < xac_.ObjNum; n ++) {
		gltfLoader.load(xac_.ObjSrc[n], function (gltf) {
			xac_.ObjAdr[n] = gltf.scene;
			// Convert from feet to meters
			xac_.ObjAdr[n].scale.setScalar(xac_.ObjSiz[n]);
			// Propeller
			let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
			xac_.MixSpn[n] = new THREE.AnimationMixer(xac_.ObjAdr[n]);
			let actun = xac_.MixSpn[n].clipAction(clip);
			actun.play();
			if (xac_.MixSpn[n]) xac_.MixSpn[n].setTime(anm_.spnprp/anm_.anmfps);
			// Bank
			clip = THREE.AnimationClip.findByName(gltf.animations, "AC_BankAction");
			xac_.MixBnk[n] = new THREE.AnimationMixer(xac_.ObjAdr[n]);
			actun = xac_.MixBnk[n].clipAction(clip);
			actun.play();
			if (xac_.MixBnk[n]) xac_.MixBnk[n].setTime(xac_.AnmBnk[n]/anm_.anmfps);
			// Pitch
			clip = THREE.AnimationClip.findByName(gltf.animations, "AC_PtchAction");
			xac_.MixPit[n] = new THREE.AnimationMixer(xac_.ObjAdr[n]);
			actun = xac_.MixPit[n].clipAction(clip);
			actun.play();
			if (xac_.MixPit[n]) xac_.MixPit[n].setTime(xac_.AnmPit[n]/anm_.anmfps);
			// Rotation
			xac_.ObjAdr[n].rotation.order = "YXZ"; // Heading, Pitch, Bank
			xac_.ObjAdr[n].rotation.y = xac_.ObjRot[n].y*DegRad;
			//
			xac_.ObjAdr[n].add(xac_.EngMsh[n]);	// Engine sound
		});
	}
}

//- Init Airplane --------------------------------------------------------------
function initMovPln() {
	for (let n = 0; n < xac_.ObjNum; n ++) {
		// Compute Relative Position
		// (cause Objects to elevate above water as we climb to prevent flicker)
		let X = xac_.MapPos[n].x-air_.MapPos.x;
		let Y = xac_.MapPos[n].y-AltDif;
		let Z = air_.MapPos.z-xac_.MapPos[n].z;
		xac_.ObjAdr[n].position.set(X,Y,Z);
		scene.add(xac_.ObjAdr[n]);
	};
	loadXACGun();
}

//- Move Plane -----------------------------------------------------------------
function moveMovPln() {
	for (let n = 0; n < xac_.ObjNum; n ++) {
		// Rotation
		let XPHSpd = Math.tan(xac_.ObjRot[n].z*DegRad)*xac_.SpdMPS[n]/GrvMPS;
		XPHSpd = XPHSpd * DLTime;
		xac_.ObjRot[n].y = xac_.ObjRot[n].y + XPHSpd;
		xac_.ObjAdr[n].rotation.set(0,xac_.ObjRot[n].y*DegRad,xac_.ObjRot[n].z*DegRad);
		// Speed (Only Horizontal for Now)
		let SpdMPF = xac_.SpdMPS[n] * DLTime; // Speed (m/t)
		let SpeedZ = -SpdMPF * Math.cos(xac_.ObjRot[n].y * DegRad);
		let SpeedX = -SpdMPF * Math.sin(xac_.ObjRot[n].y * DegRad);
		// Recompute Map Position
		xac_.MapPos[n].x = xac_.MapPos[n].x + SpeedX;
		xac_.MapPos[n].z = xac_.MapPos[n].z - SpeedZ;
		// Animation - Prop (same as mine)
		if (xac_.MixSpn[n]) xac_.MixSpn[n].setTime(anm_.spnprp/anm_.anmfps);
		// Compute New Relative Position
		let X = xac_.MapPos[n].x-air_.MapPos.x;
		let Y = xac_.MapPos[n].y-AltDif;
		let Z = air_.MapPos.z-xac_.MapPos[n].z;
		xac_.ObjAdr[n].position.set(X,Y,Z);
	}
	moveXACGun();
}

//= AIRPLANE GUNS ==============//==============================================

//- Load Airplane Guns ---------//----------------------------------------------
function loadXACGun() {
	loadXACBul(xac_,scene);
}

//- Move Airplane Guns ---------//----------------------------------------------
function moveXACGun() {
	// Turn Airplane 2 (Enemy) Guns On/Off
	xac_.BulFlg[1] = 0;			// Default = Off
	let MinDst = 500;
	// Counter
	XPGFlg = XPGFlg - 1;
	if (XPGFlg < XPGMin) XPGFlg = XPGMax;
	// On or Off	
	if (xac_.ObjAdr[1].position.x < MinDst && 
		xac_.ObjAdr[1].position.y < MinDst && 
	    xac_.ObjAdr[1].position.z < MinDst)
	    {
		if (XPGFlg > 0) xac_.BulFlg[1] = 1;
		else {xac_.BulFlg[1] = 0;}
	}
	moveXACBul(xac_,air_,AltDif,DLTime,GrvDLT);
}

//= MOVING SHIPS ===============//==============================================

//	Load Ship
function loadMovShp() {
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		gltfLoader.load(xsh_.ObjSrc[n], function (gltf) {
			gltf.scene.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
				}
			});
			xsh_.ObjAdr[n] = gltf.scene;
			xsh_.ObjAdr[n].scale.setScalar(xsh_.ObjSiz[n]); // Scale
			// Animated Radar
			if (n == 0) {
				// Radar
				let clip = THREE.AnimationClip.findByName(gltf.animations, "RadarAction");
				xsh_.MixRdr[n] = new THREE.AnimationMixer(xsh_.ObjAdr[n]);
				let actun = xsh_.MixRdr[n].clipAction(clip);
				actun.play();
				if (xsh_.MixRdr[n]) xsh_.MixRdr[n].setTime(xsh_.AnmRdr[n]/anm_.anmfps);
				// Wake
				loadShpWak(); // Init Ship Wake
				loadShpGun();
			}
			xsh_.ObjAdr[n].position.set(0,0,0); // position within group is always 0,0,0
		});
	}
}

//	Init Ship
function initMovShp() {
// Always use group
	let X, Y, Z;
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		xsh_.ObjGrp[n].rotation.order = "YXZ";
		// Compute Relative Position
		// (cause Objects to elevate above water as we climb to prevent flicker)
		X = xsh_.MapPos[n].x-air_.MapPos.x;
		Y = xsh_.MapPos[n].y-AltDif;
		Z = air_.MapPos.z-xsh_.MapPos[n].z;
		xsh_.ObjGrp[n].position.set(X,Y,Z);
		xsh_.ObjGrp[n].add(xsh_.ObjAdr[n]);
		scene.add(xsh_.ObjGrp[n]);		// Uses position of CVE to compute relative position
	}
}

//	Move Ship
function moveMovShp() {
	let X, Y, Z;
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		// Change in Heading
		let XSHSpd = 0;		// for now
		let XSHPit = 0;
		XSHSpd = XSHSpd * DLTime;
		xsh_.ObjRot[n].y = xsh_.ObjRot[n].y + XSHSpd;	
		// Rock the boat
		if (n == 0) {
			xsh_.ShpPit[n] = Mod360(xsh_.ShpPit[n] + 0.5);
			let PitAdj = 1.5*DegRad*Math.sin(xsh_.ShpPit[n]*DegRad);
			xsh_.ObjRot[n].x = PitAdj;
			xsh_.ObjGrp[n].rotation.copy(xsh_.ObjRot[n]);
		}
		// Speed (Only Horizontal)
		let SpdMPF = xsh_.SpdMPS[n] * DLTime; // Speed (u/t)
		xsh_.MapSpd[n].z = -SpdMPF * Math.cos(xsh_.ObjRot[n].y*DegRad);
		xsh_.MapSpd[n].x = -SpdMPF * Math.sin(xsh_.ObjRot[n].y*DegRad);
		// Recompute Map Postion
		xsh_.MapPos[n].x = xsh_.MapPos[n].x + xsh_.MapSpd[n].x;
		xsh_.MapPos[n].z = xsh_.MapPos[n].z - xsh_.MapSpd[n].z;
		// Compute New Relative Position
		X = xsh_.MapPos[n].x-air_.MapPos.x;
		Y = xsh_.MapPos[n].y-AltDif;
		Z = air_.MapPos.z-xsh_.MapPos[n].z;
		xsh_.ObjGrp[n].position.set(X,Y,Z);
		// Compute Distance (for Viz Tests)
		X = xsh_.ObjGrp[n].position.x;
		Z = xsh_.ObjGrp[n].position.z;
		xsh_.ObjDst[n] = Math.sqrt(X*X+Z*Z); // Compute distance
		// Attached Objects
		if (n == 0) {
			// Radar
			xsh_.AnmRdr[n] = xsh_.AnmRdr[n] - 0.1;
			if (xsh_.AnmRdr[n] < 0) xsh_.AnmRdr[n] = 359;
			if (xsh_.MixRdr[n]) xsh_.MixRdr[n].setTime(xsh_.AnmRdr[n]/anm_.anmfps);
			// Wake
			moveShpWak();
			moveShpGun();
		}
	}
}

//= SHIP WAKE ==================//==============================================

//- Load Ship Wake -------------------------------------------------------------
function loadShpWak() {
	for (let n = 0; n < wak_.ObjNum; n ++) {
		wak_.WakTxt[n] = txtrLoader.load(wak_.ObjTxt[n]);
	}
	initShpWak(wak_);
};

//- Move Ship Wake -------------------------------------------------------------
function moveShpWak() {
	for (let n = 0; n < wak_.ObjNum; n ++) {
		wak_.ObjAdr[n].rotation.x = Math.PI/2-wak_.ObjRef[n].rotation.x;
	}
}

//= SHIP GUNS ==================================================================

//- Load Ship Guns -------------------------------------------------------------
function loadShpGun() {
	xsh_.SmkMap = txtrLoader.load(xsh_.SmkSrc);
	loadXSHBul(xsh_,scene);

}

//- Move Ship Guns -------------------------------------------------------------
function moveShpGun() {
	// Turn Ship 2 Guns On/Off
	XSGFlg = XSGFlg - 1;
	if (XSGFlg > 0) xsh_.AAAFlg[1] = 1;
	else {
		xsh_.AAAFlg[1] = 0;
		if (XSGFlg < XSGMin) XSGFlg = XSGMax;
	}
	moveXSHBul(xsh_,air_,AltDif,DLTime,GrvDLT,SndFlg);
}

//= ANIMATED FLAGS =============//==============================================
//	Adapted from example at https://codepen.io/okada-web/pen/OJydGzy. Thanks!

//-	Load and Initialize Flags --//----------------------------------------------
function loadAnmFlg() {
	let flgSzX = 30;			// Size X
	let flgSzY = 16;			// Size Y
	let flgSgX = 30;			// Segments X
	let flgSgY = 16;			// Segments Y
	let FlgGeo = new THREE.PlaneGeometry(flgSzX,flgSzY,flgSgX,flgSgY);
	// For Each Flag
	for (let n = 0; n < flg_.ObjNum; n++) {
		txtrLoader.load(flg_.ObjTxt[n], function(FlgTxt) {
			FlgTxt.format = THREE.RGBAFormat;
			FlgTxt.magFilter = THREE.LinearFilter;
			FlgTxt.minFilter = THREE.LinearMipMapLinearFilter;
			FlgTxt.generateMipmaps = true;
			FlgTxt.needsUpdate = true;
			let flgMat = new THREE.MeshLambertNodeMaterial({colorNode: texture(FlgTxt), side: THREE.DoubleSide});
			flg_.ObjSrc[n] = FlgGeo;
			flg_.ObjSrc[n].rotateY(180*DegRad);
			flg_.ObjAdr[n] = new THREE.Mesh(flg_.ObjSrc[n],flgMat);
			flg_.ObjAdr[n].rotation.copy(flg_.ObjRot[n]);
			flg_.ObjAdr[n].position.copy(flg_.MapPos[n]);
			flg_.ObjAdr[n].scale.setScalar(flg_.ObjSiz[n]); // Height = 2 meters
			flg_.ObjRef[n].add(flg_.ObjAdr[n]); // Attach to Object
			flg_.ObjAdr[n].visible = true;
		});
	}
}

//-	Move Flag Meshes -----------//----------------------------------------------
function moveAnmFlg() {
//	let n = 0;
	for (let n = 0; n < flg_.ObjNum; n++) {
		let flgSgX = 30;		// Segments X
		let flgSgY = 16;		// Segments Y
		// Get Distance to Parent Object
		let flgPsX = Math.abs(flg_.ObjAdr[n].position.x);
		let flgPsY = Math.abs(flg_.ObjAdr[n].position.y);
		let flgPsZ = Math.abs(flg_.ObjAdr[n].position.z);
		let MinDst = flg_.ObjDst[n];
		// Only Animate if Within Min Distance to Parent Object
		if (flgPsX < MinDst && flgPsY < MinDst && flgPsZ < MinDst) {
			flgSgX = flgSgX+1;
			flgSgY = flgSgY+1;		
			let h = 0.5; 		// Horizontal
			let v = 0.3; 		// Vertical
			let w = 0.075; 		// Swing
			let s = 400; 		// Speed
			let idx,val;
			let tim = nowTim*s/50;	
			for (let y = 0; y < flgSgY; y++) {
				for (let x = 0; x < flgSgX; x++) {
	            	idx = x + y*(flgSgX);
					val = Math.sin(h*x+v*y-tim)*w*x/4;
					flg_.ObjSrc[n].attributes.position.setZ(idx,val);
	            }
	        }
			flg_.ObjSrc[n].attributes.position.needsUpdate = true;
			flg_.ObjSrc[n].computeVertexNormals();
		}
		// Rotate Flag on Flagpole
		flg_.ObjAdj[n] = Mod360(flg_.ObjAdj[n]+3); // Degrees
		let FlgAdj = 2.5*DegRad*Math.sin(flg_.ObjAdj[n]*DegRad); // Max Offset = 5 deg
		flg_.ObjAdr[n].rotation.y = flg_.ObjRot[n].y+FlgAdj;
	}
}

//= HARDENED SURFACES ==========//==============================================
// The hardened surfaces are the Home Airfield and the CVE Deck (moving)
// Where CVE not facing north, can we rotate ref points and airplane to north?

// Compute Minimum Altitude
function moveMinAlt() {
	air_.GrdZed = 0;			// Default
	let PX,PZ;
	let Msh = 0;
	for (let i = 0; i < alt_.Num; i++) {
		Msh = alt_.Ref[i];
		PX = -Msh.position.x;
		PZ = Msh.position.z;
		if (alt_.Lft[i] < PX && alt_.Rgt[i] > PX && alt_.Fnt[i] > PZ && alt_.Bak[i] < PZ) {
			air_.GrdZed = alt_.Alt[i];
			if (alt_.Typ[i]) moveShpAlt();
		}
	}
}

function moveShpAlt() {
	InpBrk = 0;					// Default = no brake
	air_.ShpPit = 0;			// Default
	// Recompute GrdZed
	let ZDst = xsh_.MapPos[0].z - air_.MapPos.z; // Z-distance from ship center
	let YDif = ZDst * Math.sin(xsh_.ObjRot[0].x); // Y-change caused by ship pitch
	air_.GrdZed = alt_.Alt[1] - YDif;
	//
	if (air_.GrdFlg) {		// If Landed
		if (air_.PwrPct < 0.5 && anm_.thkpos < 180) InpBrk = 0.01; // Auto-braking if power < 50% and hook extended
		let ShpKPH = xsh_.SpdMPS[0]*3.6; // Ship speed
		if (!air_.MovFlg) {
			if (air_.SpdKPH <= ShpKPH) { // If airplane speed <= Ship speed, lock to deck	
				air_.MovFlg = 1; // Flag
				InpBrk = 0;	// Brake off
				let XOff = air_.MapPos.x - xsh_.MapPos[0].x;
				let ZOff = air_.MapPos.z - xsh_.MapPos[0].z; // Z-distance from ship center
				xsh_.ShpLok[0].position.x = XOff;
				xsh_.ShpLok[0].position.z = ZOff;
				xsh_.ShpLok[0].add(air_.AirObj);
				if (anm_.thkpos < 180) anm_.thkspd = 1;	// Retract tailhook
			}
		}
		if (air_.MovFlg && air_.SpdKPH > ShpKPH) air_.MovFlg = 0; // Unlock from deck if moving faster than Ship
		if (air_.MovFlg) {	// Otherwise remain locked to deck
			sunLight.shadow.camera.far = SunDst+2*ShdBox; // Default on deck
			// Recompute Speed and Position
			air_.MapSpd.z = -xsh_.MapSpd[0].z;
			air_.MapSpd.x = -xsh_.MapSpd[0].x;
			air_.MapPos.z = air_.MapPos.z + air_.MapSpd.z;
			air_.MapPos.x = air_.MapPos.x + air_.MapSpd.x;
			air_.MapSPS.x = air_.MapSpd.x;
			air_.MapSPS.z = air_.MapSpd.z;			
			// Recompute air_.Spd
			if (air_.PwrPct < 0.5) {
				air_.SpdKPH = air_.SpdMPS = 0;
				air_.ShpPit = -xsh_.ObjRot[0].x;
			}
			else {
				air_.SpdKPH = ShpKPH; // (KPH)
				air_.SpdMPS = air_.SpdKPH/3.6; // (mps)
				xsh_.ShpLok[0].remove(air_.AirObj); // Unlock
				scene.add(air_.AirObj); // Was detached from scene
				if (!cam_.CamSel) sunLight.shadow.camera.far = SunDst+ShdBox+ShdDst;		
			}
			sunLight.shadow.camera.updateProjectionMatrix();
			// Point Same Direction as Carrier
			// [WIP]
		}
	}
}

//= 5. MY AIRPLANE ================//==============================================

//= Load Airplane ==============//==============================================
function loadAirObj() {
	loadAirExt();
	loadAirInt();
}

//-	Load Airplane Model --------------------------------------------------------
function loadAirExt() {
	gltfLoader.load(mxr_.FNm, function (gltf) {
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.material.envMap = envMap; // ??? required?
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (child.name == "propeller" ||
				child.name == "canopy1glass" ||
				child.name == "canopy2glass")
			{
				child.castShadow = false;
				child.receiveShadow = false;
				child.renderOrder = 1;
			}
		});
		mxr_.GLT = gltf;
		mxr_.Adr = gltf.scene;
		mxr_.Adr.rotation.order = "YXZ";
		mxr_.Adr.scale.setScalar(Ft2Mtr);
		loadACanimX(air_,mxr_,anm_);
		air_.AirPBY.add(mxr_.Adr);
		// Initialize
		mxr_.Adr.visible = false;
		// Load Related Objects only after mxr_.Adr known
		loadBullet(myg_,scene);
	});		
}

//-	Load Virtual Cockpit -------------------------------------------------------
function loadAirInt() {
	gltfLoader.load(vxr_.FNm, function (gltf) {
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (child.name == "propeller" ||
				child.name == "glass")
			{
				child.castShadow = false;
				child.receiveShadow = false;
				child.renderOrder = 1;
			}
		});
		vxr_.GLT = gltf;
		vxr_.Adr = gltf.scene;
		vxr_.Adr.rotation.order = "YXZ";
		vxr_.Adr.scale.setScalar(Ft2Mtr);
		loadACanimV(vxr_,anm_);
		air_.AirPBY.add(vxr_.Adr);	
		// Initialize
		vxr_.Adr.visible = true;
	});
}	

//= Init Airplane ==============//==============================================
// This section initializes starting location and variables before passing to Flight Module
function initAirObj() {
	//	Starting Location
	if (BegLoc == 0) { 			// Base
		air_.GrdFlg = 1;
		air_.MapPos.x = isl_.MapPos[0].x-610;
		air_.MapPos.z = isl_.MapPos[0].z-275;	
		air_.MapPos.y = air_.GrdZed = alt_.Alt[0];
		anm_.lngpos = 0;		// Landing Gear Down
		anm_.flppos = 180;		// Flaps Up
	}
	if (BegLoc == 1) { 			// CVE
		air_.GrdFlg = air_.MovFlg = 1;
		air_.MapPos.copy(xsh_.MapPos[0]);
		air_.MapPos.y = air_.GrdZed = alt_.Alt[1];
		let ZDst = 45;
		air_.MapPos.z = air_.MapPos.z - ZDst;
		xsh_.ShpLok[0].position.z = ZDst;
		xsh_.ShpLok[0].add(air_.AirObj);
		anm_.lngpos = 0;		// Landing Gear Down
		anm_.flppos = 0;		// Flaps Down
	}
	if (BegLoc == 2) { 			// Air
		PwrDif = 1000;
		air_.SpdKPH = 200;
		air_.MapPos.y = air_.MapSPS.y = 200;
		anm_.lngpos = 180; 		// Landing Gear Up
		anm_.flppos = 180;		// Flaps Up
	}
	// Speed
	if (air_.SpdKPH) {
		air_.SpdMPS = air_.SpdKPH/3.6; // Speed - meters per second
		air_.SpdMPF = (air_.SpdKPH/3.6)*DLTime; // Speed - meters per frame
	}
	// Altitude
	if (air_.MapPos.y == 0) air_.GrdFlg = 1;
	grd_.MSP.y = air_.MapPos.y; // Use to initialize objects
	// Flight
	flight = new Flight(air_);	// position airplane using air_.GrdZed
	air_.PYBmul.x = air_.PYBmul.x*MosMul.x;	// Pitch Adjustment
	air_.PYBmul.z = air_.PYBmul.x*MosMul.z;	// Bank Adjustment
}

//= Move Airplane ==============//==============================================
// This section processes Input before passing to Flight Module
// And manages Views and Animations
function moveAirObj() {
	// Compute Inputs ----------------------------------------------------------
	// Power Percent ...........................................................
	// Add Delay
	let gal = PwrDif * LagPwr.x; // Current input delayed
	let lag = LagPwr.y * LagPwr.z; // Released from Cumulator
	LagPwr.z = LagPwr.z + gal - lag; // Change in Cumulator
	PwrDif = PwrDif - gal + lag;
	// Input Engine Power
	air_.PwrPct = air_.PwrPct + PwrDif;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	PwrDif = 0;					// Reset
	// Coefficient of Lift .....................................................
	if (air_.AutoOn) {			// Autopilot
		air_.CfLDif = air_.InpKey.x;
		// Add Delay to Lift
		gal = air_.CfLDif * LagAtP.x; // Current input delayed
		lag = LagCfL.y * LagAtP.z; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	else {
		air_.CfLDif = (InpMos.y)*air_.PYBmul.x;	// Input Coefficient of Lift
		// Add Delay to Lift
		gal = air_.CfLDif * LagCfL.x; // Current input delayed
		lag = LagCfL.y * LagCfL.z; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	air_.CfLDif = air_.CfLDif - gal + lag;
	air_.CfLift = air_.CfLift + air_.CfLDif; // New Coefficient of Lift	
	// Limits
	if (air_.CfLift > air_.CfLMax) air_.CfLift = air_.CfLMax;
	if (air_.CfLift < -air_.CfLMax) air_.CfLift = -air_.CfLMax;
	anm_.stkpit = InpMos.y;		// Joystick pitch animation
	InpMos.y = 0;				// Reset
	// Coefficient of Lift - Flaps
	air_.CfFlap = air_.FlpCfL*(180-anm_.flppos)/180; // [Flap]
	// Bank ....................................................................
	if (air_.AutoOn) {
		air_.RotDif.z = air_.InpKey.z;
		air_.OldRot.z = air_.OldRot.z + air_.RotDif.z*DegRad;
	}
	else {
		// Add Delay to Change in Bank Rate due to Mouse
		let BnkDif = InpMos.x * air_.PYBmul.z;
		gal = BnkDif * LagBnk.x; // Current input delayed
		lag = LagBnk.y * LagBnk.z; // Released from Cumulator
		LagBnk.z = LagBnk.z + gal - lag; // Change in Cumulator
		BnkDif = BnkDif - gal + lag;
		air_.RotDif.z = air_.RotDif.z + BnkDif;	
		air_.RotDif.z = MaxVal(air_.RotDif.z,air_.BnkMax);	// Max values
		if (air_.RotDif.z == air_.BnkMax && BnkDif < 0) air_.RotDif.z = BnkDif;
		if (air_.RotDif.z == -air_.BnkMax && BnkDif > 0) air_.RotDif.z = BnkDif;
		air_.RotDif.z = air_.RotDif.z; // Inputs are +/-
		air_.AGBank = air_.RotDif.z;
		anm_.stkbnk = InpMos.x;	// Joystick bank animation
		InpMos.x = 0;			// Reset
	}
	// Input Yaw
	if (air_.SpdKPH < 1) air_.RotDif.y = 0;	// No Yaw if Speed < 1;
	// Input Brakes
	air_.BrkVal = InpBrk;		// Brakes
	// Compute Rotation and Vectors --------------------------------------------
	flight.update();
	// View Keys ---------------------------------------------------------------
	if (!cam_.OrbFlg) {			// Only If Not Orbiting		
		// If No Keys Pressed, Set Default View
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg < 1)	{
			if (cam_.CamFlg) cam_.CamLLD.x = 0; // Internal view
			else cam_.CamLLD.x = -12.5; // External view
			cam_.CamLLD.y = 0;
		}
		// Down 45
		else if (D45flg) {
			cam_.CamLLD.x = 0;
			// Look Back
			if ((L90flg) && (L90flg) && (R90flg)) cam_.CamLLD.y = 180;
			// Look Back Left 90 + 45
			else if (L90flg) cam_.CamLLD.y = 135;
			// Look Back Right 270 - 45
			else if (R90flg) cam_.CamLLD.y = 225;
			// Look Down
			else {
				cam_.CamLLD.y = 0;
				cam_.CamLLD.x = 45;
			}
		}
		// Up 45
		else if (U45flg) {
			cam_.CamLLD.x = 315;
			if (!cam_.CamFlg && (air_.GrdFlg)) cam_.CamLLD.x = 0;
			// Look Up Left 45
			if (L45flg) cam_.CamLLD.y = 45;
			// Look Up Right 45
			else if (R45flg) cam_.CamLLD.y = 315;
			// Look Up Left 90
			else if (L90flg) cam_.CamLLD.y = 90;
			// Look Up Right 90
			else if (R90flg) cam_.CamLLD.y = 270;
			// Look Up
			else cam_.CamLLD.y = 0;
		}
		// Level
		else {
			cam_.CamLLD.x = 0;
			// Look Left 45
			if (L45flg) cam_.CamLLD.y = 45;
			// Look Right 45
			else if (R45flg) cam_.CamLLD.y = 315;
			// Look Left 90
			else if (L90flg) cam_.CamLLD.y = 90;
			// Look Right 90
			else if (R90flg) cam_.CamLLD.y = 270;
		}
	}
	// Animate -----------------------------------------------------------------	
	if (cam_.CamFlg) moveACanimV(air_,vxr_,anm_,cam_.CamLLD); // VC
	else moveACanimX(air_,mxr_,anm_); // External
	// Attached Objects
	moveBullet(myg_,air_,DLTime,GrvDLT,MYGFlg);
}

//= 6. SOUNDS ==================//==============================================

//- Load and Initialize Sounds -------------------------------------------------
function loadSounds() {
	// Load Sounds .............................................................
	let audioLoader = new THREE.AudioLoader();
	let RefDst = 25;			// Reference distance for Positional Audio
	// My Engine
	let fname = AirSrc + "sounds/" + EngSrc;
	audioLoader.load(fname, function(buffer) {
		EngSnd.setBuffer(buffer);
		EngSnd.setRefDistance(RefDst);
		EngSnd.setLoop(true);
		EngSnd.setVolume(0);
	});
	// My Prop
	fname = AirSrc + "sounds/" + PrpSrc;
	audioLoader.load(fname, function(buffer) {
		PrpSnd.setBuffer(buffer);
		PrpSnd.setRefDistance(RefDst);
		PrpSnd.setLoop(true);
		PrpSnd.setVolume(0);
	});
	// My Guns (Left and Rite)
	fname = AirSrc + "sounds/" + myg_.SndSrc;
	for (let n = 0; n < myg_.ObjNum; n ++) {
		audioLoader.load(fname, function(buffer) {
			myg_.SndPtr[n].setBuffer(buffer);
			myg_.SndPtr[n].setRefDistance(RefDst);
			myg_.SndPtr[n].setLoop(true);
			myg_.SndPtr[n].setVolume(0);
		});
	}
	// XP Engines
	for (let n = 0; n < xac_.ObjNum; n ++) {
		fname = XPPath + "sounds/" + xac_.EngSrc[n];	
		audioLoader.load(fname, function(buffer) {
			xac_.EngPtr[n].setBuffer(buffer);
			xac_.EngPtr[n].setRefDistance(RefDst); // Distance at which sound is full volume
			xac_.EngPtr[n].setLoop(true);
			xac_.EngPtr[n].setVolume(0);
			xac_.EngPtr[n].playbackRate = 1.3;
		});
	}
	// XP Guns
	for (let n = 0; n < xac_.ObjNum; n ++) {
		fname = XPPath + "sounds/" + xac_.SndSrc[n];	
		audioLoader.load(fname, function(buffer) {
			xac_.SndPtr[n].setBuffer(buffer);
			xac_.SndPtr[n].setRefDistance(RefDst); // Distance at which sound is full volume
			xac_.SndPtr[n].setLoop(true);
			xac_.SndPtr[n].setVolume(0);
			xac_.SndPtr[n].playbackRate = 1.3;
		});	
	}
	// XS Guns - Smoke Sounds
	fname = xsh_.SndSrc;
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		audioLoader.load(fname, function(buffer) {
			xsh_.SndPtr[n].setBuffer(buffer);
			xsh_.SndPtr[n].setRefDistance(RefDst);
			xsh_.SndPtr[n].setVolume(0);
		});	
	}
	// AA Guns
	fname = gun_.SndSrc;
	for (let n = 0; n < gun_.ObjNum; n ++) {
		audioLoader.load(fname, function(buffer) {
			gun_.SndPtr[n].setBuffer(buffer);
			gun_.SndPtr[n].setRefDistance(RefDst);
			gun_.SndPtr[n].setVolume(0);
		});	
	}
	// Init Sounds .............................................................
	let listener = new THREE.AudioListener();
	camera.add(listener);
	//- My Engine and Prop
	EngSnd = new THREE.PositionalAudio(listener);
	PrpSnd = new THREE.PositionalAudio(listener);
	AirMsh.add(EngSnd);			// Engine
	AirMsh.add(PrpSnd);			// Prop
	AirMsh.position.z = -5;
	air_.AirObj.add(AirMsh);
	//- My Guns (Left and Rite)
	for (let n = 0; n < myg_.ObjNum; n ++) {
		myg_.SndPtr[n] = new THREE.PositionalAudio(listener);
		myg_.SndMsh[n].add(myg_.SndPtr[n]);
		myg_.SndMsh[n].position.x = -5;
		air_.AirObj.add(myg_.SndMsh[n]);
	}
	//- XP Engines
	for (let n = 0; n < xac_.ObjNum; n ++) {
		xac_.EngPtr[n] = new THREE.PositionalAudio(listener);
		xac_.EngMsh[n].add(xac_.EngPtr[n]);
	}
	//- XP Guns
	for (let n = 0; n < xac_.ObjNum; n ++) {
		xac_.SndPtr[n] = new THREE.PositionalAudio(listener);
		xac_.SndMsh[n].add(xac_.SndPtr[n]);
	}
	// XS Guns
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		xsh_.SndPtr[n] = new THREE.PositionalAudio(listener);
		xsh_.SndMsh[n].add(xsh_.SndPtr[n]);
	}
	xsh_.AAAPtr[0][0].add(xsh_.SndMsh[0]); // Link SndMsh to Specific Bullets
	xsh_.AAAPtr[1][2].add(xsh_.SndMsh[1]);
	// AA Guns
	for (let n = 0; n < gun_.ObjNum; n ++) {
		gun_.SndPtr[n] = new THREE.PositionalAudio(listener);
		gun_.SndMsh[n].add(gun_.SndPtr[n]);
	}
	gun_.AAAPtr[0][0].add(gun_.SndMsh[0]); // Link SndMsh to Specific Bullets
	gun_.AAAPtr[1][2].add(gun_.SndMsh[1]);
	//- Set Flag
	LodSnd = 1;
}

//- Change Sounds --------------------------------------------------------------
function moveSounds() {
	// My Engine
	EngSnd.setVolume(EngVol + air_.PwrPct * 0.05); // Range = .1 to .2
	EngSnd.setPlaybackRate(1 + air_.PwrPct * 0.5); // Range = 1 to 1.5
	// My Props
	PrpSnd.setVolume(PrpVol + air_.PwrPct * 0.15); // Range = .1 to .4
	PrpSnd.setPlaybackRate(1 + air_.PwrPct * 0.5); // Range = 1 to 1.5
	// My Guns (Left and Rite)
	for (let n = 0; n < myg_.ObjNum; n ++) {
		myg_.SndPtr[n].setVolume(myg_.SndVol);
	}
	// XP Engines
	for (let n = 0; n < xac_.ObjNum; n ++) {
		xac_.EngPtr[n].setVolume(xac_.EngVol[n]);
	}
	// XP Guns
	for (let n = 0; n < xac_.ObjNum; n ++) {
		xac_.SndPtr[n].setVolume(xac_.SndVol[n]);
	}
	// XS Guns
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		xsh_.SndPtr[n].setVolume(xsh_.SndVol);
	}
	// AA Guns
	for (let n = 0; n < gun_.ObjNum; n ++) {
		gun_.SndPtr[n].setVolume(gun_.SndVol);
	}
}

//- Play Sounds ----------------------------------------------------------------
function playSounds() {
	// This leaves SndFlg = 1 and MYGFlg unchanged.
	// My Engine
	if (!EngSnd.isPlaying) EngSnd.play();
	// My Prop
	if (!PrpSnd.isPlaying) PrpSnd.play();
	// My Guns (Left and Rite)
	for (let n = 0; n < myg_.ObjNum; n ++) {
		if (MYGFlg && !myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].play();
	}
	// XP Engines
	for (let n = 0; n < xac_.ObjNum; n ++) {
		if (!xac_.EngPtr[n].isPlaying) xac_.EngPtr[n].play();
	}
	// XP Guns
	for (let n = 0; n < xac_.ObjNum; n ++) {
//		if (!xac_.SndPtr[n].isPlaying) xac_.SndPtr[n].play(); // ### FIX THIS
	}
	// XS Guns - activated in PlayXS	
	// AA Guns - activated in PlayAA
}

//- Stop Sounds ----------------------------------------------------------------
function stopSounds() {
	// This leaves SndFlg = 0 and MYGFlg unchanged.
	// My Engine
	if (EngSnd.isPlaying) EngSnd.stop();
	// My Prop
	if (PrpSnd.isPlaying) PrpSnd.stop();
	// My Guns (Left and Rite)
	for (let n = 0; n < myg_.ObjNum; n ++) {
		if (myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].stop();
	}
	// XP Engines
	for (let n = 0; n < xac_.ObjNum; n ++) {
		if (xac_.EngPtr[n].isPlaying) xac_.EngPtr[n].stop();
	}
	// XP Guns
	for (let n = 0; n < xac_.ObjNum; n ++) {
		if (xac_.SndPtr[n].isPlaying) xac_.SndPtr[n].stop();
	}
	// XS Guns
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		if (xsh_.SndPtr[n].isPlaying) xsh_.SndPtr[n].stop();
	}	
	// AA Guns
	for (let n = 0; n < gun_.ObjNum; n ++) {
		if (gun_.SndPtr[n].isPlaying) gun_.SndPtr[n].stop();
	}
}

//= 7. CAMERA ==================//==============================================

//- Init Camera View -----------//----------------------------------------------
function initCamera(camera,cam_) {
	camera.position.z = -cam_.CamLLD.z;
	camera.rotation.y = cam_.CamAdj*DegRad;
	cam_.MshRot.add(camera);	// Attach to rotator
	//
	if (!cam_.CamSel) {			// 0 = External View
		sunLight.shadow.mapSize.set(2048,2048);
		sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
		sunLight.shadow.camera.updateProjectionMatrix();
		mxr_.Adr.visible = true;
		vxr_.Adr.visible = false;
		// Flaps
		if (mxr_.FlL) mxr_.FlL.setTime(anm_.flppos/anm_.anmfps);
		if (mxr_.FlR) mxr_.FlR.setTime(anm_.flppos/anm_.anmfps);
		// Gear
		if (mxr_.WHL) mxr_.WHL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WHR) mxr_.WHR.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WBL) mxr_.WBL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WBR) mxr_.WBR.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WTL) mxr_.WTL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WTR) mxr_.WTR.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WSL) mxr_.WSL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WSR) mxr_.WSR.setTime(anm_.lngpos/anm_.anmfps);
		// Canopy
		if (mxr_.Cnp) mxr_.Cnp.setTime(anm_.canpos/anm_.anmfps);
		// Tailhook
		if (mxr_.THk) mxr_.THk.setTime(anm_.thkpos/anm_.anmfps);
	}	
	if (cam_.CamSel) {			// 1 = Internal View
		sunLight.shadow.mapSize.set(8192,8192);
		sunLight.shadow.camera.far = SunDst+2*ShdBox;
		sunLight.shadow.camera.updateProjectionMatrix();
		mxr_.Adr.visible = false;
		vxr_.Adr.visible = true;
		// Canopy
		if (mxr_.Cnp) mxr_.Cnp.setTime(anm_.canpos/anm_.anmfps);
	}
	// Common Changes
	cam_.CamLLD.copy(CamLLD[cam_.CamSel]);	// Restore Saved Values
	cam_.CamMMD.copy(CamMMD[cam_.CamSel]);	// In/Out - min, max, spd
	cam_.CamAdj = CamAdj[cam_.CamSel];		// Load Adjustment
	camera.rotation.y = cam_.CamAdj*DegRad;	// 180 = Looking in
	cam_.CamMMR.copy(CamMMR[cam_.CamSel]);	// Rotation min, max, spd
	cam_.CamPar = CamPar[cam_.CamSel]		// Load New Parent
	cam_.CamPar.add(cam_.MshRot);			// Attach Rotators
	cam_.CamFlg = CamFlg[cam_.CamSel];		// 1 = cockpit
	cam_.CamLnk = CamLnk[cam_.CamSel];		// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);
}

//- Move Camera View -------------//----------------------------------------------
function moveCamera(camera,cam_) {
	// Move Camera In/Out
	camera.position.z = -cam_.CamLLD.z;
	// PointerLockControls
	if (cam_.OrbFlg) {
		cam_.CamLLD.x = cam_.CamLLD.x - InpMos.y * cam_.CamMMR.z; // Camera Position (Lat)
		cam_.CamLLD.x = MaxVal(cam_.CamLLD.x,cam_.CamMMR.x);
		cam_.CamLLD.y = Mod360(cam_.CamLLD.y + InpMos.x * cam_.CamMMR.z); // Camera Position (Lon)
		// Internal View
		if (cam_.CamFlg) {		// Range: 250 to 360/0 to 110
			if (cam_.CamLLD.y > 180 && cam_.CamLLD.y < (360-cam_.CamMMR.y)) cam_.CamLLD.y = (360-cam_.CamMMR.y);
			if (cam_.CamLLD.y < 180 && cam_.CamLLD.y > cam_.CamMMR.y) cam_.CamLLD.y = cam_.CamMMR.y;
		}
		// External View
		else {
			if (air_.GrdFlg && cam_.CamLLD.x > -12.5) cam_.CamLLD.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// Adjust Camera Rotators
	// In internal view, the camera is facing out - view matches rotation
	if (cam_.CamFlg) {
		cam_.MshRot.rotation.x = Mod360(cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(-cam_.CamLLD.y)*DegRad;
	}
	// In external view, the camera is facing in and the armature is pointing out:
	if (!cam_.CamFlg) {
		if (!cam_.OrbFlg && air_.GrdFlg) { // Air to Ground
			if (!CmGrdF) {		// if just landed
				CmLagX = CmAdjX; // All landings are smooth
//				if (CmLagX > 0.5) CmLagX = 0.5; // Make extreme landings more jarring
				CmGrdF = 1;
			}
			CmAdjX = CmLagX;	// From Landing Value to 0
		}	
		if (!cam_.OrbFlg && !air_.GrdFlg) { // Ground to Air
			if (CmGrdF) {		// if just took off
				CmLagX = CmMulX*air_.RotDif.x;
				CmGrdF = 0;
			}
			CmAdjX = (CmMulX*air_.RotDif.x)-CmLagX; // From 0 to Take-Off Value
		}
		if (CmLagX) {			// Reduce Lag
			CmLagX = 0.99*CmLagX; // Reduction in Adj/AdjOff
			if (Math.abs(CmLagX) < 0.1) CmLagX = 0;
		}
		camera.rotation.x = CmAdjX*DegRad; // + = up/airplane down
		cam_.MshRot.rotation.x = Mod360(-cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(180-cam_.CamLLD.y)*DegRad;
	}
}

//= 8. OUTPUTS ====================//==============================================

//-	Print HUD Values -----------------------------------------------------------
function prntHUDval() {
	Air_Pwr = air_.PwrPct;		// Throttle
	Air_PwrNode.nodeValue = Air_Pwr.toFixed(2);
	Air_Spd = air_.SpdKPH*Km2Mil; // Speed
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Alt = air_.MapPos.y*Mtr2Ft; // Altitude
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);
	Air_Hdg = air_.AirRot.y;	// Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
	Air_CfL = air_.CfLift;		// Cf Lift
	Air_CfLNode.nodeValue = Air_CfL.toFixed(4);
}

//-	Pause Text -----------------------------------------------------------------
function PawsText(){
	if (PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//-	Autopilot Text -------------------------------------------------------------
function AutoText(){
	if (air_.AutoOn) Air_AtPNode.nodeValue = "Autopilot On";
	else {Air_AtPNode.nodeValue = "AutoP: Press A";}
}

//- Info Text ------------------------------------------------------------------

let InfoData = [
		[
			"Info : Press I","","","","","","","","",""
		],
		[
			"",
			"CONTROLS",
			"Mouse changes Pitch/Bank and Yaw (bottons)",
			"AutoPilot: Arrow Key change Pitch and Bank",
			"Mouse Wheel or -/= Keys change Throttle",
			"G Key toggles landing gear",
			"F Key toggles flaps",
			"S Key toggles sound",
			"Spacebar fires guns"
		],
		[
			"",
			"VIEW KEYS",
			"V Key toggles views",
			"Shift Key and Mouse orbits around airplane",
			"END Key looks down",
			"DELETE or PAGE DOWN Keys look left/right",
			"HOME Key and above Keys look up",
			"END Key and DELETE or PAGE DOWN Keys look back",
			"All 3 Keys look back"
		]
	];


function InfoText() {
	if (!InfoOn) onInfo(0);
	else if (InfoOn == 1) onInfo(1);
	else if (InfoOn == 2) onInfo(2);
}

//	Info Off
function onInfo(n){
	On_Inf0Node.nodeValue = InfoData[n][0];
	On_Inf1Node.nodeValue = InfoData[n][1];
	On_Inf2Node.nodeValue = InfoData[n][2];
	On_Inf3Node.nodeValue = InfoData[n][3];
	On_Inf4Node.nodeValue = InfoData[n][4];
	On_Inf5Node.nodeValue = InfoData[n][5];
	On_Inf6Node.nodeValue = InfoData[n][6];
	On_Inf7Node.nodeValue = InfoData[n][7];
	On_Inf8Node.nodeValue = InfoData[n][8];
	On_Inf9Node.nodeValue = InfoData[n][9];
}

//= 9. INPUTS =====================//==============================================
// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//- MOUSE ----------------------------------------------------------------------

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		air_.RotDif.y = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		air_.RotDif.y = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		air_.RotDif.y = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		air_.RotDif.y = 0;
	}
}

//- Mousewheel -----------------------------------------------------------------
function onDocumentMouseWheel(event) {
	event.preventDefault();
	PwrDif = - event.deltaY * PwrMul; // Increment = 1%
}

//- KEYBOARD -------------------------------------------------------------------

//- Keyboard (Down) ------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_PwLU) PwrDif = 0.1;		// Power Up - keyboard left
	if (event.keyCode == K_PwLD) PwrDif = -0.1;		// Power Down - keyboard left
	if (event.keyCode == K_PwRU) PwrDif = 0.1;		// Power Up - keyboard right
	if (event.keyCode == K_PwRD) PwrDif = -0.1;		// Power Down - keyboard right
	if (event.keyCode == K_BnkL) air_.InpKey.z = -KeyVal.z;	// Bank Left - autopilot only
	if (event.keyCode == K_BnkR) air_.InpKey.z = KeyVal.z;	// Bank Right - autopilot only
	if (event.keyCode == K_PitU) air_.InpKey.x = KeyVal.x;	// Pitch Up - autopilot only
	if (event.keyCode == K_PitD) air_.InpKey.x = -KeyVal.x;	// Pitch Down - autopilot only
	if (event.keyCode == K_YwLL) air_.RotDif.y = -KeyVal.z; // YawL - keyboard left
	if (event.keyCode == K_YwLR) air_.RotDif.y = KeyVal.z;  // YawR - keyboard left
	if (event.keyCode == K_YwRL) air_.RotDif.y = -KeyVal.z; // YawL - keyboard right
	if (event.keyCode == K_YwRR) air_.RotDif.y = KeyVal.z;  // YawR - keyboard right
	if (event.keyCode == K_Brak) InpBrk = 0.01;		// Brakes
	// Additional
	if (event.keyCode == K_Gear) anm_.lngflg = 1; 	// Gear
	if (event.keyCode == K_Flap) anm_.flpflg = 1; 	// Flaps
	if (event.keyCode == K_Canp) anm_.canflg = 1; 	// Canopy
	if (event.keyCode == K_Hook) anm_.thkflg = 1; 	// Tailhook
	// Views
	if (event.keyCode == K_Look) cam_.OrbFlg = 1;	// Orbit View
	if (event.keyCode == K_VU45) D45flg = 1;		// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 1;		// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 1;		// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 1;		// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 1;		// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 1;		// View - 90 deg right
	// Guns
	if (event.keyCode == K_Guns) { // Guns
		if (!PawsOn) {
			for (let n = 0; n < myg_.ObjNum; n ++) {
				if (SndFlg && !myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].play();
			}
		};
		MYGFlg = 1;
	}
	// Reset
	if (event.keyCode == K_RSet) posnRSet();		// Do Reset	
	// Toggle
	if (event.keyCode == K_Paws) toglPaws();		// Toggle Pause
	if (event.keyCode == K_Auto) toglAuto();		// Toggle AutoPilot
	if (event.keyCode == K_Info) toglInfo();		// Toggle Information
	if (event.keyCode == K_View) toglView();		// Switch View
	if (event.keyCode == K_Soun) toglSoun();		// Toggle Sound
}

//-	Keyboard (Up) --------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_PwLU) PwrDif = 0;		// Power Up - keyboard left
	if (event.keyCode == K_PwLD) PwrDif = 0;		// Power Down - keyboard left
	if (event.keyCode == K_PwRU) PwrDif = 0;		// Power Up - keyboard right
	if (event.keyCode == K_PwRD) PwrDif = 0;		// Power Down - keyboard right
	if (event.keyCode == K_BnkL) air_.InpKey.z = 0;	// Bank Left - autopilot only
	if (event.keyCode == K_BnkR) air_.InpKey.z = 0;	// Bank Right - autopilot only
	if (event.keyCode == K_PitU) air_.InpKey.x = 0;	// Pitch Up - autopilot only
	if (event.keyCode == K_PitD) air_.InpKey.x = 0;	// Pitch Down - autopilot only
	if (event.keyCode == K_YwLL) air_.RotDif.y = 0;	// YawL - keyboard left
	if (event.keyCode == K_YwLR) air_.RotDif.y = 0;	// YawR - keyboard left
	if (event.keyCode == K_YwRL) air_.RotDif.y = 0;	// YawL - keyboard right
	if (event.keyCode == K_YwRR) air_.RotDif.y = 0;	// YawR - keyboard right
	if (event.keyCode == K_Brak) InpBrk = 0;		// Brakes
	// Additional
	if (event.keyCode == K_Gear) anm_.lngflg = 0;	// Gear
	if (event.keyCode == K_Flap) anm_.flpflg = 0;	// Flaps
	if (event.keyCode == K_Canp) anm_.canflg = 0;	// Canopy
	if (event.keyCode == K_Hook) anm_.thkflg = 0;	// Taihook
	// Views
	if (event.keyCode == K_Look) cam_.OrbFlg = 0;	// Orbit View
	if (event.keyCode == K_VU45) D45flg = 0;		// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 0;		// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 0;		// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 0;		// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 0;		// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 0;		// View - 90 deg right
	// Guns
	if (event.keyCode == K_Guns) {					// Guns
		for (let n = 0; n < myg_.ObjNum; n ++) {
			myg_.SndPtr[n].stop();
		}
		if (!PawsOn) {
			for (let n = 0; n < myg_.ObjNum; n ++) {
				if (myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].stop();
			}
		};
		MYGFlg = 0;
	}
}

//- Reset Position -------------//----------------------------------------------
function posnRSet() {
	// CVE
	air_.MovFlg = 1; // Flag
	air_.PwrPct = 0;
	air_.SpdKPH = 0;
	air_.SpdMPS = 0;
	air_.SpdMPF = 0;
	xsh_.ShpLok[0].add(air_.AirObj);
}

//- Subroutines ----------------//----------------------------------------------

//. Toggle Pause ...............................................................
function toglPaws() {
	PawsOn = 1 - PawsOn;
	if (PawsOn && SndFlg) {		//On to Off
		stopSounds();
	}
	if (!PawsOn && SndFlg) {	// Off to On
		playSounds();
	}
	PawsText();
}

//. Toggle AutoPilot ...........................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................................................................
function toglInfo() {
	InfoOn++
	if (InfoOn == 3) InfoOn = 0;
	InfoText();
}

//. Toggle Camera View (3-Way) -------------------------------------------------
function toglView() {
	// Old CamSel
	cam_.CamPar.remove(cam_.MshRot);		// Unlink Old Parent
	CamLLD[cam_.CamSel].copy(cam_.CamLLD);	// Save lld
	// New CamSel
	cam_.CamSel++
	if (cam_.CamSel == cam_.CamNum) cam_.CamSel = 0;
	initCamera(camera,cam_)
}

//. Toggle Sound ...............................................................
function toglSoun() {
	if (!PawsOn) {
		SndFlg = 1 - SndFlg;
		if (SndFlg) {			// Off to On
			playSounds();
		}
		else {					// On to Off
			stopSounds();
		}
	}
}

//= WINDOW RESIZE ==============//==============================================
function onWindowResize() {
	CamAsp = window.innerWidth/window.innerHeight;
	camera.aspect = CamAsp;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>