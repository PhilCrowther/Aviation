<!DOCTYPE html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 10 Apr 2025

A basic demo of a flight simulation of an animated airplane model over animated ocean using WebGPU and NodeMaterials.
This demo has now been expanded to include a battle scenario which will eventually involve air combat
-->

<head>
<title>fsim FM2 ocean gpu r175</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Throttle: <span id="Air_Pwr"></span></div>
		<div>AirSpeed: <span id="Air_Spd"></span> mph</div>
		<div>Altitude: <span id="Air_Alt"></span> ft</div>
		<div>Heading&nbsp: <span id="Air_Hdg"></span> deg</div>
		<div>CfLift&nbsp&nbsp: <span id="Air_CfL"></span></div>
		<div>GFmult&nbsp&nbsp: <span id="Air_GFm"></span></div>

	</div>
	<div class="overlay2">
		<div><span id="On_Paws"></span></div>
		<div><span id="Air_AtP"></span></div>
		<div><span id="On_Inf0"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Inf1"></span></div>
		<div><span id="On_Inf2"></span></div>
		<div><span id="On_Inf3"></span></div>
		<div><span id="On_Inf4"></span></div>
		<div><span id="On_Inf5"></span></div>
		<div><span id="On_Inf6"></span></div>
		<div><span id="On_Inf7"></span></div>
		<div><span id="On_Inf8"></span></div>
		<div><span id="On_Inf9"></span></div>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script src="https://PhilCrowther.github.io/Aviation/data/fsim_FM2_ocean_gpu.js"></script>
<script src="https://PhilCrowther.github.io/Aviation/models/fm2/data/data.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.webgpu.js",
			"three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.webgpu.js",
			"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.tsl.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/",
			"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.8/dist/main.js"
		}
	}
</script>

<script type="module">

// Basic Modules
import * as THREE from "three";
import {color,texture} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement} from "three/addons/objects/LensflareMesh.js";
import Stats from "stats-gl";
// Special Modules
import {PointerLockControls} from "https://PhilCrowther.github.io/Aviation/jsm/Controls1.js";
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdWtr4c.js"; // add grd_.EMI
import {Ocean} from "https://PhilCrowther.github.io/Aviation/jsm/Ocean4t2.js"; // r173 (uses TimestampQuery)
import {Flight,Mod360,PoM360,MaxVal,makMsh} from "https://PhilCrowther.github.io/Aviation/jsm/Flight4a.js";
import {loadAirExt,loadAirInt,moveAirExt,moveAirInt} from "https://PhilCrowther.github.io/Aviation/jsm/AnimFM2a.js";
import {initBullet,moveBullet,	// My Airplane Bullets
		initXACBul,moveXACBul,	// Other Airplane Bullets
		initAAGuns,moveAAGuns	// AA Guns (Fixed and Ship)
} from "https://PhilCrowther.github.io/Aviation/jsm/GunASG.js";
import {initGrdSmk,initGrdFyr,	// Ground Based
		initAirSmk,initAirFyr,	// Air Based
		initShpWak				// Ship Based
} from "https://PhilCrowther.github.io/Aviation/jsm/Smoke1a.js";
import {loadAnmFlg,moveAnmFlg,	// Animated Flag
		loadMyPeep,moveMyPeep,	// Animated People
} from "https://PhilCrowther.github.io/Aviation/jsm/ObjAnm1a.js";
2
/*= GENERAL ====================//==============================================

This flight simulation demo uses the most advanced version of three.js

=FEATURES
-Flight Smulation
	* Realistic Flight Simulation and AutoPilot (Flight Module)
	* Taildragger takeoff and landing
	* Static and Moving Landing Surfaces
-Scenery:
	* Animated and Textured iFFT Ocean (Ocean and GrdMap Modules)
	* Islands, including Volcano with Animated Smoke
	* SunFlare
-My Airplane:
	* Detailed Airplane Model - Outside and Cockpit (created in Blender)
	* Animated Controls and Gauges - Outside and Cockpit (AnimFM2 Module)
	* Animated Pilot
	* 3D Sounds
-	Traffic:
	* Animated Traffic - Airplane and Carrier
	* Landable Moving Carrier with animated Flag and Wake
-Controls:
	* Multi-Positional Camera

TO DO:
-	Program:
	* Move Variables to Data File (not variables with three.js functions) - WIP
	* Red Out not very red.
	* Don't hear EA guns or engines (used to hear engines)9
	* Reset landed airplane to starting position (R) - WIP
	* Convert waving flag to GPU shader
-	Flight Module:
	* Add supercharger/turbocharger effect
OK
- Program:
	* My Guns seem to be aimed too high - but if fly level, guns shoot at horizon
*/

/*******************************************************************************
*
*	INDEX TO SECTIONS
*
********************************************************************************

	VARIABLES						Data			Main
	1. MAIN VARIABLES
	   Inputs										X
	   Constants					X				X
	   Variables					X				X
	   Sun Values					X				X
	   Standard Setup								X
	   Fad2Black Plane				X				X
	2. SKYBOX VARIABLES				X
	3. OCEAN GRID VARIABLES
		GRDWTR MODULE				grd_			adj
		OCEAN MODULE				wav_			adj
	4. OBJECT VARIABLES
		SHARED TEXTURES				txt_
		STATIC OBJECTS
			Islands					isl_			adj
			Fixed Objects			fxd_			adj
		MOVING VEHICLES
			Moving Airplanes		xac_			adj
			Moving Ships			xsh_			adj
		ANIMATED FLAG				flg_			adj
		AIRPLANE END SEQUENCE		xat_
		AIRPLANE EXPLOSION			xae_			adj
	    SMOKE MODULE
	    	Volcano Smoke			vlk_			adj
			Vertical Smoke			grs_			adj
	    	Ground Fire				grf_			adj
	    	Airplane Smoke Trail	xas_			adj
	    	Airplane Fire Trail		xaf_			adj
	    	Ship Wake				wak_			adj
		MYPEEPS						myp_			adj
		MINIMUM ALTITUDE			alt_			adj
	5. MY AIRPLANE VARIABLES		air_			adj
		FLIGHT MODULE
		ANIMFM2 MODULE				anm_,mxr_,vxr_
	x. GUNASG MODULE
			My Guns					myg_
			Moving Airplanes		xag_
			Moving Ships			xsg_
			Fixed Guns				aaf_
	6. SOUND VARIABLES
		My Sounds					mys_			adj
		Radio Variables				rad_
	7. CAMERA VARIABLES								cam_
	8. OUTPUT VARIABLES				X
	9. INPUT VARIABLES
	   Pointer Lock Control			X

	PROGRAM
	1. MAIN							Main Program
	   LoadAll						Load All Images
	   InitAll						Intialize
	   RendAll						Render
	   FadMsh						Fade to Black
	2. SKYBOX						SkyCube
	3. GEOMAT						Grids and Textures
	4. OBJECTS						Static and Moving Objects and Animations
	    Isl							Islands
	    Fxd							Fixed Objects
	    XAC							Moving Airplanes (0 = Friendly; 1 = Enemy)
	    XAS							Moving Ships (0 = Carrier; 1 = Destroyer)
	5. MY AIRPLANE					My Airplane and Animations
	6. SOUNDS						All Sounds
	   RADIO SOUNDS					Radio Calls
	7. CAMERA						Camera Views
	8. OUTPUTS						Screen Text and Numbers
	9. INPUTS						Keyboard and Mouse Inputs
*/

/*******************************************************************************
*
*	VARIABLES
*
*******************************************************************************/

//= 1. MAIN VARIABLES ==========//==============================================
//- INPUTS ---------------------//----------------------------------------------
let BegLoc = 1;					// 0 = Island; 1 = CVE; 2 = Air
//- FLIGHT CONTROLS ------------//----------------------------------------------
let PYBmul = new THREE.Vector3(0.004,1.0,0.001); // Control Multiplier for FM2
let	MosMul = new THREE.Vector3(1.0,1.0,1.0); // Adjustment to PYBmul (default = 1)
//- Input Lag (x = diverted, y = released, z = stored)
//- Mouse
let LagPwr = new THREE.Vector3(1-1/30,1/15,0);	// Power
let LagCfL = new THREE.Vector3(1-1/30,1/15,0);	// CfL
let LagBnk = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- Keys
let LagAtP = new THREE.Vector2(0.967,0.099);	// CfL - Autopilot
//- Autopilot Key Vaulues (XZ = Autopilot Pitch/Bank; Y = Yaw Mouse Button or Key)
let	KeyVal = new THREE.Vector3(0.5,0.05,0.25); // (Yaw = turn rate in 15 deg bank)
//- CONSTANTS ------------------//----------------------------------------------
//	Set Zero Values
let V3Zero = new THREE.Vector3(0,0,0);
let E3Zero = new THREE.Euler(0,0,0);
//- SUN VALUES -----------------//----------------------------------------------
//- Computations
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);

//= STANDARD SETUP =============//==============================================
// 	Scene
const scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
// 	Light
const ambLight = new THREE.AmbientLight(SunCol,0.2);
	scene.add(ambLight);
//- SunLight
const sunLight = new THREE.DirectionalLight(SunCol,SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = SunDst*0.75;
	sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -ShdBLR;
	sunLight.shadow.camera.right = ShdBLR+1;
	sunLight.shadow.camera.top = ShdBTB;
	sunLight.shadow.camera.bottom = -ShdBTB;
//	sunLight.shadow.bias = -0.0002; // WebGPU
	sunLight.shadow.bias = -0.0005; // WebGPU
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
const camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//	Renderer
const renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);	
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
//	ToneMapping does not seem helpful
	document.body.appendChild(renderer.domElement);
let maxAnisotropy = renderer.getMaxAnisotropy();
// 	Clock
const clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
// 	Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
// 	Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
const txtrLoader = new THREE.TextureLoader(loadingManager);
const imagLoader = new THREE.ImageLoader(loadingManager);
const cubeLoader = new THREE.CubeTextureLoader(loadingManager);
const gltfLoader = new GLTFLoader(loadingManager);
const audoLoader = new THREE.AudioLoader();
// Create Audio Listener
let	listener = new THREE.AudioListener();
	camera.add(listener);
// 	Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= 2. SKYBOX ==================//==============================================

//= FADE2BLACK PLANE ===========//==============================================
let FadMsh = initFadMsh();		// Initialize

//= 3. OCEAN GRID VARIABLES ====//==============================================
//- GrdWtr Textures ------------//----------------------------------------------
//- Canvas (for splitting up textures)
let ImgSiz = 512;				// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext("2d",{willReadFrequently: true});
	context.translate(0, ImgSiz); // Flips vertical for three.js
	context.scale(1,-1);
//	Adjustments
	grd_.MSP = new THREE.Vector3();
	grd_.Col = new THREE.Color(WtrCol);
	grd_.NMS = new THREE.Vector2();
//	Fine-Tune Graphics
	grd_.Mtl = [0.5,0.5,0.5];	// Metalness (1 for max reflection)
	grd_.Ruf = [0.5,0.5,0.5];	// Roughness (0 for max reflection)
	grd_.EMI = [0.5,0.48,0.48];	// EnvMap Intensity
//	Tests
//	grd_.Col = new THREE.Color(0x000040);
//	grd_.DfS = "https://PhilCrowther.github.io/Aviation/textures/ocean/uv_grid.jpg";
//	Since textures must be loaded in the Main Program and since design of materials 
//	and goemetry can vary, some of the Grid initialization is handled in the Main Program
//  by the LoadGeoMat and InitGeoMat routines
//- Ocean Module ---------------//----------------------------------------------
//	Adjustments
	wav_.NMS = new THREE.Vector2(1,1);

//= 4. OBJECT VARIABLES ========//==============================================
//= STATIC OBJECTS =============//==============================================
//- Islands --------------------//----------------------------------------------
//	Adjustments
	isl_.ObjRot = [new THREE.Euler(),new THREE.Euler()]; // Rotation
	isl_.MapPos = [new THREE.Vector3(610,30,5275),new THREE.Vector3(-1610,10,2440)];
	isl_.ObjGrp = [new makMsh(),new makMsh()]; // Group
//- Static Objects -------------//----------------------------------------------
//	Adjustments
	fxd_.ObjRot = [new THREE.Euler()]; // Rotation
	fxd_.MapPos = [new THREE.Vector3(-562,-22.5,-363)]; // Relative Position
	fxd_.ObjRef = [isl_.ObjGrp[0]];
//- MOVING VEHICLES ------------//----------------------------------------------
//. Moving Airplanes ...........//..............................................
//	Adjustments
	xac_.ObjRot = [new THREE.Euler(0,0,30),new THREE.Euler(0,0,30)];  // Rotation
	xac_.MapPos = [new THREE.Vector3(180,1524,5300),new THREE.Vector3(180,1524,5300)]; // meters
	xac_.MapSpd = [new THREE.Vector3(),new THREE.Vector3()]; // not used
	xac_.EngMsh = [new makMsh(),new makMsh()];
	xac_.SndMsh = [new makMsh(),new makMsh()];
//. Moving Ships ...............//..............................................
//	Adjustments
	xsh_.ObjRot = [new THREE.Euler(0,0,0),new THREE.Euler(0,0,0)];  // Rotation
	xsh_.MapPos = [new THREE.Vector3(-4100,0.1,150),new THREE.Vector3(-4200,0.2,350)]; // meters
	xsh_.ObjGrp = [new makMsh(),new makMsh()];
	xsh_.MapSpd = [new THREE.Vector3(),new THREE.Vector3()];
	xsh_.ShpLok = [new makMsh(),0];

//= ANIMATED FLAGS =============//==============================================
//	Adjustments
	flg_.ObjRot = [new THREE.Euler(0,97.5*DegRad,0)]; // Adjust to make the flag visible at start
	flg_.MapPos = [new THREE.Vector3(44.2,92.47,-58.93).multiplyScalar(Ft2Mtr)]; // Relative Map Position
	flg_.ObjRef = [xsh_.ObjGrp[0]]; // Parent Object

//= AIRPLANE EXPLOSION =========//==============================================
	xae_.ExpMsh = makeSphere("yellow");

//= SMOKE MODULE ===============//==============================================
//- Vertical Smoke -------------//----------------------------------------------
//	Adjustments
	grs_.ObjRot = [new THREE.Euler()];				// Rotation (not used)
	grs_.MapPos = [new THREE.Vector3(50,75,25)];	// Map Position
	grs_.ObjRef = [isl_.ObjGrp[0]];					// Parent Object
//- Ground Fire ----------------//----------------------------------------------
	grf_.ObjRot = [new THREE.Euler()];				// Rotation
	grf_.MapPos = [new THREE.Vector3(-562,-22.5,-363)]; // Map Position
	grf_.ObjRef = [isl_.ObjGrp[0]],					// Parent Object
//- Ship Wake ------------------//------------------------------------------
	wak_.ObjRot = [new THREE.Euler(),new THREE.Euler()]; // Rotation (not used)
	wak_.MapPos = [new THREE.Vector3(50,75,25),		// Map Position
				   new THREE.Vector3(50,75,25)],
	wak_.ObjRef = [xsh_.ObjGrp[0],xsh_.ObjGrp[1]];	// Parent Object			 

//= MY PEEPS ===================//==============================================
//- Animated Objects: Linked ---//----------------------------------------------
//	Adjustments
	myp_.ObjRot = [new THREE.Euler(0,-45,0), // Rotation (degrees)
				   new THREE.Euler(0,-90,0)];
	myp_.MapPos = [new THREE.Vector3(6,12.9,40), // Relative Position (if parent)
				   new THREE.Vector3(12.22,11.39,35)];
	myp_.ObjRef = [xsh_.ObjGrp[0],xsh_.ObjGrp[0]]; // Parent, if any

//= MINIMUM ALTITUDE ===========//==============================================
//- Adjustments
	alt_.Ref = [isl_.ObjGrp[0],xsh_.ObjGrp[0]]; // can't load until object exists
//- Carrier Deck Lock Down
	xsh_.ShpLok[0].position.y = 1.4+(alt_.Alt[1]-xsh_.MapPos[0].y);
	xsh_.ObjGrp[0].add(xsh_.ShpLok[0]);

//= 5. MY AIRPLANE VARIABLES ===//==============================================
//- Flight Module --------------//----------------------------------------------
//	Adjustments
	air_.AirDat = data_;
	air_.AirRot = new THREE.Euler();
	air_.AirObj = new makMsh;
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY = new makMsh;
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY); // PBY includes air_.ACPAdj
	scene.add(air_.AirObj);	// Airplane
	air_.RotDif = new THREE.Vector3();
	air_.MapSpd = new THREE.Vector3();
	air_.MapPos = new THREE.Vector3();
	air_.MapSPS = new THREE.Vector3();
	air_.PYBmul = new THREE.Vector3().copy(PYBmul);
	air_.InpKey = new THREE.Vector3();
	air_.OldRot = new THREE.Euler();
	air_.BegTmp = BegTmp;

//- FM2 Animations -------------//----------------------------------------------
	mxr_.Adr = new makMsh();
	vxr_.Adr = new makMsh();
	if (BegLoc == 0) {
//		anm_.lngpos = 0;		// Landing Gear Down (later)
		anm_.flppos = 180;		// Flaps Up
	}
	if (BegLoc == 1) {
//		anm_.lngpos = 0;		// Landing Gear Down (later)
		anm_.flppos = 0;		// Flaps Down
		anm_.canpos = 0;		// Canopy Open
	}
	if (BegLoc == 2) {
//		anm_.lngpos = 180;		// Landing Gear Up (later)
		anm_.flppos = 180;		// Flaps Up
	}

//= GUNASG MODULE ==============//==============================================
//- My Guns --------------------//----------------------------------------------
//	Specific Adjustments
	myg_.BulClr = new THREE.Vector2(0xff80ff,0x804080); // Red
	myg_.SndSrc = AirSrc + "sounds/" + "fm2_gun.mp3", // File (my guns)
	myg_.SndMsh = [new makMsh(),new makMsh()];
//- Moving Airplanes -----------//----------------------------------------------
//	General Format Adjustments
for (let n = 0; n < aaf_.ObjNum; n ++) {
	xag_.GunRot[n] = new THREE.Euler();  // Gun Rotation (degrees)
	xag_.GunPos[n] = new THREE.Vector3();
	xag_.SndMsh[n] = new makMsh();
}
//	Specific Adjustments
	xag_.XACRot = [xsh_.ObjRot[1],xsh_.ObjRot[1]];
	xag_.XACPos = [xsh_.MapPos[1],xsh_.MapPos[1]];
	xag_.BulClr = new THREE.Vector2(0xff80ff,0x804080); // Red
	xag_.SndSrc = [XPPath + "sounds/" + "fm2_gun.mp3", // File (my guns)
				   XPPath + "sounds/" + "fm2_gun.mp3"];
//- Moving Ships ---------------//----------------------------------------------
//	General Format Adjustments
for (let n = 0; n < aaf_.ObjNum; n ++) {
	xsg_.GunPtr[n] = new makMsh();
	xsg_.SmkMpP[n] = new THREE.Vector3();
	xsg_.SndMsh[n] = new makMsh();
}
//	Specific Adjustments
	xsg_.XSHRot = [xsh_.ObjRot[1],xsh_.ObjRot[1]], // Fletcher
	xsg_.XSHPos = [xsh_.MapPos[1],xsh_.MapPos[1]],
	xsg_.GunRot = [new THREE.Euler(0,0,0),new THREE.Euler(60,315,0)]; // Gun Rotation (degrees)
	xsg_.GunPos = [new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)]; // Map Position
	xsg_.AAACol = new THREE.Vector2(0xff80ff,0x804080); // Red	
//- Fixed Guns -----------------//----------------------------------------------
//	General Format Adjustments
for (let n = 0; n < aaf_.ObjNum; n ++) {
	aaf_.XSHRot[n] = new THREE.Euler();
	aaf_.XSHPos[n] = new THREE.Vector3();
	aaf_.GunPtr[n] = new makMsh();
	aaf_.SmkMpP[n] = new THREE.Vector3();
	aaf_.SndMsh[n] = new makMsh();
}
//	Specific Adjustments
	aaf_.GunRot = [new THREE.Euler(45,90,0),new THREE.Euler(30,0,0)]; // Gun Rotation (degrees)
	aaf_.GunPos = [new THREE.Vector3(48,8,5638),new THREE.Vector3(-1225,5,3355)]; // Map Position
	aaf_.AAACol = new THREE.Vector2(0x80ffff,0x408080); // Green-Blue

//- 6. SOUND VARIABLES =========//==============================================
//- My Sounds ------------------//----------------------------------------------
//	Adjustments
	mys_.AirMsh = new makMsh();	// For Engine and Prop

//= 7. CAMERA VARIABLES ========//==============================================
//- Create Cockpit Attach Point
const CamPVC = new makMsh();
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirPBY.add(CamPVC); 	// Attach CamPVC to AirPBY (### not AirObj)
//- Camera Inputs (Outside Camera linked to air_.AirPBY; 1 Cockpit Camera Linked to cam_.PVC)
//- AIRPLANE: Start ............//..............................................
let CamSel = 1;					// Camera Selection (0 = Outside; 1 = Cockpit)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];			// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CamFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
let VewRot = 0;					// Used to rotation head in beginning Cockpit view
if (BegLoc == 1) VewRot = 45;	// Use this instead of R45, in case no access to View Keys
//- Shared Variables
let cam_ = {
		CamSel: CamSel,			// View Selector (0 = Outside, 1 = Cockpit)
		CamNum: CamNum,
		OrbFlg: 0,				// Orbit Flag (1 = Orbiting)
		// Camera
		CamLLD: new THREE.Vector3().copy(CamLLD[CamSel]), // cam_.MshRot Lat, Lon, Dst
		CamAdj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		CamMMD: new THREE.Vector3().copy(CamMMD[CamSel]), // In/Out - min,max,spd
		// Rotator
		MshRot: new makMsh(),	// Camera Rotator
		CamMMR: new THREE.Vector3().copy(CamMMR[CamSel]), // Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		CamPar: CamPar[CamSel],	// Center of Rotation	
		CamFlg: CamFlg[CamSel],	// View Flag (0 = Outside, 1 = Cockpit)
		// Linked Airplane
		CamLnk: CamLnk[CamSel],
		MshObj: new makMsh(),
		MshDeg: new makMsh(),
		// Beginning Head Rotation
		VewRot: VewRot,
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.MshRot.rotation.order = "YXZ";
	cam_.MshObj.rotation.order = "YXZ";
	cam_.MshDeg.rotation.order = "YXZ";
	cam_.CamPar.add(cam_.MshRot); // Attach Rotator
	cam_.MshObj.add(cam_.MshDeg);
//- Adjust Camera x.rotation
let CmAdjX = 0;					// Airborne Pitch Adjustment
let CmGrdF = 0;					// Camera Ground Flag (1 = On Ground)
let CmMulX = 35;				// Pitch Adjustment Multiplier
let CmLagX = 0;					// Transition Offset

//= 9. INPUT VARIABLES =========//==============================================
//- Pointer Lock Control -------//----------------------------------------------
//	Adjustments
	InpMos = new THREE.Vector2(); // Mouse Inputs
//. Setup ......................................................................
let controls = new PointerLockControls(camera, renderer.domElement,air_);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener( "unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

/*******************************************************************************
*
*	PROGRAM
*
*******************************************************************************/

//= 1. MAIN PROGRAMS ===========//==============================================

	loadAll();
	
//-	0 LOAD ALL------------------//----------------------------------------------

function loadAll() {
	WaitScreen();				// load loading screen
	loadSkyBox();
	loadGeoMat(grd_);
	loadAirObj();
	AltDif = air_.MapPos.y*AltAdj; // Used by everything
	loadObject();				// load objects
}

//- WAIT SCREEN ----------------//----------------------------------------------

function WaitScreen() {
	// Set up the loading screen scene - it can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//-	INITIALIZE -----------------//----------------------------------------------

function initAll() {
	initSkyBox();
	// Objects
	initAirObj();
	AltDif = air_.MapPos.y*AltAdj; // Used by everything
	initObject();				// Determine relative XZ location of all objects
	// Grid
	waves = new Ocean(renderer,wav_); // Init Ocean
	grd_.MSP.y = air_.MapSPS.y;
	grd_.Dsp = wav_.Dsp;
	grd_.NMS = wav_.NMS;
	grd_.Nrm = wav_.Nrm;
	grids = new GrdMap(grd_,scene);
	// Other
	initCamera(camera,cam_);	// position camera
	prntHUDval();				// print HUD values
	PawsText();
	AutoText();
	InfoText();
	// Show stats
	if (StatOn) {				// show stats
		StatOn = new Stats({
			precision: 3,
			horizontal: false
		});
		StatOn.init(renderer);
		StatOn.domElement.style.cssText = "position:absolute;top:75%;left:95%;";
		container.appendChild(StatOn.dom);
	}
	nowTim = clock.getElapsedTime();
	LodFlg = 1;
}

//- RENDER ---------------------//----------------------------------------------

async function rendAll() {		// r173 added async
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;					// Stop the function here.
	}
	if (controls.isLocked === true && !LodSnd) {
		loadSounds();
		loadRadios();
	}
	if (!PawsOn && LodFlg && controls.isLocked === true) {		
		difTim = clock.getDelta();
		nowTim = nowTim + difTim;
		// Black Out/Red Out
		if (air_.GFmult*10>7.5 || air_.GFmult*10<-5) {
			FadEnd = 0.99;
			if (air_.GFmult*10>7.5) FadCol = "black";
			else {FadCol = "red"};
		}		
		else {FadEnd = FadFlr};
		if (FadEnd != FadBeg) moveFadMsh(); // Fade In/Out
		// Camera
		moveCamera(camera,cam_);
		// Move Objects
		moveAirObj();			// Move aircaft
		AltDif = air_.MapPos.y*AltAdj; // Used by everything
		moveMinAlt();			// If on CVE, changes air_.Spd
		moveObject();			// Move objects
		moveMyPeep(myp_,difTim);
		// Move Grids
		waves.update();			// Move Ocean
		grd_.MSP.copy(air_.MapSPS);
		grids.update(grd_);		// Move Grids
		// Sounds
		moveSounds();
		// Timed Radio Sequence
		if (!air_.GrdFlg && !rad_.SeqTim && !rad_.SeqDun) strtRadSeq();
		if (rad_.SeqTim) contRadSeq();
		prntHUDval();			// print HUD values
		if (StatOn) StatOn.update(); // update stats
		// Shadow Tests (confirms that shadow values changed)
		// console.log(sunLight.shadow.mapSize.width);
		// console.log(sunLight.shadow.camera.far);
	}
	if (controls.isLocked === false && LodSnd) {
		stopSounds();
		SndFlg = MYGFlg = 0;
	}
	await renderer.renderAsync(scene, camera); // ### WebGPU requires Async, r173 added await
	renderer.resolveTimestampsAsync(THREE.TimestampQuery.RENDER); // r173
}

//= FADE =======================//==============================================

//-	Init Fade Mesh -------------//----------------------------------------------
function initFadMsh() {
	let geometry = new THREE.SphereGeometry(0.15,64,64);
	FadMat = new THREE.MeshBasicNodeMaterial({
		side:THREE.BackSide,
		colorNode:color(FadCol),
		opacity:FadBeg,
//		depthTest:false,		// No effect
//		depthWrite:false,		// NG - prop shines through
		transparent:true,
	});
	let mesh = new THREE.Mesh(geometry,FadMat);
	camera.add(mesh);
	//- Range and Visibility Tests
	if (FadBeg < FadFlr) FedBeg = FadFlr;
	if (FadBeg == FadFlr) mesh.visible = false;
	else {mesh.visible = true};

return mesh;}

//-	Move Fade Mesh -------------//----------------------------------------------
function moveFadMsh() {
	// Set Color
	FadMat.colorNode = color(FadCol);
	// Limit Range (FadFlr to 1)
	if (FadBeg < FadFlr) FadBeg = FadFlr;
	if (FadEnd < FadFlr) FadEnd = FadFlr;
	if (FadBeg > 1) FadBeg = 1;
	if (FadEnd > 1) FadBeg = 1;
	//
	FadMsh.visible = true;
	// If Black to Clear
	if (FadEnd < FadBeg) {
		FadBeg = FadBeg - FadSpd/FadBeg;
		if (FadBeg < FadEnd) {
			FadBeg = FadEnd;
//			if (FadBeg == FadEnd) FadMsh.visible = false;
		}
	}
	// If Fade to Black
	else {
		FadBeg = FadBeg + FadSpd/FadBeg;
		if (FadBeg > FadEnd) FadBeg = FadEnd;
	}
	// Set Opacity
	FadMsh.material.opacity = FadBeg;
	if (FadBeg == FadFlr) FadMsh.visible = false;
	else {FadMsh.visible = true};
}

//= 2. SKYBOX ==================//==============================================

//- Load SkyBox ----------------//----------------------------------------------
function loadSkyBox() {
	envMap = cubeLoader
		.setPath(SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	scene.environment = envMap;
	// LensFlare
	if (LnFFlg) {				// SunFlare	
		LF0Txt = txtrLoader.load(LF0Src);
		LF1Txt = txtrLoader.load(LF1Src);
	}
}

//- Init SkyBox ----------------//----------------------------------------------
function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight("white");
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(LF0Txt,256,0));
			LF.addElement(new LensflareElement(LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

//= 3. GEOMAT ===================//==============================================
// Not exported since GrdWtr is a module
function loadGeoMat(grd_) {
	loadGe1Mat(grd_.DfS,grd_.DfM); // Diffuse Textures
	loadGe1Mat(grd_.RfS,grd_.RfM); // Roughness Textures
	// Static Normal Map (Grid 2 Only) -----------------------------------------
	txtrLoader.load(grd_.N2S,function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.offset.set(0,0);
		texture.repeat.set(grd_.Stp**2/2,grd_.Stp**2/2);
		texture.needsUpdate = true;
		grd_.NM2 = texture;
	});
}

//- Load One GeoMap
function loadGe1Mat(fnam,dest) {
	let ImgDat = 0;
	let texture = 0;
	imagLoader.load(fnam,function(image) { // Load, Split and Save Textures
		context.drawImage(image,0,0,ImgSiz,ImgSiz);
		// Grid0 and Grid1 - Static Color Texture - Divided into 4 Parts
		let idx = 0;
		let siz = ImgSiz/4;
		for (let z = 0; z < 4; z++) {
			for (let x = 0; x < 4; x++) {
				ImgDat = context.getImageData(siz*x,siz*z,siz,siz);
				texture = new THREE.DataTexture(ImgDat.data,siz,siz);
				texture.format = THREE.RGBAFormat;
				texture.magFilter = THREE.LinearFilter;
				texture.minFilter = THREE.LinearMipMapLinearFilter;
				texture.generateMipmaps = true;
				texture.needsUpdate = true;
				dest[0][idx] = texture;
				dest[1][idx] = texture;
				idx++;
			}
		}
		// Grid2 - Static Color Map Texture
		ImgDat = context.getImageData(0,0,ImgSiz,ImgSiz);
		texture = new THREE.DataTexture(ImgDat.data,ImgSiz,ImgSiz);
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.offset.set(0,0);
		texture.needsUpdate = true;
		dest[2] = texture;
	});
} 

//= 4. OBJECTS =================//==============================================

function loadObject() {
	// Shared Textures
	if (txt_.ObjNum) {
		for (let n = 0; n < txt_.ObjNum; n++) {
			txt_.ObjTxt[n] = txtrLoader.load(txt_.ObjSrc[n]);	
		}
	}
	//
	loadStatic();
	loadMoving();
	loadAnmFlg(txtrLoader,flg_);
	loadMyPeep(gltfLoader,myp_);
}

function initObject() {
	initBullet(myg_,scene);
	initAAAGun();
	initStatic();
	initMoving();
}

function moveObject() {
	moveStatic();
	moveMoving();
	moveAnmObj();
	moveAAAGun();
}

//- Static Objects -------------//----------------------------------------------

function loadStatic() {
	loadIsland();
	if (fxd_.ObjNum) loadFxdObj();
	
}

function initStatic() {
	initIsland();
}

function moveStatic() {
	moveIsland();
	if (fxd_.ObjNum) moveFxdObj();
}

//- Moving Objects -------------//----------------------------------------------

function loadMoving() {
	loadMovPln();
	loadMovShp();
}

function initMoving() {
	initMovPln();
	initMovShp();
}

function moveMoving() {
	moveMovPln();
	moveMovShp();
}

//- Animated Attachments -------//----------------------------------------------

function loadAnmObj() {
	loadAnmFlg();
}

function moveAnmObj() {
	moveAnmFlg(flg_,nowTim);
}

//- AAA Guns -------------------//----------------------------------------------

function initAAAGun() {
	if (aaf_.ObjNum) {
		aaf_.SmkMap = txt_.ObjTxt[aaf_.SmkMap];
		initAAGuns(aaf_,air_,AltDif,scene);
		// Create Exploding Center
		for (let n = 0; n < aaf_.ObjNum; n ++) {
			aaf_.ExpPtr[n] = makeSphere("crimson");
			aaf_.SmkPtr[n].add(aaf_.ExpPtr[n]);
		}
	}
}

function moveAAAGun() {
	if (aaf_.ObjNum) {
		for (let n = 0; n < aaf_.ObjNum; n ++) {
			// Adjust Gun Longitude
			AARYDf[n] = Mod360(AARYDf[n]+0.005); // Range 0 to 360
			aaf_.GunRot[n].y = AARYBg[n] + 5*Math.sin(AARYDf[n]); // Offset = -45 to +45
		}
		moveAAGuns(aaf_,air_,AltDif,DLTime,GrvDLT,SndFlg);
		// Explosion
		for (let n = 0; n < aaf_.ObjNum; n ++) {
			if (aaf_.SmkFlg[n]) {
				aaf_.ExpSiz[n] = 1/200; // Start Size
				aaf_.ExpLif[n] = 0.15; // Start Life (seconds)
				aaf_.ExpPtr[n].visible = true;
			}
			if (aaf_.ExpLif[n] > 0) {
				aaf_.ExpPtr[n].scale.setScalar(aaf_.ExpSiz[n]);
				aaf_.ExpSiz[n] = aaf_.ExpSiz[n] + 1/200;
				aaf_.ExpLif[n] = aaf_.ExpLif[n] - DLTime;
				if (aaf_.ExpLif[n] < 0) {
					aaf_.ExpLif[n] = 0;
					aaf_.ExpPtr[n].visible = false;
				}
			}
		}	
		// Play Sound (No Delay)
//		for (let n = 0; n < aaf_.ObjNum; n ++) {
//			if (SndFlg && aaf_.SmkFlg[n]) aaf_.SndPtr[n].play();
//		}
		// Play Sound With Delay
		for (let n = 0; n < aaf_.ObjNum; n ++) {
			// Start Delay
			if (aaf_.SmkFlg[n]) { // Start Countdown
				let X = aaf_.SmkPtr[n].position.x; // SndMsh attached to SmkPtr
				let Z = aaf_.SmkPtr[n].position.z;
				let delay = (Math.sqrt(X*X+Z*Z)/343);
				if (delay > (aaf_.SmkDMx[n]-1)) delay = (aaf_.SmkDMx[n]-1); // Avoid overlap issues
				aaf_.SndDTm[n] = delay;	
			}
			// If End of Delay Start Sound
			if (aaf_.SndDTm[n]) aaf_.SndDTm[n] = aaf_.SndDTm[n] - DLTime;
			if (aaf_.SndDTm[n] < 0) {
				aaf_.SndDTm[n] = 0;
				if (SndFlg) aaf_.SndPtr[n].play();
			}
		}
	}
}

//- Sphere ---------------------//---------------------------------------------
//	Used to create flash explosions

function makeSphere(col) {
	let geometry = new THREE.SphereGeometry(1,32,16);
	let	material = new THREE.MeshBasicNodeMaterial({colorNode:color(col),transparent:true,opacity:1});
	let mesh = new THREE.Mesh(geometry,material);
	mesh.visible = false;
return mesh;}

//= ISLANDS ====================//==============================================

//-	Load Islands ---------------//----------------------------------------------
function loadIsland() {
	for (let i = 0; i < isl_.ObjNum; i++) {
		isl_.ObjGrp[i].position.copy(isl_.MapPos[i]);
		scene.add(isl_.ObjGrp[i]);
	}
	for (let i = 0; i < isl_.ObjNum; i++) {
	// Transparent Island Objects
		txtrLoader.load(isl_.ObjTxt[i], function (IslTxt) {	
			let mat = new THREE.MeshLambertNodeMaterial({colorNode: texture(IslTxt), transparent: true});
			gltfLoader.load(isl_.ObjSrc[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender island must include a UV map
					if (child.isMesh) {
						child.material = mat;
						child.receiveShadow = true;
					}
				});
				isl_.ObjAdr[i] = gltf.scene;
				isl_.ObjAdr[i].scale.setScalar(isl_.ObjSiz[i]);
				isl_.ObjAdr[i].rotation.copy(isl_.ObjRot[i]);
				isl_.ObjGrp[i].add(isl_.ObjAdr[i]);
			});
		});
	}
}

//-	Init Islands ---------------//----------------------------------------------
function initIsland() {
	let X,Y,Z;
	for (let i = 0; i < isl_.ObjNum; i++) {
		// Set Relative Position
		// (cause Objects to elevate above water as we climb to prevent flicker)
		X = isl_.MapPos[i].x-air_.MapPos.x;
		Y = isl_.MapPos[i].y-AltDif;
		Z = air_.MapPos.z-isl_.MapPos[i].z;
		isl_.ObjGrp[i].position.set(X,Y,Z);
	}
	// Specific Atached Objects
	initVlkSmk();				// Load Volcano Smoke
}

//-	Move Islands ---------------//----------------------------------------------
function moveIsland() {
	let X,Y,Z;
	for (let i = 0; i < isl_.ObjNum; i ++) {
		// Compute New Relative Position
		// (cause Islands to elevate above water as we climb to prevent flicker)
		X = isl_.MapPos[i].x-air_.MapPos.x;
		Y = isl_.MapPos[i].y-AltDif;
		Z = air_.MapPos.z-isl_.MapPos[i].z;
		isl_.ObjGrp[i].position.set(X,Y,Z);
	}
}

//- Init Volcano Smoke ---------//----------------------------------------------
function initVlkSmk() {
	grs_.ObjTxt = txt_.ObjTxt[grs_.ObjTxt];
	initGrdSmk(grs_);
	grs_.SmkMsh[0].position.copy(grs_.MapPos[0]);
	grs_.ObjRef[0].add(grs_.SmkMsh[0]);
}

//= STATIC OBJECTS =============//==============================================

//- Load Objects ---------------//----------------------------------------------
function loadFxdObj() {
	for (let i = 0; i < fxd_.ObjNum; i++) {
		gltfLoader.load(fxd_.ObjSrc[i], function (gltf) {
			fxd_.ObjAdr[i] = gltf.scene;
			fxd_.ObjAdr[i].scale.setScalar(fxd_.ObjSiz[i]);
			fxd_.ObjAdr[i].rotation.copy(fxd_.ObjRot[i]);
			fxd_.ObjAdr[i].position.copy(fxd_.MapPos[i]);
			fxd_.ObjRef[i].add(fxd_.ObjAdr[i]);
		});
	}
//	initHgrFyr();		// Needs More Work
}

//- Move Objects ---------------//----------------------------------------------
function moveFxdObj() {
	for (let i = 0; i < fxd_.ObjNum; i++) {
		fxd_.ObjAdr[i].position.y = fxd_.MapPos[i].y + AltDif*0.01;
	}
}

//- Init Hangar Fire -----------//----------------------------------------------
function initHgrFyr() {
	grf_.ObjTxt = txt_.ObjTxt[grf_.ObjTxt];
	initGrdFyr(grf_);
	//-	Link	
	grf_.SmkMsh[0].position.copy(grf_.MapPos[0]);
	grf_.ObjRef[0].add(grf_.SmkMsh[0]);
	grf_.FyrMsh[0].position.copy(grf_.MapPos[0]);
	grf_.ObjRef[0].add(grf_.FyrMsh[0]);
}

//= MOVING AIRPLANES ===========//==============================================

//-	Load Airplane --------------//----------------------------------------------
function loadMovPln() {
	for (let n = 0; n < xac_.ObjNum; n ++) {
		gltfLoader.load(xac_.ObjSrc[n], function (gltf) {
			xac_.ObjAdr[n] = gltf.scene;
			// Convert from feet to meters
			xac_.ObjAdr[n].scale.setScalar(xac_.ObjSiz[n]);
			// Propeller
			let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
			xac_.MixSpn[n] = new THREE.AnimationMixer(xac_.ObjAdr[n]);
			let actun = xac_.MixSpn[n].clipAction(clip);
			actun.play();
			if (xac_.MixSpn[n]) xac_.MixSpn[n].setTime(anm_.spnprp/anm_.anmfps);
			// Bank
			clip = THREE.AnimationClip.findByName(gltf.animations, "AC_BankAction");
			xac_.MixBnk[n] = new THREE.AnimationMixer(xac_.ObjAdr[n]);
			actun = xac_.MixBnk[n].clipAction(clip);
			actun.play();
			if (xac_.MixBnk[n]) xac_.MixBnk[n].setTime(xac_.AnmBnk[n]/anm_.anmfps);
			// Pitch
			clip = THREE.AnimationClip.findByName(gltf.animations, "AC_PtchAction");
			xac_.MixPit[n] = new THREE.AnimationMixer(xac_.ObjAdr[n]);
			actun = xac_.MixPit[n].clipAction(clip);
			actun.play();
			if (xac_.MixPit[n]) xac_.MixPit[n].setTime(xac_.AnmPit[n]/anm_.anmfps);
			// Rotation
			xac_.ObjAdr[n].rotation.order = "YXZ"; // Heading, Pitch, Bank
			xac_.ObjAdr[n].rotation.y = xac_.ObjRot[n].y*DegRad;
		});
	}

}

//- Init Airplane --------------//----------------------------------------------
function initMovPln() {
	for (let n = 0; n < xac_.ObjNum; n ++) {
		// Compute Relative Position
		// (cause Objects to elevate above water as we climb to prevent flicker)
		let X = xac_.MapPos[n].x-air_.MapPos.x;
		let Y = xac_.MapPos[n].y-AltDif;
		let Z = air_.MapPos.z-xac_.MapPos[n].z;
		xac_.ObjAdr[n].position.set(X,Y,Z);
		scene.add(xac_.ObjAdr[n]);
	};
	initXACGun();				// Enemy Airplane Only
	initXACExp(1);				// Enemy Airplane Only
	initXACSmk(0);				// Friendly Airplane Only
	initXACFyr(1);				// Enemy Airplane Only
}

//- Move Plane -----------------//----------------------------------------------
function moveMovPln() {
	for (let n = 0; n < xac_.ObjNum; n ++) {
		// Rotation
		if (!xac_.EndSeq[n]) {	// Horizontal Turning Flight
			let XPHSpd = Math.tan(xac_.ObjRot[n].z*DegRad)*xac_.SpdMPS[n]/GrvMPS;
			XPHSpd = XPHSpd * DLTime;
			xac_.ObjRot[n].y = xac_.ObjRot[n].y + XPHSpd;
		}
		else {moveXACEnd(n)}	// If Ending Sequence
		xac_.ObjAdr[n].rotation.set(xac_.ObjRot[n].x*DegRad,xac_.ObjRot[n].y*DegRad,xac_.ObjRot[n].z*DegRad);
		//- Map Speed ..........................................................
		//- Default = Horizontal Only
		let SpdMPF = xac_.SpdMPS[n] * DLTime; // Speed (m/t)
		let SpeedY = SpdMPF * Math.sin(xac_.ObjRot[n].x * DegRad);
		if (!xac_.EndSeq[n]) SpeedY = 0; // avoid rounding errors
		let GS = -SpdMPF * Math.cos(xac_.ObjRot[n].x * DegRad)
		let SpeedZ = GS * Math.cos(xac_.ObjRot[n].y * DegRad);
		let SpeedX = GS * Math.sin(xac_.ObjRot[n].y * DegRad);
		//. Recompute Map Position .............................................
		xac_.MapPos[n].x = xac_.MapPos[n].x + SpeedX;
		xac_.MapPos[n].z = xac_.MapPos[n].z - SpeedZ;
		xac_.MapPos[n].y = xac_.MapPos[n].y + SpeedY;
		// Animation - Prop (same as mine)
		if (xac_.MixSpn[n]) xac_.MixSpn[n].setTime(anm_.spnprp/anm_.anmfps);
		//. Compute New Relative Position ......................................
		let X = xac_.MapPos[n].x-air_.MapPos.x;
		let Y = xac_.MapPos[n].y-AltDif;
		let Z = air_.MapPos.z-xac_.MapPos[n].z;
		xac_.ObjAdr[n].position.set(X,Y,Z);
	}
	if (!xac_.EndSeq[1]) moveXACGun(1); // Enemy Airplane Only
}

//= XAC GUNS ===================//==============================================

//- Init Airplane Guns ---------//----------------------------------------------
function initXACGun() {
	initXACBul(xag_,scene);
}

//- Move XAC Guns --------------//----------------------------------------------
//	Enemy Airplane Only
function moveXACGun(n) {
	// Turn Airplane 2 (Enemy) Guns On/Off
	xag_.BulFlg[n] = 0;			// Default = Off
	// Counter
	XPGFlg = XPGFlg - 1;
	if (XPGFlg < XPGMin) XPGFlg = XPGMax;
	// On or Off
	let MinDst = 500;
	let X = xag_.XACPos[n].x - air_.MapPos.x;
	let Y = xag_.XACPos[n].y - AltDif;
	let Z = air_.MapPos.z - xag_.XACPos[n].z;
	if (X < MinDst && Y < MinDst && Z < MinDst) { // If Visible
		if (XPGFlg > 0) xag_.BulFlg[n] = 1;
		else {xag_.BulFlg[n] = 0;}
	}
	moveXACBul(xag_,air_,AltDif,DLTime,GrvDLT);
}

//= XAC END SEQUENCE ===========//==============================================

function moveXACEnd(n) {
	// n = xac number
	// this sequence called if xac_.EndSeq[n] = 1;
	// TimRem Starts at 0, So Starts Next Event
	if (!xat_.TimRem) {			// Start New Actions
		xat_.SegIdx ++;
		// Set Timd
		xat_.TimRem = xat_.SegTim[xat_.SegIdx];
		// Select Actions
		if (xat_.SegIdx == 0) begnXACExp(n); // Begin Explosion 1
		if (xat_.SegIdx == 1) {
			stopXACExp(n); // Stop Explosion 1
			begnXACFyr(n); // Start Smoke and Fire
		}
		if (xat_.SegIdx == 2) {
			begnXACExp(n);		// Begin Explosion 2
			stopXACFyr(n);		// End Smoke and Fire
		}
		if (xat_.SegIdx == 3) {
			stopXACExp(n);
			xac_.ObjAdr[n].visible = false; // Airplane gone
		}
		if (xat_.SegIdx == 4) playRadSeg(2); // Play Radio Call
		if (xat_.SegIdx == 5) xac_.EndSeq[n] = 1;
	}
	else {						// Continuing Actions
		if (xat_.SegIdx == 0) contXACExp(n);
		if (xat_.SegIdx == 1) makeXACSpn(n);
		if (xat_.SegIdx == 2) contXACExp(n);
		xat_.TimRem = xat_.TimRem - DLTime;
		if (xat_.TimRem < 0) xat_.TimRem = 0;
	}
}

//-	Begin Explosion ------------//----------------------------------------------
function begnXACExp(n) {
	xae_.ExpSiz = 0.1;			// Start Size
	xae_.ExpMsh.visible = true;
	if (!xac_.SndPtr[n].isPlaying) xac_.SndPtr[n].play();
}

//- Continue Explosion ---------//----------------------------------------------
function contXACExp(n) {
	xae_.ExpMsh.scale.setScalar(xae_.ExpSiz);
	xae_.ExpSiz = xae_.ExpSiz + 1/Ft2Mtr;
}

//-	Stop Explosion -------------//----------------------------------------------
function stopXACExp(n) {
	xae_.ExpSiz = 0.01;			// End Size
	xae_.ExpMsh.visible = false;
	if (xac_.SndPtr[n].isPlaying) xac_.SndPtr[n].stop();
}

//-	Begin Smoke and Fire -------//----------------------------------------------
function begnXACFyr(n) {
	xaf_.SmkMsh[0].visible = true;
	xaf_.FyrMsh[0].visible = true;
}

//-	End Smoke and Fire ---------//----------------------------------------------
function stopXACFyr(n) {
	xaf_.SmkMsh[0].visible = false;
	xaf_.FyrMsh[0].visible = false;
}

//-	Make Airplane Spin ---------//----------------------------------------------
function makeXACSpn(n) {
	xac_.ObjRot[n].z = Mod360(xac_.ObjRot[n].z - 1); // Roll Right
	if (xac_.ObjRot[n].x > -90) {
		xac_.ObjRot[n].x = xac_.ObjRot[n].x - 0.1; // Pitch Down
		if (xac_.ObjRot[n].x < -90) xac_.ObjRot[n].x = -90;
	}
}

//= AIRPLANE SMOKE =============//==============================================

//- Init Airplane Explosion ----//----------------------------------------------
function initXACExp(n) {
	// Attach Exploding Center
	xac_.ObjAdr[n].add(xae_.ExpMsh); // Attach to Enemy Airplane
	xae_.ExpMsh.visible = false;
}

//- Init Airplane White Smoke --//----------------------------------------------
function initXACSmk(n) {
	// Create Emitter
	xas_.ObjTxt = txt_.ObjTxt[xas_.ObjTxt];
	initAirSmk(xas_);
	// Attach to Friendly Airplane
	xac_.ObjAdr[n].add(xas_.SmkMsh[0]);
//	xas_.SmkMsh[0].visible = false;	// Always On
}

//- Init Airplane Black Smoke --//----------------------------------------------
function initXACFyr(n) {
	// Create Emitter
	xaf_.ObjTxt = txt_.ObjTxt[xaf_.ObjTxt];
	initAirFyr(xaf_);
	// Attach to Enemy Airplane
	xac_.ObjAdr[n].add(xaf_.SmkMsh[0]);
	xac_.ObjAdr[n].add(xaf_.FyrMsh[0]);
	// Turn Off
	xaf_.SmkMsh[0].visible = false;
	xaf_.FyrMsh[0].visible = false;
}

//= MOVING SHIPS ===============//==============================================

//	Load Ship
function loadMovShp() {
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		gltfLoader.load(xsh_.ObjSrc[n], function (gltf) {
			gltf.scene.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
				}
			});
			xsh_.ObjAdr[n] = gltf.scene;
			xsh_.ObjAdr[n].scale.setScalar(xsh_.ObjSiz[n]); // Scale
			// Animated Radar
			if (n == 0) {
				// Radar
				let clip = THREE.AnimationClip.findByName(gltf.animations, "RadarAction");
				xsh_.MixRdr[n] = new THREE.AnimationMixer(xsh_.ObjAdr[n]);
				let actun = xsh_.MixRdr[n].clipAction(clip);
				actun.play();
				if (xsh_.MixRdr[n]) xsh_.MixRdr[n].setTime(xsh_.AnmRdr[n]/anm_.anmfps);
			}
			xsh_.ObjAdr[n].position.set(0,0,0); // position within group is always 0,0,0
		});
	}
}

//	Init Ship
function initMovShp() {
// Always use group
	let X, Y, Z;
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		xsh_.ObjGrp[n].rotation.order = "YXZ";
		// Compute Relative Position
		// (cause Objects to elevate above water as we climb to prevent flicker)
		X = xsh_.MapPos[n].x-air_.MapPos.x;
		Y = xsh_.MapPos[n].y-AltDif;
		Z = air_.MapPos.z-xsh_.MapPos[n].z;
		xsh_.ObjGrp[n].position.set(X,Y,Z);
		xsh_.ObjGrp[n].add(xsh_.ObjAdr[n]);
		scene.add(xsh_.ObjGrp[n]);		// Uses position of CVE to compute relative position
	}
	initXSHWak();			// Init Ship Wake
	initXSHGun();	
}

//	Move Ship
function moveMovShp() {
	let X, Y, Z;
	for (let n = 0; n < xsh_.ObjNum; n ++) {
		// Change in Heading
		let XSHSpd = 0;		// for now
		let XSHPit = 0;
		XSHSpd = XSHSpd * DLTime;
		xsh_.ObjRot[n].y = xsh_.ObjRot[n].y + XSHSpd;	
		// Rock the boat
		if (n == 0) {
			xsh_.ShpPit[n] = Mod360(xsh_.ShpPit[n] + 0.5);
			let PitAdj = 1.5*DegRad*Math.sin(xsh_.ShpPit[n]*DegRad);
			xsh_.ObjRot[n].x = PitAdj;
			xsh_.ObjGrp[n].rotation.copy(xsh_.ObjRot[n]);
		}
		// Speed (Only Horizontal)
		let SpdMPF = xsh_.SpdMPS[n] * DLTime; // Speed (u/t)
		xsh_.MapSpd[n].z = -SpdMPF * Math.cos(xsh_.ObjRot[n].y*DegRad);
		xsh_.MapSpd[n].x = -SpdMPF * Math.sin(xsh_.ObjRot[n].y*DegRad);
		// Recompute Map Postion
		xsh_.MapPos[n].x = xsh_.MapPos[n].x + xsh_.MapSpd[n].x;
		xsh_.MapPos[n].z = xsh_.MapPos[n].z - xsh_.MapSpd[n].z;
		// Compute New Relative Position
		X = xsh_.MapPos[n].x-air_.MapPos.x;
		Y = xsh_.MapPos[n].y-AltDif;
		Z = air_.MapPos.z-xsh_.MapPos[n].z;
		xsh_.ObjGrp[n].position.set(X,Y,Z);
		// Compute Distance (for Viz Tests)
		X = xsh_.ObjGrp[n].position.x;
		Z = xsh_.ObjGrp[n].position.z;
		xsh_.ObjDst[n] = Math.sqrt(X*X+Z*Z); // Compute distance
		// Attached Objects
		if (n == 0) {
			// Radar
			xsh_.AnmRdr[n] = xsh_.AnmRdr[n] - 0.1;
			if (xsh_.AnmRdr[n] < 0) xsh_.AnmRdr[n] = 359;
			if (xsh_.MixRdr[n]) xsh_.MixRdr[n].setTime(xsh_.AnmRdr[n]/anm_.anmfps);
			// Wake
			moveXSHWak();
			moveXSHGun();
		}
	}
}

//= SHIP WAKE ==================//==============================================

//- Init Ship Wake -------------//----------------------------------------------
function initXSHWak() {
	for (let n = 0; n < wak_.ObjNum; n ++) {
		wak_.ObjTxt[n] = txt_.ObjTxt[wak_.ObjTxt[n]];
	}
	initShpWak(wak_);
};

//- Move Ship Wake -------------//----------------------------------------------
function moveXSHWak() {
	for (let n = 0; n < wak_.ObjNum; n ++) {
		wak_.ObjAdr[n].rotation.x = Math.PI/2-wak_.ObjRef[n].rotation.x; // Remain flat
	}
}

//= SHIP GUNS ==================//==============================================

//- Init Ship Guns -------------//----------------------------------------------
function initXSHGun() {
	xsg_.SmkMap = txt_.ObjTxt[xsg_.SmkMap];
	initAAGuns(xsg_,air_,AltDif,scene);
}

//- Move Ship Guns -------------//----------------------------------------------
function moveXSHGun() {
	if (xsg_.ObjNum) {
		// Turn Ship 2 Guns On/Off
		XSGFlg = XSGFlg - 1;
		if (XSGFlg > 0) xsg_.AAAFlg[1] = 1;
		else {
			xsg_.AAAFlg[1] = 0;
			if (XSGFlg < XSGMin) XSGFlg = XSGMax;
		}
		moveAAGuns(xsg_,air_,AltDif,DLTime,GrvDLT,SndFlg);
		// Play Sound (No Delay)
//		for (let n = 0; n < xsg_.ObjNum; n ++) {
//			if (xsg_.SmkFlg[n] && SndFlg) xsg_.SndPtr[n].play()
//		}
		// Play Sound With Delay
		for (let n = 0; n < xsg_.ObjNum; n ++) {
			// Start Delay
			if (xsg_.SmkFlg[n]) {
				let X = xsg_.SmkPtr[n].position.x;
				let Z = xsg_.SmkPtr[n].position.z;
				let delay = Math.sqrt(X*X+Z*Z)/343;
				if (delay > (xsg_.SmkDMx[n]-1)) delay = (xsg_.SmkDMx[n]-1); // Avoid overlap issues
				xsg_.SndDTm[n] = delay;
			}
			// If End of Delay Start Sound
			if (xsg_.SndDTm[n] > 0) xsg_.SndDTm[n] = xsg_.SndDTm[n] - DLTime;
			if (xsg_.SndDTm[n] < 0) {
				xsg_.SndDTm[n] = 0;
				if (SndFlg) xsg_.SndPtr[n].play();
			}
		}
	}
}

//= HARDENED SURFACES ==========//==============================================
// The hardened surfaces are the Home Airfield and the CVE Deck (moving)
// Where CVE not facing north, can we rotate ref points and airplane to north?

// Compute Minimum Altitude
function moveMinAlt() {
	air_.GrdZed = 0;			// Default
	let PX,PZ;
	let Msh = 0;
	for (let i = 0; i < alt_.Num; i++) {
		Msh = alt_.Ref[i];
		PX = -Msh.position.x;
		PZ = Msh.position.z;
		if (alt_.Lft[i] < PX && alt_.Rgt[i] > PX && alt_.Fnt[i] > PZ && alt_.Bak[i] < PZ) {
			air_.GrdZed = alt_.Alt[i];
			if (alt_.Typ[i]) moveShpAlt();
		}
	}
}

function moveShpAlt() {
	InpBrk = 0;					// Default = no brake
	air_.ShpPit = 0;			// Default
	// Recompute GrdZed
	let ZDst = xsh_.MapPos[0].z - air_.MapPos.z; // Z-distance from ship center
	let YDif = ZDst * Math.sin(xsh_.ObjRot[0].x); // Y-change caused by ship pitch
	air_.GrdZed = alt_.Alt[1] - YDif;
	//
	if (air_.GrdFlg) {		// If Landed
		if (air_.PwrPct < 0.5 && anm_.thkpos < 180) InpBrk = 0.01; // Auto-braking if power < 50% and hook extended
		let ShpKPH = xsh_.SpdMPS[0]*3.6; // Ship speed
		if (!air_.MovFlg) {
			if (air_.SpdKPH <= ShpKPH) { // If airplane speed <= Ship speed, lock to deck	
				air_.MovFlg = 1; // Flag
				InpBrk = 0;	// Brake off
				let XOff = air_.MapPos.x - xsh_.MapPos[0].x;
				let ZOff = air_.MapPos.z - xsh_.MapPos[0].z; // Z-distance from ship center
				xsh_.ShpLok[0].position.x = XOff;
				xsh_.ShpLok[0].position.z = ZOff;
				xsh_.ShpLok[0].add(air_.AirObj);
				if (anm_.thkpos < 180) anm_.thkspd = 1;	// Retract tailhook
			}
		}
		if (air_.MovFlg && air_.SpdKPH > ShpKPH) air_.MovFlg = 0; // Unlock from deck if moving faster than Ship
		if (air_.MovFlg) {	// Otherwise remain locked to deck
			sunLight.shadow.camera.far = SunDst+2*ShdBox; // Default on deck
			// Recompute Speed and Position
			air_.MapSpd.z = -xsh_.MapSpd[0].z;
			air_.MapSpd.x = -xsh_.MapSpd[0].x;
			air_.MapPos.z = air_.MapPos.z + air_.MapSpd.z;
			air_.MapPos.x = air_.MapPos.x + air_.MapSpd.x;
			air_.MapSPS.x = air_.MapSpd.x;
			air_.MapSPS.z = air_.MapSpd.z;			
			// Recompute air_.Spd
			if (air_.PwrPct < 0.5) {
				air_.SpdKPH = air_.SpdMPS = 0;
				air_.ShpPit = -xsh_.ObjRot[0].x;
			}
			else {
				air_.SpdKPH = ShpKPH; // (KPH)
				air_.SpdMPS = air_.SpdKPH/3.6; // (mps)
				xsh_.ShpLok[0].remove(air_.AirObj); // Unlock
				scene.add(air_.AirObj); // Was detached from scene
				if (!cam_.CamSel) sunLight.shadow.camera.far = SunDst+ShdBox+ShdDst;
			}
			sunLight.shadow.camera.updateProjectionMatrix();
			// Point Same Direction as Carrier
			// [WIP]
		}
	}
}

//= 5. MY AIRPLANE =============//==============================================

//= Load Airplane ==============//==============================================
function loadAirObj() {
	loadAirExt(gltfLoader,air_,mxr_,anm_);
	loadAirInt(gltfLoader,air_,vxr_,anm_);
}

//= Init Airplane ==============//==============================================
// This section initializes starting location and variables before passing to Flight Module
function initAirObj() {
	//	Starting Location
	if (BegLoc == 0) { 			// Base
		air_.GrdFlg = 1;
		air_.MapPos.x = isl_.MapPos[0].x-610;
		air_.MapPos.z = isl_.MapPos[0].z-275;	
		air_.MapPos.y = air_.GrdZed = alt_.Alt[0];
		anm_.lngpos = 0;		// Landing Gear Down
	}
	if (BegLoc == 1) { 			// CVE
		air_.GrdFlg = air_.MovFlg = 1;
		air_.MapPos.copy(xsh_.MapPos[0]);
		air_.MapPos.y = air_.GrdZed = alt_.Alt[1];
		let ZDst = 45;
		air_.MapPos.z = air_.MapPos.z - ZDst;
		xsh_.ShpLok[0].position.z = ZDst;
		xsh_.ShpLok[0].add(air_.AirObj);
		anm_.lngpos = 0;		// Landing Gear Down
		anm_.canpos = 0;		// Canopy Open
	}
	if (BegLoc == 2) { 			// Air
		PwrDif = 1000;
		air_.SpdKPH = 200;
		air_.MapPos.y = air_.MapSPS.y = 200;
		anm_.lngpos = 180;		// Landing Gear Up
	}
	// Speed
	if (air_.SpdKPH) {
		air_.SpdMPS = air_.SpdKPH/3.6; // Speed - meters per second
		air_.SpdMPF = (air_.SpdKPH/3.6)*DLTime; // Speed - meters per frame
	}
	// Altitude
	if (air_.MapPos.y == 0) air_.GrdFlg = 1;
	grd_.MSP.y = air_.MapPos.y; // Use to initialize objects
	// Flight
	flight = new Flight(air_);	// position airplane using air_.GrdZed
	air_.PYBmul.x = air_.PYBmul.x*MosMul.x;	// Pitch Adjustment
	air_.PYBmul.z = air_.PYBmul.x*MosMul.z;	// Bank Adjustment
}

//= Move Airplane ==============//==============================================
// This section processes Input before passing to Flight Module
// And manages Views and Animations
function moveAirObj() {
	// Compute Inputs ----------..----------------------------------------------
	// Power Percent ...........................................................
	// Add Delay
	let gal = PwrDif * LagPwr.x; // Current input delayed
	let lag = LagPwr.y * LagPwr.z; // Released from Cumulator
	LagPwr.z = LagPwr.z + gal - lag; // Change in Cumulator
	PwrDif = PwrDif - gal + lag;
	// Input Engine Power
	air_.PwrPct = air_.PwrPct + PwrDif;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	PwrDif = 0;					// Reset
	// Coefficient of Lift .....//..............................................
	if (air_.AutoOn) {			// Autopilot
		air_.CfLDif = air_.InpKey.x;
		// Add Delay to Lift
		gal = air_.CfLDif * LagAtP.x; // Current input delayed
		lag = LagCfL.z * LagAtP.y; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	else {
		air_.CfLDif = InpMos.y * air_.PYBmul.x; // Input Coefficient of Lift
		// Add Delay to Lift
		gal = air_.CfLDif * LagCfL.x; // Current input delayed
		lag = LagCfL.z * LagCfL.y; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	air_.CfLDif = air_.CfLDif - gal + lag;
	air_.CfLift = air_.CfLift + air_.CfLDif; // New Coefficient of Lift	
	// Limits
	if (air_.CfLift > air_.CfLMax) air_.CfLift = air_.CfLMax;
	if (air_.CfLift < -air_.CfLMax) air_.CfLift = -air_.CfLMax;
	anm_.stkpit = InpMos.y;		// Joystick pitch animation
	InpMos.y = 0;				// Reset
	// Coefficient of Lift - Flaps
	air_.CfFlap = air_.FlpCfL*(180-anm_.flppos)/180; // [Flap]
	// Bank ....................................................................
	if (air_.AutoOn) {
		air_.RotDif.z = air_.InpKey.z;
		air_.OldRot.z = air_.OldRot.z + air_.RotDif.z*DegRad;
	}
	else {
		// Add Delay to Change in Bank Rate due to Mouse
		let BnkDif = InpMos.x * air_.PYBmul.z;
		gal = BnkDif * LagBnk.x; // Current input delayed
		lag = LagBnk.y * LagBnk.z; // Released from Cumulator
		LagBnk.z = LagBnk.z + gal - lag; // Change in Cumulator
		BnkDif = BnkDif - gal + lag;
		air_.RotDif.z = air_.RotDif.z + BnkDif;	
		air_.RotDif.z = MaxVal(air_.RotDif.z,air_.BnkMax);	// Max values
		if (air_.RotDif.z == air_.BnkMax && BnkDif < 0) air_.RotDif.z = BnkDif;
		if (air_.RotDif.z == -air_.BnkMax && BnkDif > 0) air_.RotDif.z = BnkDif;
		air_.RotDif.z = air_.RotDif.z; // Inputs are +/-
		air_.AGBank = air_.RotDif.z;
		anm_.stkbnk = InpMos.x;	// Joystick bank animation
		InpMos.x = 0;			// Reset
	}
	// Input Yaw
	if (air_.SpdKPH < 1) air_.RotDif.y = 0;	// No Yaw if Speed < 1;
	// Input Brakes
	air_.BrkVal = InpBrk;		// Brakes
	// Compute Rotation and Vectors --------------------------------------------
	flight.update();
	// Animate -----------------------------------------------------------------	
	if (cam_.CamFlg) moveAirInt(air_,vxr_,anm_,cam_.CamLLD); // VC
	else moveAirExt(air_,mxr_,anm_); // Outside
	// Bullets
	moveBullet(myg_,air_,DLTime,GrvDLT,MYGFlg);
	testHitBox();
}

//= HITBOX =====================//==============================================

function testHitBox() {
	let n = myg_.HitTgt;
	if (!xac_.EndSeq[n]) { // If Not Already in Sequence
		// Check Bullets for Hit
		for (let i = 0; i < myg_.BulNum; i ++) {
			// Hitting Target?
			if (Math.abs(xac_.ObjAdr[n].position.x - myg_.BulPtr[i].position.x) < myg_.HitDst) {
				if (Math.abs(xac_.ObjAdr[n].position.y - myg_.BulPtr[i].position.y) < myg_.HitDst) {
					if (Math.abs(xac_.ObjAdr[n].position.z - myg_.BulPtr[i].position.z) < myg_.HitDst) {
						xac_.HitCnt[n]++;
					}
				}
			}
		}
	}
	// Start Ending Sequence
	if (!xac_.EndSeq[n] && xac_.HitCnt[n] > xac_.HitMax) {
		xac_.EndSeq[n] = xac_.EndTim;
		xac_.HitCnt[n] = 0;		// Reset Hit Counter
	}
}

//= 6. SOUNDS ==================//==============================================

//- Load and Initialize Positional Sounds --------------------------------------
function loadSounds() {
	air_.AirObj.add(mys_.AirMsh);
	mys_.AirMsh.position.z = -5;
	let RefDst = 25;			// Reference distance for Positional Audio
	// My Airplane .............................................................
	// Engine
	mys_.EngSnd = new THREE.PositionalAudio(listener);
	audoLoader.load(mys_.EngSrc,function(buffer) {
		mys_.EngSnd.setBuffer(buffer);
		init1Sound(mys_.EngSnd,RefDst,0,1,1,mys_.AirMsh);		
	});
	// My Prop
	mys_.PrpSnd = new THREE.PositionalAudio(listener);
	audoLoader.load(mys_.PrpSrc,function(buffer) {
		mys_.PrpSnd.setBuffer(buffer);
		init1Sound(mys_.PrpSnd,RefDst,0,1,1,mys_.AirMsh);
	});
	// My Guns (Left and Rite)
	let xoff = 5
	for (let n = 0; n < myg_.ObjNum; n ++) {
		myg_.SndPtr[n] = new THREE.PositionalAudio(listener);
		audoLoader.load(myg_.SndSrc,function(buffer) {
			myg_.SndPtr[n].setBuffer(buffer);
			init1Sound(myg_.SndPtr[n],RefDst,0,1,1,myg_.SndMsh[n]);
			xoff = -xoff;
			myg_.SndMsh[n].position.x = xoff;
			air_.AirObj.add(myg_.SndMsh[n]);
		});
	}
	// Load XAC Sounds .........................................................
	// XP Engines
	for (let n = 0; n < xac_.ObjNum; n ++) {
		xac_.EngPtr[n] = new THREE.PositionalAudio(listener);
		audoLoader.load(xac_.EngSrc[n],function(buffer) {
			xac_.EngPtr[n].setBuffer(buffer);
			init1Sound(xac_.EngPtr[n],RefDst,0,1.3,1,xac_.EngMsh[n]);
			xac_.ObjAdr[n].add(xac_.EngMsh[n]);
		});
	}
	// XP Guns
	for (let n = 0; n < xag_.ObjNum; n ++) {
		xag_.SndPtr[n] = new THREE.PositionalAudio(listener);
		audoLoader.load(xag_.SndSrc[n],function(buffer) {
			xag_.SndPtr[n].setBuffer(buffer);
			init1Sound(xag_.SndPtr[n],RefDst,0,1.3,1,xag_.SndMsh[n]);
			xac_.ObjAdr[n].add(xag_.SndMsh[n]);
		});
	}
	// The Next 3 Sounds Are All the Same (for now)
	//
	// XP End Explosion
	for (let n = 0; n < aaf_.ObjNum; n ++) {
		xac_.SndPtr[n] = new THREE.PositionalAudio(listener);
		audoLoader.load(xac_.SndSrc,function(buffer) {
			xac_.SndPtr[n].setBuffer(buffer);
			init1Sound(xac_.SndPtr[n],RefDst,0,1,0,xac_.SndMsh[n]);
			xac_.ObjAdr[n].add(xac_.SndMsh[n]);
		});
	}
	// Load AAA Sounds .........................................................
	// XS Guns - End Explosion
	for (let n = 0; n < xsg_.ObjNum; n ++) {
		xsg_.SndPtr[n] = new THREE.PositionalAudio(listener);
		audoLoader.load(xsg_.SndSrc,function(buffer) {
			xsg_.SndPtr[n].setBuffer(buffer);
			init1Sound(xsg_.SndPtr[n],RefDst,0,1,0,xsg_.SndMsh[n]);
			xsg_.SmkPtr[n].add(xsg_.SndMsh[n]);
		});
	}
	// AA Guns - End Explosion
	for (let n = 0; n < aaf_.ObjNum; n ++) {
		aaf_.SndPtr[n] = new THREE.PositionalAudio(listener);
		audoLoader.load(aaf_.SndSrc, function(buffer) {
			aaf_.SndPtr[n].setBuffer(buffer);
			init1Sound(aaf_.SndPtr[n],RefDst,0,1,0,aaf_.SndMsh[n]);
			aaf_.SmkPtr[n].add(aaf_.SndMsh[n]);
		});	
	}
	//- Set Flag
	LodSnd = 1;
}

//- Change All Sounds ----------//----------------------------------------------
function moveSounds() {
	//- My Airplane ............................................................
	//-	Engine Running
	mys_.EngSnd.setVolume(mys_.EngVol + air_.PwrPct * 0.05); // Range = .1 to .2
	mys_.EngSnd.setPlaybackRate(1 + air_.PwrPct * 0.5); // Range = 1 to 1.5
	//-	Prop Spinning
	mys_.PrpSnd.setVolume(mys_.PrpVol + air_.PwrPct * 0.15); // Range = .1 to .4
	mys_.PrpSnd.setPlaybackRate(1 + air_.PwrPct * 0.5); // Range = 1 to 1.5
	//-	Guns Firing (Left and Rite)
	for (let n = 0; n < myg_.ObjNum; n ++) {myg_.SndPtr[n].setVolume(myg_.SndVol);}
	//- XAC ....................................................................
	for (let n = 0; n < xac_.ObjNum; n ++) {xac_.EngPtr[n].setVolume(xac_.EngVol[n]);} // Endinge
	for (let n = 0; n < xag_.ObjNum; n ++) {xag_.SndPtr[n].setVolume(xag_.SndVol[n]);} // Gun
	//-	Ending Explosions ......................................................
	for (let n = 0; n < xac_.ObjNum; n ++) {xac_.SndPtr[n].setVolume(xac_.SndVol);} // XAC
	for (let n = 0; n < xsg_.ObjNum; n ++) {xsg_.SndPtr[n].setVolume(xsg_.SndVol);} // XAS
	for (let n = 0; n < aaf_.ObjNum; n ++) {aaf_.SndPtr[n].setVolume(aaf_.SndVol);} // AAA
}

//- Play All Sounds ------------//----------------------------------------------
function playSounds() {
	// This leaves SndFlg = 1 and MYGFlg unchanged.
	//- My Airplane ............................................................
	if (!mys_.EngSnd.isPlaying) mys_.EngSnd.play(); // Engine
	if (!mys_.PrpSnd.isPlaying) mys_.PrpSnd.play(); // Prop
	for (let n = 0; n < myg_.ObjNum; n ++) {if (MYGFlg && !myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].play();} // Guns (L/R)
	//- XAC ....................................................................
	for (let n = 0; n < xac_.ObjNum; n ++) {if (!xac_.EngPtr[n].isPlaying) xac_.EngPtr[n].play();} // Engine
//	for (let n = 0; n < xag_.ObjNum; n ++) {if (!xag_.SndPtr[n].isPlaying) xag_.SndPtr[n].play();} // ### FIX THIS - only when firing}
	//- Ending Explosions Activated Elsewhere (XAC,XAG,AAF)
}

//- Stop All Sounds ------------//----------------------------------------------
function stopSounds() {
	// This leaves SndFlg = 0 and MYGFlg unchanged.
	//- My Airplane ............................................................
	if (mys_.EngSnd.isPlaying) mys_.EngSnd.stop(); // Engine
	if (mys_.PrpSnd.isPlaying) mys_.PrpSnd.stop(); // Prop
	for (let n = 0; n < myg_.ObjNum; n ++) {if (myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].stop();} // Guns (L/R)
	//- XAC ....................................................................
	for (let n = 0; n < xac_.ObjNum; n ++) {if (xac_.EngPtr[n].isPlaying) xac_.EngPtr[n].stop();} // Engine
	for (let n = 0; n < xag_.ObjNum; n ++) {if (xag_.SndPtr[n].isPlaying) xag_.SndPtr[n].stop();} // Guns
	//-	End Explosions
	for (let n = 0; n < xac_.ObjNum; n ++) {if (xac_.SndPtr[n].isPlaying) xac_.SndPtr[n].stop();} // XAC
	for (let n = 0; n < xsg_.ObjNum; n ++) {if (xsg_.SndPtr[n].isPlaying) xsg_.SndPtr[n].stop();}
	for (let n = 0; n < aaf_.ObjNum; n ++) {if (aaf_.SndPtr[n].isPlaying) aaf_.SndPtr[n].stop();}
}

//= RADIO SOUNDS ===============//==============================================

//-	Load Radio Sounds ----------//----------------------------------------------
function loadRadios() {	
	//-	Static
	rad_.SndAdr[0] = new THREE.Audio(listener);	
	audoLoader.load(rad_.SndSrc[0],function(buffer) {
		rad_.SndAdr[0].setBuffer(buffer);
		initASound(rad_.SndAdr[0],1.0,1);
	});
	//-	Radio
	rad_.SndAdr[1] = new THREE.Audio(listener);	
	audoLoader.load(rad_.SndSrc[1],function(buffer) {
		rad_.SndAdr[1].setBuffer(buffer);
		initASound(rad_.SndAdr[1],0.7,1.05);
	});
}

//- Start Radio Sequence -------//----------------------------------------------
function strtRadSeq() {
	rad_.SeqTim = 1;			// Start timer when leave ground
	rad_.SegPtr = 0;			// Restart Event Pointer
}

//- Continue Radio Sequence ----//----------------------------------------------
function contRadSeq() {
	rad_.SeqTim = rad_.SeqTim + difTim; // Once started, keep updating
	if (rad_.SeqTim > rad_.SegBeg[rad_.SegPtr]) { // If Arrived at Target Time
		playRadSeg(rad_.SegSel[rad_.SegPtr]); // Play This Segment
		rad_.SegPtr++;			// Go to next segment in list
		if (rad_.SegPtr == rad_.SegNum) rad_.SeqDun = 1; // If Done with Sequence
	}
}

//-	Play Radio Segment ---------//----------------------------------------------
function playRadSeg(n) {
	// SegIdx 0 = "Over Island"; SegIdx 1 = "Help"; SegIdx 2 = "Thanks"
	rad_.SegIdx = n;
	if (SndFlg) {
		// Static
		if (!rad_.SndAdr[0].isPlaying) {
			rad_.SndAdr[0].offset = rad_.SegSta[rad_.SegIdx];
			rad_.SndAdr[0].play();
			rad_.SndAdr[0].stop(rad_.SegEnd[rad_.SegIdx]);
		}
		// Radio
		if (!rad_.SndAdr[1].isPlaying) {
			rad_.SndAdr[1].offset = rad_.SegOff[rad_.SegIdx];
			rad_.SndAdr[1].play();
			rad_.SndAdr[1].stop(rad_.SegEnd[rad_.SegIdx]);
		}
	}
}

//- INIT 1 SOUND ---------------//----------------------------------------------

//- Positional Audio
function init1Sound(dest,dist,volm,rate,loop,link) {
	dest.setRefDistance(dist);	// Position
	dest.setVolume(volm);
	dest.playbackRate = rate;
	if (loop) dest.setLoop(true);
	link.add(dest);
}

//- Positional Audio
function init2Sound(dest,dist,volm,rate,loop) {
	dest.setRefDistance(dist);	// Position
	dest.setVolume(volm);
	dest.playbackRate = rate;
	if (loop) dest.setLoop(true);
}

//- Audio
function initASound(dest,volm,rate) {
	dest.setVolume(volm);
	dest.playbackRate = rate;
}

//= 7. CAMERA ==================//==============================================

//- Init Camera View -----------//----------------------------------------------
function initCamera(camera,cam_) {
	camera.position.z = -cam_.CamLLD.z;
	camera.rotation.y = cam_.CamAdj*DegRad;
	cam_.MshRot.add(camera);	// Attach to rotator
	//
	if (!cam_.CamSel) {			// 0 = Outside View
		sunLight.shadow.mapSize.set(2048,2048);
		sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
		sunLight.shadow.camera.updateProjectionMatrix();
		mxr_.Adr.visible = true;
		vxr_.Adr.visible = false;
		// Flaps
		if (mxr_.FlL) mxr_.FlL.setTime(anm_.flppos/anm_.anmfps);
		if (mxr_.FlR) mxr_.FlR.setTime(anm_.flppos/anm_.anmfps);
		// Gear
		if (mxr_.WHL) mxr_.WHL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WHR) mxr_.WHR.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WBL) mxr_.WBL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WBR) mxr_.WBR.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WTL) mxr_.WTL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WTR) mxr_.WTR.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WSL) mxr_.WSL.setTime(anm_.lngpos/anm_.anmfps);
		if (mxr_.WSR) mxr_.WSR.setTime(anm_.lngpos/anm_.anmfps);
		// Canopy
		if (mxr_.Cnp) mxr_.Cnp.setTime(anm_.canpos/anm_.anmfps);
		// Tailhook
		if (mxr_.THk) mxr_.THk.setTime(anm_.thkpos/anm_.anmfps);
	}	
	if (cam_.CamSel) {			// 1 = Cockpit View
		sunLight.shadow.mapSize.set(8192,8192);
		sunLight.shadow.camera.far = SunDst+2*ShdBox;
		sunLight.shadow.camera.updateProjectionMatrix();
		mxr_.Adr.visible = false;
		vxr_.Adr.visible = true;
		// Canopy
		if (mxr_.Cnp) mxr_.Cnp.setTime(anm_.canpos/anm_.anmfps);
	}
	// Common Changes
	cam_.CamLLD.copy(CamLLD[cam_.CamSel]);	// Restore Saved Values
	cam_.CamMMD.copy(CamMMD[cam_.CamSel]);	// In/Out - min, max, spd
	cam_.CamAdj = CamAdj[cam_.CamSel];		// Load Adjustment
	camera.rotation.y = cam_.CamAdj*DegRad;	// 180 = Looking in
	cam_.CamMMR.copy(CamMMR[cam_.CamSel]);	// Rotation min, max, spd
	cam_.CamPar = CamPar[cam_.CamSel]		// Load New Parent
	cam_.CamPar.add(cam_.MshRot);			// Attach Rotators
	cam_.CamFlg = CamFlg[cam_.CamSel];		// 1 = cockpit
	cam_.CamLnk = CamLnk[cam_.CamSel];		// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);
}

//- Move Camera View -----------//----------------------------------------------
function moveCamera(camera,cam_) {
	if (cam_.VewRot) {			// Beginning Head Rotation
		// Zero Out When Moving Forward
		if (air_.PwrPct) {		// Throttle is trigger
			cam_.VewRot = 0.95*cam_.VewRot;
			if (Math.abs(cam_.VewRot < 0.1)) cam_.VewRot = 0;
		}
	}
	// Camera In/Out
	camera.position.z = -cam_.CamLLD.z;
	// PointerLockControls
	if (cam_.OrbFlg) {			// If Orbiting
		cam_.CamLLD.x = cam_.CamLLD.x - InpMos.y * cam_.CamMMR.z; // Camera Position (Lat)
		cam_.CamLLD.x = MaxVal(cam_.CamLLD.x,cam_.CamMMR.x);
		cam_.CamLLD.y = Mod360(cam_.CamLLD.y + InpMos.x * cam_.CamMMR.z); // Camera Position (Lon)
		// Cockpit View
		if (cam_.CamFlg) {		// Range: 250 to 360/0 to 110
			if (cam_.CamLLD.y > 180 && cam_.CamLLD.y < (360-cam_.CamMMR.y)) cam_.CamLLD.y = (360-cam_.CamMMR.y);
			if (cam_.CamLLD.y < 180 && cam_.CamLLD.y > cam_.CamMMR.y) cam_.CamLLD.y = cam_.CamMMR.y;
		}
		// Outside View
		else {
			if (air_.GrdFlg && cam_.CamLLD.x > -12.5) cam_.CamLLD.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// View Keys (NumLock)
	else {						// If Not Orbiting
		// Cockpit View
		if (cam_.CamFlg) {
			// Use Default View if No View Keys Set
			if (!U45flg && !D45flg && !L45flg && !R45flg && !L90flg && !R90flg && !LBkflg && !RBkflg) {
				cam_.CamLLD.x = 0;
				cam_.CamLLD.y = cam_.VewRot;
			}
			// View Keys
			else {
				cam_.CamLLD.y = cam_.VewRot;
				if (U45flg) cam_.CamLLD.x = 315;
				if (D45flg) cam_.CamLLD.x = 45;
				if (L45flg) cam_.CamLLD.y = Mod360(315+cam_.CamLLD.y);	// Look Left 45
				if (R45flg) cam_.CamLLD.y = Mod360(45+cam_.CamLLD.y);		// Look Right 45
				if (L90flg) cam_.CamLLD.y = Mod360(270+cam_.CamLLD.y);	// Look Left 90
				if (R90flg) cam_.CamLLD.y = Mod360(90+cam_.CamLLD.y);		// Look Right 90  (temp fix)			
				if (LBkflg) cam_.CamLLD.y = Mod360(225+cam_.CamLLD.y);	// Look Left 135
				if (RBkflg) cam_.CamLLD.y = Mod360(135+cam_.CamLLD.y);	// Look Right 135 (temp fix)
			}
		}
		// Outside View
		else {
			// Use Default View if No View Keys Set
			if (!U45flg && !D45flg && !L45flg && !R45flg && !L90flg && !R90flg && !LBkflg && !RBkflg && !CBkflg) {
				cam_.CamLLD.x = -15;
				cam_.CamLLD.y = 0;
			}
			// View Keys
			if (U45flg) cam_.CamLLD.x = 315;
			if (D45flg && air_.MapPos.y>50) cam_.CamLLD.x = 45;
			if (L45flg) cam_.CamLLD.y = 315;	// Look Left 45
			if (R45flg) cam_.CamLLD.y = 45;		// Look Right 45
			if (L90flg) cam_.CamLLD.y = 270;	// Look Left 90
			if (R90flg) cam_.CamLLD.y = 90;		// Look Right 90
			if (LBkflg) cam_.CamLLD.y = 225;	// Look Left 135
			if (RBkflg) cam_.CamLLD.y = 135;	// Look Right 135
			if (CBkflg) cam_.CamLLD.y = 180;	// Look Back			
		}
	}
	// Adjust Camera Rotators
	// In Cockpit View, the camera is facing out - view matches rotation
	if (cam_.CamFlg) {
		cam_.MshRot.rotation.x = Mod360(cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(-cam_.CamLLD.y)*DegRad;
	}
	// In Outside View, the camera is facing in and the armature is pointing out:
	if (!cam_.CamFlg) {
		if (!cam_.OrbFlg && air_.GrdFlg) { // Air to Ground
			if (!CmGrdF) {		// if just landed
				CmLagX = CmAdjX; // All landings are smooth
//				if (CmLagX > 0.5) CmLagX = 0.5; // Make extreme landings more jarring
				CmGrdF = 1;
			}
			CmAdjX = CmLagX;	// From Landing Value to 0
		}	
		if (!cam_.OrbFlg && !air_.GrdFlg) { // Ground to Air
			if (CmGrdF) {		// if just took off
				CmLagX = CmMulX*air_.RotDif.x;
				CmGrdF = 0;
			}
			CmAdjX = (CmMulX*air_.RotDif.x)-CmLagX; // From 0 to Take-Off Value
		}
		if (CmLagX) {			// Reduce Lag
			CmLagX = 0.99*CmLagX; // Reduction in Adj/AdjOff
			if (Math.abs(CmLagX) < 0.1) CmLagX = 0;
		}
		camera.rotation.x = CmAdjX*DegRad; // + = up/airplane down
		cam_.MshRot.rotation.x = Mod360(-cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(180-cam_.CamLLD.y)*DegRad;
	}
}

//= 8. OUTPUTS =================//==============================================

//-	Print HUD Values -----------//----------------------------------------------
function prntHUDval() {
	Air_Pwr = air_.PwrPct;		// Throttle
	Air_PwrNode.nodeValue = Air_Pwr.toFixed(2);
	Air_Spd = air_.SpdKPH*Km2Mil; // Speed
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Alt = air_.MapPos.y*Mtr2Ft; // Altitude
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);
	Air_Hdg = air_.AirRot.y;	// Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
	Air_CfL = air_.CfLift;		// Cf Lift
	Air_CfLNode.nodeValue = Air_CfL.toFixed(4);
	Air_GFm = air_.GFmult*10;	// G-Force Multiplier
	Air_GFmNode.nodeValue = Air_GFm.toFixed(2);
}

//-	Pause Text -----------------//----------------------------------------------
function PawsText(){
	if (PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//-	Autopilot Text -------------//----------------------------------------------
function AutoText(){
	if (air_.AutoOn) Air_AtPNode.nodeValue = "Autopilot On";
	else {Air_AtPNode.nodeValue = "AutoP: Press A";}
}

//- Info Text ------------------//----------------------------------------------
let InfoData = [
		[	"Info : Press I","","","","","","","","",""],
		[	"",
			"CONTROLS",
			"Mouse changes Pitch/Bank and Yaw (bottons)",
			"AutoPilot: Arrow Key change Pitch and Bank",
			"Mouse Wheel or -/= Keys change Throttle",
			"G Key toggles landing gear",
			"F Key toggles flaps",
			"S Key toggles sound",
			"Spacebar fires guns"],
		[	"",
			"VIEW KEYS",
			"V Key toggles views",
			"Shift Key and Mouse orbits around airplane",
			"END Key looks down",
			"DELETE or PAGE DOWN Keys look left/right",
			"HOME Key and above Keys look up",
			"END Key and DELETE or PAGE DOWN Keys look back",
			"All 3 Keys look back"]
	];

function InfoText() {
	if (!InfoOn) onInfo(0);
	else if (InfoOn == 1) onInfo(1);
	else if (InfoOn == 2) onInfo(2);
}

//	Info Off
function onInfo(n){
	On_Inf0Node.nodeValue = InfoData[n][0];
	On_Inf1Node.nodeValue = InfoData[n][1];
	On_Inf2Node.nodeValue = InfoData[n][2];
	On_Inf3Node.nodeValue = InfoData[n][3];
	On_Inf4Node.nodeValue = InfoData[n][4];
	On_Inf5Node.nodeValue = InfoData[n][5];
	On_Inf6Node.nodeValue = InfoData[n][6];
	On_Inf7Node.nodeValue = InfoData[n][7];
	On_Inf8Node.nodeValue = InfoData[n][8];
	On_Inf9Node.nodeValue = InfoData[n][9];
}

//= 9. INPUTS ==================//==============================================
// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//- MOUSE ----------------------//----------------------------------------------

//- Mouse Buttons (Down) -------//----------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		air_.RotDif.y = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		air_.RotDif.y = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------//----------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		air_.RotDif.y = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		air_.RotDif.y = 0;
	}
}

//- Mousewheel -----------------//----------------------------------------------
function onDocumentMouseWheel(event) {
	event.preventDefault();
	PwrDif = - event.deltaY * PwrMul; // Increment = 1%
}

//- KEYBOARD -------------------//----------------------------------------------

//- Keyboard (Down) ------------//----------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_PwLU) PwrDif = 0.1;		// Power Up - keyboard left
	if (event.keyCode == K_PwLD) PwrDif = -0.1;		// Power Down - keyboard left
	if (event.keyCode == K_PwRU) PwrDif = 0.1;		// Power Up - keyboard right
	if (event.keyCode == K_PwRD) PwrDif = -0.1;		// Power Down - keyboard right
	if (event.keyCode == K_BnkL) air_.InpKey.z = -KeyVal.z;	// Bank Left - autopilot only
	if (event.keyCode == K_BnkR) air_.InpKey.z = KeyVal.z;	// Bank Right - autopilot only
	if (event.keyCode == K_PitU) air_.InpKey.x = KeyVal.x;	// Pitch Up - autopilot only
	if (event.keyCode == K_PitD) air_.InpKey.x = -KeyVal.x;	// Pitch Down - autopilot only
	if (event.keyCode == K_YwLL) air_.RotDif.y = -KeyVal.z; // YawL - keyboard left
	if (event.keyCode == K_YwLR) air_.RotDif.y = KeyVal.z;  // YawR - keyboard left
	if (event.keyCode == K_YwRL) air_.RotDif.y = -KeyVal.z; // YawL - keyboard right
	if (event.keyCode == K_YwRR) air_.RotDif.y = KeyVal.z;  // YawR - keyboard right
	if (event.keyCode == K_Brak) InpBrk = 0.01;		// Brakes
	// Additional
	if (event.keyCode == K_Gear) anm_.lngflg = 1; 	// Gear
	if (event.keyCode == K_Flap) anm_.flpflg = 1; 	// Flaps
	if (event.keyCode == K_Canp) anm_.canflg = 1; 	// Canopy
	if (event.keyCode == K_Hook) anm_.thkflg = 1; 	// Tailhook
	// Views
	if (event.keyCode == K_Look) cam_.OrbFlg = 1;	// Orbit View
	if (event.keyCode == K_VU45) D45flg = 1;		// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 1;		// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 1;		// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 1;		// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 1;		// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 1;		// View - 90 deg right
	if (event.keyCode == K_VLBk) LBkflg = 1;		// View - 135 deg left
	if (event.keyCode == K_VRBk) RBkflg = 1;		// View - 135 deg right
	if (event.keyCode == K_VCBk) CBkflg = 1;		// View - 180 deg back
	// Guns
	if (event.keyCode == K_Guns) { // Guns
		if (!PawsOn) {
			for (let n = 0; n < myg_.ObjNum; n ++) {
				if (SndFlg && !myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].play();
			}
		};
		MYGFlg = 1;
	}
	// Reset
	if (event.keyCode == K_RSet) posnRSet();		// Do Reset	
	// Toggle
	if (event.keyCode == K_Paws) toglPaws();		// Toggle Pause
	if (event.keyCode == K_Auto) toglAuto();		// Toggle AutoPilot
	if (event.keyCode == K_Info) toglInfo();		// Toggle Information
	if (event.keyCode == K_View) toglView();		// Switch View
	if (event.keyCode == K_Soun) toglSoun();		// Toggle Sound
}

//-	Keyboard (Up) --------------//----------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_PwLU) PwrDif = 0;		// Power Up - keyboard left
	if (event.keyCode == K_PwLD) PwrDif = 0;		// Power Down - keyboard left
	if (event.keyCode == K_PwRU) PwrDif = 0;		// Power Up - keyboard right
	if (event.keyCode == K_PwRD) PwrDif = 0;		// Power Down - keyboard right
	if (event.keyCode == K_BnkL) air_.InpKey.z = 0;	// Bank Left - autopilot only
	if (event.keyCode == K_BnkR) air_.InpKey.z = 0;	// Bank Right - autopilot only
	if (event.keyCode == K_PitU) air_.InpKey.x = 0;	// Pitch Up - autopilot only
	if (event.keyCode == K_PitD) air_.InpKey.x = 0;	// Pitch Down - autopilot only
	if (event.keyCode == K_YwLL) air_.RotDif.y = 0;	// YawL - keyboard left
	if (event.keyCode == K_YwLR) air_.RotDif.y = 0;	// YawR - keyboard left
	if (event.keyCode == K_YwRL) air_.RotDif.y = 0;	// YawL - keyboard right
	if (event.keyCode == K_YwRR) air_.RotDif.y = 0;	// YawR - keyboard right
	if (event.keyCode == K_Brak) InpBrk = 0;		// Brakes
	// Additional
	if (event.keyCode == K_Gear) anm_.lngflg = 0;	// Gear
	if (event.keyCode == K_Flap) anm_.flpflg = 0;	// Flaps
	if (event.keyCode == K_Canp) anm_.canflg = 0;	// Canopy
	if (event.keyCode == K_Hook) anm_.thkflg = 0;	// Taihook
	// Views
	if (event.keyCode == K_Look) cam_.OrbFlg = 0;	// Orbit View
	if (event.keyCode == K_VU45) D45flg = 0;		// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 0;		// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 0;		// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 0;		// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 0;		// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 0;		// View - 90 deg right
	if (event.keyCode == K_VLBk) LBkflg = 0;		// View - 135 deg left
	if (event.keyCode == K_VRBk) RBkflg = 0;		// View - 135 deg right
	if (event.keyCode == K_VCBk) CBkflg = 0;		// View - 180 deg back
	// Guns
	if (event.keyCode == K_Guns) {					// Guns
		for (let n = 0; n < myg_.ObjNum; n ++) {
			myg_.SndPtr[n].stop();
		}
		if (!PawsOn) {
			for (let n = 0; n < myg_.ObjNum; n ++) {
				if (myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].stop();
			}
		};
		MYGFlg = 0;
	}
}

//- Reset Position -------------//----------------------------------------------
function posnRSet() {
	// CVE
	air_.MovFlg = 1; // Flag
	air_.PwrPct = 0;
	air_.SpdKPH = 0;
	air_.SpdMPS = 0;
	air_.SpdMPF = 0;
	xsh_.ShpLok[0].add(air_.AirObj);
}

//- Subroutines ----------------//----------------------------------------------

//. Toggle Pause ...............//..............................................
function toglPaws() {
	PawsOn = 1 - PawsOn;
	if (PawsOn && SndFlg) {		//On to Off
		stopSounds();
	}
	if (!PawsOn && SndFlg) {	// Off to On
		playSounds();
	}
	PawsText();
}

//. Toggle AutoPilot ...........//..............................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................//..............................................
function toglInfo() {
	InfoOn++
	if (InfoOn == 3) InfoOn = 0;
	InfoText();
}

//. Toggle Camera View (3-Way) -//----------------------------------------------
function toglView() {
	// Old CamSel
	cam_.CamPar.remove(cam_.MshRot);		// Unlink Old Parent
	CamLLD[cam_.CamSel].copy(cam_.CamLLD);	// Save lld
	// New CamSel
	cam_.CamSel++
	if (cam_.CamSel == cam_.CamNum) cam_.CamSel = 0;
	initCamera(camera,cam_)
}

//. Toggle Sound ...............//..............................................
function toglSoun() {
	if (!PawsOn) {
		SndFlg = 1 - SndFlg;
		if (SndFlg) {			// Off to On
			playSounds();
		}
		else {					// On to Off
			stopSounds();
		}
	}
}

//= WINDOW RESIZE ==============//==============================================
function onWindowResize() {
	CamAsp = window.innerWidth/window.innerHeight;
	camera.aspect = CamAsp;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>