<!doctype html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 21 Jun 2025

This program demonstrates a couple of Moving Map Grid subroutines, including:
* loadGrdMap
* moveGrdMap

The subroutines can be used to draw single Grids or nested Grids.

-->

<head>
<title>ACM Demo - Intercept</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="stylesheet" href="styles/main_ACM.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>AIR COMBAT MANEUVERING (ACM)</div>
	</div>
	<div class="overlay2">
		<div>..................Air1</div>
		<div>Altitude....(ft): <span id="AC1_Alt"></span></div>
		<div>Speed......(mph): <span id="AC1_Spd"></span></div>
		<div>Heading....(deg): <span id="AC1_Hdg"></span></div>
		<div>Pitch......(deg): <span id="AC1_Pit"></span></div>
		<div>Bank.......(deg): <span id="AC1_Bnk"></span></div>
		<div>Turn Rate..(deg): <span id="AC1_Trn"></span></div>
		<div>Angle of Attack : <span id="AC1_AoA"></span></div>
	</div>
	<div class="overlay3">
		<div>Air2</div>
		<div><span id="AC2_Alt"></span></div>
		<div><span id="AC2_Spd"></span></div>
		<div><span id="AC2_Hdg"></span></div>
		<div><span id="AC2_Pit"></span></div>
		<div><span id="AC2_Bnk"></span></div>
		<div><span id="AC2_Trn"></span></div>
		<div><span id="AC2_AoA"></span></div>
	</div>	
	<div class="overlay4">
		<div>Press Arrow Keys to Pitch and Bank Airplane</div>
		<div>Press Z or X to Yaw Left or Right</div>
		<div>Press P to Pause</div>
		<div>Press V to Change Camera View</div>		
	</div>
</div>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.177/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.177/examples/jsm/"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import Stats from "three/addons/libs/stats.module.js";

//= Start ======================================================================
// Note: Since three.js uses meters, compute Speed and Altitude in Meters
// But can display speed in MPH and altitude in feet 
// Altitude: 10,000 meters = 32,800 feet
// Grid 4 Square Size: 1.0 miles = 1609.33 meters (basic building block)
// Grid 5 Square Size: 3.0 miles.  Viz = 3.0 X 13.5 = 40.5 miles = 65km

//= Lag Type ===================//==============================================
let LagTyp = 2;					// 0 = No Lag, 1 = Lag, 2 = Intercept
let BegLag = new THREE.Vector3(-100,0,150); // Offset: x = horizontal, y = vertical, z = distance behind
let BegOff = new THREE.Vector3(0,0,0); // Off Angle: x = vertical, y = horizontal

//= Starting Values ============//==============================================
let BegAlt = 3048;				// Aircraft Altitude (m) = 10000 ft
let BegSpd = 482.8;				// Aircraft Speed = 300 mph
let BegPwr = 1.0;				//
let BegRot = new THREE.Vector3(0,0,0); // Beg Pitch, Heading, Bank Angles
let BegCfL = 0.265;				// Level Flight

//= Variables ==================//==============================================
//	Inputs
let InpSpd = 0;					// Aircraft Speed Change (mph)
//- Flags
let	PanFlg = 0;					// Camera Panning
let PawsOn = 0;					// Pause
let StsFlg = 1;					// Stats ((0 = off, 1 = on)

//= Constants ==================//==============================================
let DLTime = 1/60;				// Frames per Second
//- Math Predefined
let	PieVal = Math.PI;			// PI
let	DegRad = PieVal/180;		// Convert Degrees to Radians
let	RadDeg = 180/PieVal;		// Convert Radians to Degrees
let Mtr2Ft = 3.28084;			// Meters to Feet
let Ft2Mtr = .3048;				// Feet to Meters
let MPHMPS = .44704;			// MPH to meters per second
let Km2Mil = 0.621371;			// Kilometers to Miles
//- Sky
let SkyLim = 50000;				// Max viewing distance (meters)
let SkyCol = 0xa9e5ff;			// Color of Sky
//- Flight
let GrvUPS = 9.80665;			// Gravity (m/s2)
let	AirDen = 1.225;				// Density (Sea Level Value) (kg/m3)
let quaternion = new THREE.Quaternion();

//= Basic Values ===============================================================
// Display
let	scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
let	renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.outputColorSpace = THREE.SRGBColorSpace;	// ### r152
	document.body.appendChild(renderer.domElement);
// Lights
const AmbLight = new THREE.AmbientLight(0xffffff, 1.0);
	scene.add(AmbLight);
// Camera
let	camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, SkyLim);
// Inputs
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	renderer.domElement.addEventListener("mousedown", onMouseDown, false);
	renderer.domElement.addEventListener("mouseup", onMouseUp, false);
	renderer.domElement.addEventListener("mousemove", onMouseMove, false);
	renderer.domElement.addEventListener('mousewheel', onMouseWheel, {capture: false, passive: false});
	window.addEventListener("resize", onWindowResize, false);

//= Ground Squares =============//==============================================
// Layer 1 constains smaller higher definition squares
// Layer 2 contains larger lower definition squares (3X size of Layer 1 squares)
let GrdSiz = 1609.33;			// 1 Mile (1609.33m)
//= Both Grids -----------------------------------------------------------------
// Used to Position Map
let Grd0 = {
		MSZ:	0,				// Map NSSpd (updated by program)
		MSX:	0,				// Map EWSpd (updated by program)
		MPY:	0				// Map UpPos = Aircraft Altitude (updated by program)
	}
//= Grid 4 ---------------------------------------------------------------------
let Grd4 = {
		Typ:	4,				// Type of Grid - Inner or Outer
		RCs:	27,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	GrdSiz,			// Size of square
		Stp:	3,				// Steps
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		RCF:	0,				// N/A
		NSA:	0,				// Shared North/South Adjustment (updated)
		EWA:	0,				// Shared East/West Adjustment (updated)
		Mat:	0				// Match Material of Outer and Inner Blocks
	}
//= Grid 5 ---------------------------------------------------------------------
let Grd5 = {
		Typ:	5,				// Type of Grid - Inner or Outer
		RCs:	27,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	Grd4.Siz*Grd4.Stp, // Size of square
		Stp:	3,				// Steps
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		RCF:	Grd4.RCs/Grd4.Stp, // Cut-Out Area (27/3 = 9)
		NSA:	0,				// Shared North/South Adjustment (updated)
		EWA:	0,				// Shared East/West Adjustment (updated)
		Mat:	0				// Match Material of Outer and Inner Blocks
	}

//= Aircraft ===================//==============================================
let Air1 = {
		// Inputs
		InpRot: new THREE.Vector3(0,0,0), // Input
		CfLift: BegCfL,			// Coefficient of Lift
		PwrPct: BegPwr,			// % of Max Power (0 to 1)
		// Changes to Airplane Pitch Bank and Yaw
		AirRSp: new THREE.Vector3(0,0,0),
		// Airplane Rotation
		AirRot: new THREE.Vector3().copy(BegRot), // Rotation
		AirPBY: new THREE.Object3D(),
		AirObj: new THREE.Object3D(),
		HdgDif: 0,				// Heading Change in Turn
		// Airplane Speed
		SpdKPH: BegSpd,			// Speed in KPH
		SpdMPS: BegSpd/3.6,
		SpdMPF: (BegSpd/3.6)*DLTime,
		// Airplane Map Speed and Position
		MapSpd: new THREE.Vector3(0,0,0), // Map Speed
		MapPos: new THREE.Vector3(0,BegAlt,0), // Map Position
		// Model
		Color1: 0x00007f,		// Primary Color
		Color2: 0x7f7fff,		// Secondary Color
		// Smoke
		SmkObj: 0,				// Smoke Object
		SmkPts: [],				// Position Array
		SmkTim: [],				// Smoke
	}
let Air2 = {
		// Inputs
		InpRot: new THREE.Vector3(0,0,0), // Input
		CfLift: BegCfL,			// Coefficient of Lift
		PwrPct: BegPwr,			// % of Max Power (0 to 1)
		// Changes to Airplane Pitch Bank and Yaw
		AirRSp: new THREE.Vector3(0,0,0),
		// Airplane Rotation
		AirRot: new THREE.Vector3(BegRot.x+BegOff.x,BegRot.y+BegOff.y,BegRot.z+BegOff.z),
		AirPBY: new THREE.Object3D(),
		AirObj: new THREE.Object3D(),
		HdgDif: 0,				// Heading Change in Turn
		// Airplane Speed
		SpdKPH: BegSpd,			// Spped in KPH
		SpdMPS: BegSpd/3.6,
		SpdMPF: (BegSpd/3.6)*DLTime,
		// Airplane Map Speed and Position
		MapSpd: new THREE.Vector3(0,0,0), // Map Speed
		MapPos: new THREE.Vector3(BegLag.x,BegAlt+BegLag.y,BegLag.z), // Map Position (same as mine)
		// Model
		Color1: 0x7f0000,		// Primary Color
		Color2: 0xff7f7f,		// Secondary Color
		// Smoke
		SmkObj: 0,				// Smoke Object
		SmkPts: [],				// Position Array
		SmkTim: [],				// Smoke
	}
//- Aircraft Data --------------------------------------------------------------
//	Constrol Sensitivity
let	MxBnkR = 1;					// Maximum bank rate
let	BnkMul = MxBnkR/1000;		// Standard bank multiplier
let	MxPitR = 1;					// Maximum pitch rate
let	PitMul = MxPitR/250;		// Standard pitch multiplier
//	Basic Aircraft Data
let JetMax = 0;					// Jet Only - Maximum Power
let	PwrMax = 1007;				// Prop Only - Maximum Power (Kw)
let	PropEf = 0.8;				// Prop Only - Prop Efficiency 
let	Weight = 7500;				// Aircraft Weight (lbs)
let	CfLMax = 1.4;				// Maximum Coefficient of Lift
let	WingSp = 11.58;				// Wing Span (m)
let	WingAr = 24.15;				// Wing Area (m2)
let	WingEf = 0.75;				// Wing Efficiency
let	DrgCd0 = 0.0211;			// Coefficient of Drag
let	GrvMax = 8;					// Maximum G-Force
let	AngInc = 5;					// Angle of Incidence
let	TrmAdj = 2.5;				// Elevator Trim Adjustment
//	Computed Values
let ThrstK = 1000 * PropEf;		// Prop ONly - Constant (prop only)
let ACMass = Weight/GrvUPS;		// Mass (slugs or kg)
let WingAs = WingSp*WingSp/WingAr; // Wing Aspect Ratio
let	ACPMax = CfLMax * 10;		// Max aircraft pitch adjustment (+/- 15)
let	ACPInc = ACPMax - AngInc;	// Net max aircraft pitch adjustment (10)

//- Smoke Trail ----------------------------------------------------------------
let SmkTot = 100;
let SmkInt = 10;
let SmkSiz = 6;

//= Computations ===============//==============================================
//- Lag Pursuit ----------------------------------------------------------------
let LagId1 = 0;					// Index to next Air1 Entry
let LagId2 = 0;					// Index to current Air2
let	LagMax = 360;				// Max Number of Values (360 = 6 seconds of bank changes)
let LagDst = BegLag.z;			// Starting Distance Between Air2 and Air1 (250 feet)
let LagSpd = BegSpd*(1000/3600); // Air1 Speed (meters/sec)
let LagTim = LagDst/LagSpd;		// Time = Difference in Distance/Air1 Speed [250/440 = 0.561818 etc]
//	LagTim = 0.5				// Override - This works better
let LagInp = [0];				// Air1 Rotation Change
//	Cheats? (Fixes Rounding Errors)
let LagRot = [0];				// Air1 Rotation
let LagPos = [0];				// Air1 Position
//- Intercept ------------------------------------------------------------------
let IntAng = new THREE.Vector3(); // Intercept Angle (Pitch,Yaw,Bank)
let IntInp = new THREE.Vector3(); // Intercept Input (Pitch,Yaw,Bank)
let OffAng = new THREE.Vector3(); // Off-Angle

//= CAMERA =====================//==============================================
	camera.rotation.order = "YXZ";
	camera.position.z = -500;	// Starting Disctance for Camera 1
	camera.rotation.y = 180*DegRad; // Default = looking in
let	CamObj = new THREE.Object3D(); // Armature base - use to rotate camera
	CamObj.rotation.order = "YXZ";
	CamObj.add(camera);
let CtrObj = new THREE.Object3D();
	CtrObj.rotation.order = "YXZ";
	CtrObj.add(CamObj);
	scene.add(CtrObj);
//- Camera - Lat/Lon = direction the camera is pointing
let Cam1 = {
		Rot: new THREE.Vector3(-30,10,0), // Lat Lon Bnk
		Pos: new THREE.Vector3(500,750,125),
		Dif: 1,
		Ref: CtrObj,
	}
let Cam2 = {
		Rot: new THREE.Vector3(-30,10,0), // Lat Lon Bnk
		Pos: new THREE.Vector3(100,300,50),
		Dif: 0.25,
		Ref: Air2.AirPBY,
	}
let CamSel = Cam1;
let CamLtX = 90;				// Max lat

//= INPUTS =====================//==============================================
let onPointerDownX, onPointerDownY, onPointerDownLon, onPointerDownLat;
//- Key Values
let K_SpdU = 45;				// Speed Up (insert)
let K_PitD = 38;				// Pitch down (up arrow)
let K_SpdD = 33;				// Speed Up (page up)
let	K_BnkL = 37;				// Bank Left (left arrow)
let	K_BnkR = 39;				// Bank Right (right arrow)
let K_YawL = 46;				// Yaw Left (delete)
let K_PitU = 40;				// Pitch up (down arrow)
let K_YawR = 34;				// Yaw Right (page down)
let K_Paws = 80;				// Pause (p)
let K_View = 86					// View (v)
// -
let BnkSpd = 1;					// Bank Speed
let CfLSpd = 1;					// Pitch Speed

//= HTML OVERLAY TEXT ==========================================================
//- Air1
let AC1_HdgElement = document.getElementById("AC1_Hdg");
let AC1_HdgNode = document.createTextNode("");
	AC1_HdgElement.appendChild(AC1_HdgNode);
let AC1_AltElement = document.getElementById("AC1_Alt");
let AC1_AltNode = document.createTextNode("");
	AC1_AltElement.appendChild(AC1_AltNode);
let AC1_SpdElement = document.getElementById("AC1_Spd");
let AC1_SpdNode = document.createTextNode("");
	AC1_SpdElement.appendChild(AC1_SpdNode);
let AC1_BnkElement = document.getElementById("AC1_Bnk");
let AC1_BnkNode = document.createTextNode("");
	AC1_BnkElement.appendChild(AC1_BnkNode);
let AC1_TrnElement = document.getElementById("AC1_Trn");
let AC1_TrnNode = document.createTextNode("");
	AC1_TrnElement.appendChild(AC1_TrnNode);
let AC1_PitElement = document.getElementById("AC1_Pit");
let AC1_PitNode = document.createTextNode("");
	AC1_PitElement.appendChild(AC1_PitNode);
let AC1_AoAElement = document.getElementById("AC1_AoA");
let AC1_AoANode = document.createTextNode("");
	AC1_AoAElement.appendChild(AC1_AoANode);
let AC1_Alt,AC1_Hdg,AC1_Spd,AC1_Bnk,AC1_Trn,AC1_Pit,AC1_AoA;
//- Air2
let AC2_HdgElement = document.getElementById("AC2_Hdg");
let AC2_HdgNode = document.createTextNode("");
	AC2_HdgElement.appendChild(AC2_HdgNode);
let AC2_AltElement = document.getElementById("AC2_Alt");
let AC2_AltNode = document.createTextNode("");
	AC2_AltElement.appendChild(AC2_AltNode);
let AC2_SpdElement = document.getElementById("AC2_Spd");
let AC2_SpdNode = document.createTextNode("");
	AC2_SpdElement.appendChild(AC2_SpdNode);
let AC2_BnkElement = document.getElementById("AC2_Bnk");
let AC2_BnkNode = document.createTextNode("");
	AC2_BnkElement.appendChild(AC2_BnkNode);
let AC2_TrnElement = document.getElementById("AC2_Trn");
let AC2_TrnNode = document.createTextNode("");
	AC2_TrnElement.appendChild(AC2_TrnNode);
let AC2_PitElement = document.getElementById("AC2_Pit");
let AC2_PitNode = document.createTextNode("");
	AC2_PitElement.appendChild(AC2_PitNode);
let AC2_AoAElement = document.getElementById("AC2_AoA");
let AC2_AoANode = document.createTextNode("");
	AC2_AoAElement.appendChild(AC2_AoANode);
let AC2_Alt,AC2_Hdg,AC2_Spd,AC2_Bnk,AC2_Trn,AC2_Pit,AC2_AoA;

//= Main Program ===============================================================
	initAll();
	rendAll();

//= 1 Initialize ===============//==============================================

function initAll() {
	scene.background = new THREE.Color(SkyCol);
	Grd0.MPY = Air1.MapPos.y*Ft2Mtr;
	initGrdMap();
	initAirPln();
	// Show stats
	if (StsFlg) {				// show stats
		StsFlg = new Stats();
		StsFlg.setMode(0);		// FPS only
		StsFlg.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(StsFlg.dom);
	}
	initCamera();
}

// 2 Render ====================//==============================================

function rendAll() {
	requestAnimationFrame(rendAll);
	if (PawsOn == 0) {
		moveAirPln();
		Grd0.MSZ = Air1.MapSpd.z; // update Grid Data
		Grd0.MSX = Air1.MapSpd.x;
		Grd0.MPY = Air1.MapPos.y;
		moveGrdMap();			// Move Grid Map
		if (StsFlg) StsFlg.update(); // update stats
	}
	chngHUDV(Air1)
	moveCamera();
	renderer.render(scene, camera); // Render
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//*
//*		GRID MAP
//*
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//- Init -----------------------------------------------------------------------
function initGrdMap() {
	init1GrMap(Grd4);
	init1GrMap(Grd5);
}

//- Move -----------------------------------------------------------------------
function moveGrdMap() {
	move1GrMap(Grd4);
	move1GrMap(Grd5);
}

//= INIT MOVING MAP ============//==============================================

function init1GrMap(Grd) {
	// Load Variables
	Grd.RCi = Grd.RCs-1;		// Max Index Value
	Grd.MZV[Grd.RCi] = 0;		// Z-Values
	Grd.MXV[Grd.RCi] = 0;		// X-Values
	Grd.Nor = Grd.RCi;			// Max North Square (updated)
	Grd.Est = Grd.RCi;			// Max East Square (updated)
	Grd.Num = Grd.RCs * Grd.RCs; // Size of array
	Grd.Ptr[Grd.Num-1] = 0;		// Mesh Pointers
	if (Grd.Typ > 4) {
		Grd.NSA = (Grd.RCs-Grd.RCF)/2;	// (27-3=6)
		Grd.EWA = Grd.NSA;
	}
	// Compute Starting Z and X Values
	let zx = -0.5*(Grd.RCs)*Grd.Siz+0.5*Grd.Siz;
	for (let i = 0; i < Grd.RCs; i++) {
		Grd.MZV[i] = zx;
		Grd.MXV[i] = zx;
		zx = zx + Grd.Siz;
	}
	let geometry;
	if (Grd.Typ == 4) geometry = new THREE.PlaneGeometry(Grd.Siz, Grd.Siz,2,2);
	if (Grd.Typ == 5) geometry = new THREE.PlaneGeometry(Grd.Siz, Grd.Siz, 2*Grd4.Stp, 2*Grd4.Stp);
	ToQuads(geometry);
	let material = new THREE.LineBasicMaterial({color: "green"});
	// Set Starting Position of Squares
	let n = 0;
	for (let y = 0; y < Grd.RCs; y++) { // Row
		for (let x = 0; x < Grd.RCs; x++) {	// Column
			Grd.Ptr[n] = new THREE.LineSegments(geometry,material);
			Grd.Ptr[n].material.depthTest = false;
			Grd.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Grd.Ptr[n]);
			Grd.Ptr[n].position.set(Grd.MXV[x],-Grd0.MPY,-Grd.MZV[y]);
			n++;
		}
	}
}

function ToQuads(g) {
  let p = g.parameters;
  let segmentsX = (g.type == "TorusBufferGeometry" ? p.tubularSegments : p.radialSegments) || p.widthSegments || p.thetaSegments || (p.points.length - 1) || 1;
  let segmentsY = (g.type == "TorusBufferGeometry" ? p.radialSegments : p.tubularSegments) || p.heightSegments || p.phiSegments || p.segments || 1;
  let indices = [];
  for (let i = 0; i < segmentsY + 1; i++) {
    let index11 = 0;
    let index12 = 0;
    for (let j = 0; j < segmentsX; j++) {
      index11 = (segmentsX + 1) * i + j;
      index12 = index11 + 1;
      let index21 = index11;
      let index22 = index11 + (segmentsX + 1);
      indices.push(index11, index12);
      if (index22 < ((segmentsX + 1) * (segmentsY + 1) - 1)) {
        indices.push(index21, index22);
      }
    }
    if ((index12 + segmentsX + 1) <= ((segmentsX + 1) * (segmentsY + 1) - 1)) {
      indices.push(index12, index12 + segmentsX + 1);
    }
  }
  g.setIndex(indices);
}

//= MOVE MOVING MAP ============//==============================================

function move1GrMap(Grd) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Grd.RCs*Grd.Siz;
	let min = -max;
	// Update Z, X and Y-Values
	for (let i = 0; i < Grd.RCs; i++) {
		Grd.MZV[i] = Grd.MZV[i] - Grd0.MSZ;	// Rows
		Grd.MXV[i] = Grd.MXV[i] - Grd0.MSX;	// Columns
	}
	Grd.MYV = Grd0.MPY;			// Altitude
	// Test North/South
	if (Grd0.MSZ < 0) {			// If Moving South
		j = Grd.Nor;
		if (Grd.MZV[j] >= max) {
			v = min+(Grd.MZV[j]-max);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Grd.RCi;
				v = v - Grd.Siz;
			}
			Grd.Nor = Grd.Nor - Grd.Stp;
			if (Grd.Nor < 0) Grd.Nor = Grd.Nor + Grd.RCs;
			if (Grd.Typ == 2) Grd.NSA = Grd.NSA + 1;
			else Grd5.NSA = Grd5.NSA - 1;
		}
	}
	if (Grd0.MSZ > 0) {			// If Moving North
		j = Grd.Nor + 1;
		if (j > Grd.RCi) j = 0;
		if (Grd.MZV[j] <= min) {
			v = max-(min-Grd.MZV[j]);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MZV[j] = v;
				j = j + 1;
				if (j > Grd.RCi) j = 0;
				v = v + Grd.Siz;
			}
			Grd.Nor = Grd.Nor + Grd.Stp;
			if (Grd.Nor > Grd.RCi) Grd.Nor = Grd.Nor - Grd.RCs;
			if (Grd.Typ == 2) Grd.NSA = Grd.NSA - 1;
			else Grd5.NSA = Grd5.NSA + 1;
		}
	}
	// Test East/West
	if (Grd0.MSX < 0) {			// If Moving West
		j = Grd.Est;
		if (Grd.MXV[j] >= max) {
			v = min+(Grd.MXV[j]-max);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Grd.RCi;
				v = v - Grd.Siz;
			}
			Grd.Est = Grd.Est - Grd.Stp;
			if (Grd.Est < 0) Grd.Est = Grd.Est + Grd.RCs;
			if (Grd.Typ == 2) Grd.EWA = Grd.EWA + 1;
			else Grd5.EWA = Grd5.EWA - 1;
		}
	}
	if (Grd0.MSX > 0) {			// If Moving East
		j = Grd.Est + 1;
		if (j > Grd.RCi) j = 0;	
		if (Grd.MXV[j] <= min) {
			v = max-(min-Grd.MXV[j]);
			for (let i = 0; i < Grd.Stp; i++) {			
				Grd.MXV[j] = v;
				j = j + 1;
				if (j > Grd.RCi) j = 0;
				v = v + Grd.Siz;
			}
			Grd.Est = Grd.Est + Grd.Stp;
			if (Grd.Est > Grd.RCi) Grd.Est = Grd.Est - Grd.RCs;
			if (Grd.Typ == 2) Grd.EWA = Grd.EWA - 1;
			else Grd5.EWA = Grd5.EWA + 1;
		}
	}
	// Set Position
	let n = 0;
	for (let r = 0; r < Grd.RCs; r++) {	// Row
		for (let c = 0; c < Grd.RCs; c++) {	// Col
			Grd.Ptr[n].position.set(Grd.MXV[c],-Grd.MYV,-Grd.MZV[r]);
			Grd.Ptr[n].visible = true;	// Default for Outer Grid
			n = n + 1;
		}
	}
	// Outer Grid Only - Make Cut-Out Area Invisible
	if (Grd.Typ == 2) {
		let r = Grd.Nor + 1 + Grd.NSA; // Get Lower index
		if (r > Grd.RCi) r = r - Grd.RCs;
		let c = Grd.Est + 1 + Grd.EWA; // Get Left Index
		if (c > Grd.RCi) c = c - Grd.RCs;
		for (let i = 0; i < Grd.RCF; i++) {
			n = r * Grd.RCs + c;
			if (n < 0) n = n + Grd.Num;
			if (n > Grd.Num) n = n - Grd.Num;
			let n2 = (r+1) * Grd.RCs - 1;
			if (n2 > Grd.Num) n2 = n2 - Grd.Num;
			if (n2 < 0) n2 = n2 + Grd.Num;
			for (let j = 0; j < Grd.RCF; j++) {
				Grd.Ptr[n].visible = false;
				n = n + 1;
				if (n > n2) n = n - Grd.RCs; 
				if (n < 0) n = n + Grd.Num;
				if (n > Grd.Num) n = n - Grd.Num;
			}
			r = r + 1;
			if (r > Grd.RCi) r = r - Grd.RCs;
		}
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//*
//*		AIRPLANE
//*
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//	Initialize
function initAirPln() {
	init1ACraft(Air1);
	init1ACraft(Air2);
}

//	Move
function moveAirPln() {
	move1ACraft(Air1);
	move1ACraft(Air2);
}

//= INITIALIZE AIRPLANE ==========//============================================

function init1ACraft(Air) {
	// - Aircraft Mount --------------------------------------------------------
	Air.AirObj.rotation.order = "YXZ";
	scene.add(Air.AirObj);
	Air.AirObj.rotation.z = Mod360(360-Air.AirRot.z) * DegRad;	// Bank
	Air.AirObj.rotation.x = Mod360(Air.AirRot.x) * DegRad;		// Pitch
	Air.AirObj.rotation.y = Mod360(-Air.AirRot.y) * DegRad;		// Heading
	// Aircraft Pitch Bank Yaw
	Air.AirPBY.rotation.order = "YXZ";
	Air.AirObj.add(Air.AirPBY);
	// - Aircraft Object -------------------------------------------------------
	let mshAir, geoAir, matAir;
	// Front
	mshAir = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 2.5, 15, 3, 1, "false"), new THREE.MeshBasicMaterial({color: Air.Color1}));
	mshAir.rotation.x = -PieVal/2;
	mshAir.position.z = -5;
	Air.AirPBY.add(mshAir);
	// Back
	mshAir = new THREE.Mesh(new THREE.CylinderGeometry(.25, 2.5, 25, 3, 1, "false"), new THREE.MeshBasicMaterial({color: Air.Color1}));
	mshAir.rotation.x = PieVal/2;
	mshAir.rotation.y = PieVal;
	mshAir.position.z = 15;
	Air.AirPBY.add(mshAir);
	// Wing
	geoAir = new THREE.BoxGeometry(50,0.25,5).toNonIndexed();
	matAir = new THREE.MeshBasicMaterial({vertexColors: true});
	let colors = [];
	let color = new THREE.Color();
	color.set(Air.Color1);
	for (let i = 0; i < 24; i += 3) {
		if (i >= 18) color.set(Air.Color2);
		colors.push(color.r, color.g, color.b);
		colors.push(color.r, color.g, color.b);
		colors.push(color.r, color.g, color.b);
	}
	geoAir.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
	mshAir = new THREE.Mesh(geoAir,matAir);
	mshAir.position.y = -.5;
	mshAir.position.z = 2.5;
	Air.AirPBY.add(mshAir);
	// HTail
	geoAir = new THREE.BoxGeometry(12.5,.25,3.25).toNonIndexed();
	matAir = new THREE.MeshBasicMaterial({vertexColors: true});
	geoAir.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
	mshAir = new THREE.Mesh(geoAir,matAir);
	mshAir.position.y = -.5;
	mshAir.position.z = 25;
	Air.AirPBY.add(mshAir);
	// VTail
	mshAir = new THREE.Mesh(new THREE.BoxGeometry(.25,6.25,3.25), new THREE.MeshBasicMaterial({color: Air.Color1}));
	mshAir.position.y = 2.5;
	mshAir.position.z = 25;
	Air.AirPBY.add(mshAir);
	Air.AirPBY.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
	// Location
	if (Air != Air1) {
		Air.AirObj.position.x = (Air.MapPos.x - Air1.MapPos.x);
		Air.AirObj.position.y = (Air.MapPos.y - Air1.MapPos.y);
		Air.AirObj.position.z = (Air.MapPos.z - Air1.MapPos.z);
	}
	initJetSmk(Air);
}

//= MOVE AIRPLANE ==============//==============================================

function move1ACraft(Air) {
	//- LAG COMPUTATIONS -------------------------------------------------------
	// 0 = Mimic ...............................................................
	/*
		Air2 copies Air1 immediately.
		Not useful since allows Air1 to take initiative.
	*/
	if (LagTyp == 0 && Air == Air2) {
		Air.InpRot.copy(Air1.InpRot);
	}
	// 1 = Lag Pursuit .........................................................
	/*
		Air2 stays on tail of Air1
		Save Air1 data
		After time lag, Air2 retrieves data.
		Time lag = Distance/Speed
		Current data max is 360 values = max 6 second lag
	*/
	// If Air1 - Save time for any bank changes
	if (LagTyp == 1) {
		if (Air == Air1) {
			LagInp[LagId1] = new THREE.Vector3().copy(Air.InpRot);
			LagRot[LagId1] = new THREE.Vector3().copy(Air.AirRot);
			LagPos[LagId1] = new THREE.Vector3().copy(Air.MapPos);
			LagId1++
			if (LagId1 > LagMax) LagId1 = 0;
		}
		// If Air2
		if (Air == Air2) {
			// Wait
			if (LagTim) {
				LagTim = LagTim - DLTime;
				if (LagTim <= 0) LagTim = 0;
			}
			else {
				Air.InpRot.copy(LagInp[LagId2]);	//  98% Accuracy
				Air.AirRot.copy(LagRot[LagId2]);	//  99% Accuracy
				Air.MapPos.copy(LagPos[LagId2]);	// 100% Accuracy
				LagId2++		// Go to next
				if (LagId2 > LagMax) LagId2 = 0;
			}
		}
	}
	// 2 = Intercept (WIP) .....................................................
	/*
		There are two opposing factors at play here:
		* The Intercept Angle - the relative position of the Target. 
		* The Off Angle - the difference in heading of the Target.
		Reducing the Intercept Angle causes the Enemy to Bank towards the target.
		Reducing the Off Angle causes a reduction in the Bank.
		We have not yet worked out the best values to reduce the number of oscillations.
	*/
	if (LagTyp == 2 && Air == Air2) {
		// Compute Relative Position
		let x = Air1.MapPos.x - Air.MapPos.x; // X-Distance
		let y = Air1.MapPos.y - Air.MapPos.y; // Y-Distance
		let z = -(Air1.MapPos.z - Air.MapPos.z); // Z-Distance
		IntAng.x = PoM360(Mod360(Math.atan2(x,z)*RadDeg-Air.AirRot.y));	// Horizontal Angle (0-360)		
		IntAng.y = Math.atan2(z,x)*RadDeg;	// Vertical Angle
		OffAng.y = PoM360(Mod360(Air1.AirRot.y - Air2.AirRot.y)); // Horizontal Off-Angle
		// Bank
		let PoMBnk = PoM360(Air.AirRot.z);
		// Offset
		let InpBk1 = .25 * IntAng.x; // 33 => bank of 8, but not rotate
		if (IntAng.x > 0) {
			if (PoMBnk > IntAng.x) InpBk1 = 0;
		}
		else if (IntAng.x < 0) {
			if (PoMBnk < IntAng.x) InpBk1 = 0;
		}
		// Off-Angle
		let InpBk2 = .25 * OffAng.y; // 10 Off = .79; 20 = 2.4; 30 = 2.266
		if (OffAng.y > 0) {
			if (PoMBnk > 2*OffAng.y) InpBk2 = 0;
		}
		else if (OffAng.y < 0) {
			if (PoMBnk < 2*OffAng.y) InpBk2 = 0;
		}
		Air.InpRot.z =  InpBk1 + InpBk2;
	}	
	// 1. COMPUTE VECTORS ------------------------------------------------------
	// Compute Force Vectors in UPS and multiply by FrcAcc to convert to UPT
	// a. Compute New Speeds for New DLTime
	let DLTim2 = DLTime*DLTime;	// Time ^ 2
	let GrvDLT = GrvUPS*DLTim2;	// Gravity (upt)
	let FrcAcc = DLTim2/ACMass;	// Convert Force to Acceleration
	Air.SpdMPS = Air.SpdKPH*1000/3600;
	Air.SpdMPF = Air.SpdMPS*DLTime;
	// b. Compute Dynamic Pressure
	let DynPrs = 0.5*(Air.SpdMPS**2)*AirDen; // Dynamic Pressure
	let QSTval = DynPrs * WingAr;
	// Compute Max Lift
	let LftMax = GrvMax*GrvDLT;	// Maximum G-accel
	LftMax = (LftMax+GrvMax)*GrvDLT;
	// Set CfLift
	// Normally, set power to cause change in flight parth.  CfL adjusted to speed
	// However, in air combat, power always at max.  Must change pitch with CfL
	let ACP = Air.AirRot.x * DegRad
	let ACB = Air.AirRot.z * DegRad;
	if (Math.round(Air.InpRot.x) == 0) {	// Setting for current flight path (level, climb or descent)
		Air.CfLift = (Weight * Math.cos(ACP))/(DynPrs * WingAr * Math.abs(Math.cos(ACB)));
	}
	else {						// Allows change of flight path					
		Air.CfLift =   Air.CfLift + .01*Air.InpRot.x;
	}
	// Add adjustment to level flight path when press specified key combo?
	if (Air.CfLift > CfLMax) Air.CfLift = CfLMax;
	if (Air.CfLift < -CfLMax) Air.CfLift = -CfLMax;
	// c. Compute Lift Rotation
	// Lift = DynPres * WingArea * Cl
	let CfLftT = Air.CfLift;
	let ACLftF =  CfLftT * QSTval; // Lift[ft-lbs] - can be positive or negative
	let ACLift = ACLftF * FrcAcc; // Acceleration (DLT)	
	if (ACLift > 0 && ACLift > LftMax) ACLift = LftMax;	// Limit to Max Gs (pos)
	if (ACLift < 0 && ACLift < -LftMax) ACLift = -LftMax;	// Limit to Max Gs (neg)
	let ACLftD = (ACLift/Air.SpdMPF) * RadDeg;	// Degrees = ACLift*180 / (PI()*V) = ACLift/V * RadDeg
	// d. Compute Net Thrust Acceleration
	let EnThrF = JetMax * Air.PwrPct; // Jet
	if (JetMax == 0) EnThrF = ThrstK * (PwrMax * Air.PwrPct) / Air.SpdMPS;	// Propeller Force
	// Drag
	let DrgCdi = (CfLftT*CfLftT)/(WingAs*WingEf*PieVal);	// Cfi = CLift^2 / (Wing Aspect Ratio * Wing Efficiency * pi)
	let ACDrIF = DrgCdi * QSTval; // Induced Drag = ACLftF^2 / (DynPrs * WingSp^2 * WingEf * PI)
	let DrgCdp = DrgCd0;		// Total Coefficient of Parasitic Drag
	let ACDrPF = DrgCdp * QSTval; // Parasitic Drag =  Cd0 * DynPres * WingA
	let ACThrF = EnThrF - ACDrPF; // Net Thrust Force
	let ACTrst = ACThrF * FrcAcc; // Net Thrust Accel
	let GrvThr = GrvDLT * Math.sin(ACP); // Gravity opposing Thrust = Grav * sin(ACP)
	let ACThrG = ACTrst - GrvThr; // Net Thrust after Gravity +/-
	// e. Gravity Reducing ACPitch
	let GrvACP = GrvDLT * Math.cos(ACP); // Gravity opposing Lift and Yaw
	let GrACPD = (GrvACP / Air.SpdMPF) * RadDeg;	// Degrees +/-
	// Save Values
	let PPPDif = ACLftD;		// Pitch Degrees (before Gravity)
	// Compute Aircraft Pitch Adjustment
	// ACPAdj is an adjustment to Air.AirRot.x that allows the aircraft to pitch relative to the direction of flight
	// to match pitch required to produce specified lift; or, if on ground, to pitch around main wheel axis
	let ACPAdj = (Air.CfLift * 10) - AngInc;	// Default (1.3 = 13)
	// 2. COMPUTE DIRECTION OF FLIGHT -------------------------------------------
	// Inputs: Change in Bank, PPPDif, and Yaw
	// This routine uses 2 linked objects to correctly rotate aircraft
	// Temp Save
	// Changes to Air.AirPBY
	Air.AirPBY.rotation.z = -Air.InpRot.z*DegRad;
	Air.AirPBY.rotation.x = PPPDif*DegRad;
	Air.AirPBY.rotation.y = -Air.InpRot.y*DegRad;
	// Transfer Combined Rotation to Air.AirObj
	Air.AirPBY.getWorldQuaternion(quaternion);
	Air.AirObj.setRotationFromQuaternion(quaternion);
	// Zero Out Air.AirPBY Rotations (so values not doubled)
	Air.AirPBY.rotation.z = 0;
	Air.AirPBY.rotation.x = 0;
	Air.AirPBY.rotation.y = 0;
	// Load Resulting Values into Variables (for display)
	Air.AirRot.z = Mod360(-Air.AirObj.rotation.z*RadDeg);
	Air.AirRot.x = Air.AirObj.rotation.x*RadDeg;
	
	// Update Air.AirObj Heading for Bank
	let ACH = Air.AirRot.y;					// ### Save old heading
	Air.AirRot.y = Mod360(-Air.AirObj.rotation.y*RadDeg);
	if (Air == Air1 && Air.InpRot.z != 0) Air.AirRot.y = ACH;
	Air.HdgDif = Mod360(Air.AirRot.y - ACH);
	if (Air.HdgDif > 180) Air.HdgDif = 360-Air.HdgDif;
	Air.AirObj.rotation.y = -Air.AirRot.y*DegRad;
	
	// 3. COMPUTE MAP SPEED -----------------------------------------------------
	// Inputs:	Air.SpdMPF, ACThrG, Air.AirRot.x, Air.AirRot.y, MPosZV, MPosYV, MPosXV
	// Results:	Air.SpdKPH, Air.AirRSp.z, Air.AirRSp.y, Air.AirRot.x
	// a. Compute Speed
	Air.SpdMPF = Air.SpdMPF + ACThrG;
	if (Air.SpdMPF <= 0) Air.SpdMPF = 0.0001; // Set Minimum Speed to avoid division by zero  211031
	Air.SpdMPS = Air.SpdMPF/DLTime;	// (MPS)
	Air.SpdKPH = Air.SpdMPS*3.6; // (KPH)	
	// b1. Compute PSpd (before gravity)
	ACP = Air.AirRot.x * DegRad;
	Air.MapSpd.z = Air.SpdMPF * Math.abs(Math.cos(ACP)); // Horizontal speed
	// b2. Adjust ACP for Gravity
	Air.AirRot.x = Air.AirRot.x-GrACPD;
	if (Air.AirRot.x < -90) Air.AirRot.x = -90; // Prevents you from pitching back up
	ACP = Air.AirRot.x*DegRad;
	Air.AirObj.rotation.x = ACP;
	Air.MapSpd.y = Air.SpdMPF * Math.sin(ACP); // Vertical speed
	ACH = Air.AirRot.y*DegRad;
	// Map Speed
	Air.MapSpd.y = Air.SpdMPF * Math.sin(ACP);
	let GS = Air.SpdMPF * Math.cos(ACP);
	Air.MapSpd.z = GS * Math.cos(ACH);
	Air.MapSpd.x = GS * Math.sin(ACH);
	// Map Position
	Air.MapPos.y = Air.MapPos.y + Air.MapSpd.y;
	if (Air.MapPos.y < 5) {		// if hit ground, zero out
		Air.MapPos.y = 5;
		Air.AirRot.z = 0;
		Air.AirRot.x = 0;
		Air.InpRot.z = 0;
		Air.InpRot.x = 0;
		Air.AirObj.rotation.z = 0; // No Bank
		Air.AirObj.rotation.x = 0; // No Pitch
	}
	Air.MapPos.z = Air.MapPos.z - Air.MapSpd.z;
	Air.MapPos.x = Air.MapPos.x + Air.MapSpd.x;
	// Convert Speed and Position to Maters
	if (Air != Air1) {
		Air.AirObj.position.x = (Air.MapPos.x - Air1.MapPos.x);
		Air.AirObj.position.y = (Air.MapPos.y - Air1.MapPos.y);
		Air.AirObj.position.z = (Air.MapPos.z - Air1.MapPos.z);
	}
	moveJetSmk(Air);
}

//= Jet Exhaust ================//==============================================

// Init Smoke Trail
function initJetSmk(Air) {
	// particle positin and time
	for (let i = 0; i < SmkTot; i++) {
		Air.SmkPts.push(0,0,0);	// position		
		Air.SmkTim[i] = i*SmkInt;
	}
	// create the particle system
	let geoExh = new THREE.BufferGeometry();
	geoExh.setAttribute('position', new THREE.Float32BufferAttribute(Air.SmkPts, 3));
	let matExh = new THREE.PointsMaterial({size: SmkSiz, color: Air.Color1});
	Air.SmkObj = new THREE.Points(geoExh, matExh);
	// add it to the scene
	scene.add(Air.SmkObj);
	Air.SmkObj.position.copy(Air.AirObj.position);
}

// Move Smoke Trail
function moveJetSmk(Air) {
	let pos = Air.SmkObj.geometry.attributes.position.array;
	let p;
	for (let i = 0; i < SmkTot; i++) {
		p = 3*i;
		pos[p] = pos[p] - Air.MapSpd.x;
		pos[p+1] = pos[p+1] - Air.MapSpd.y;
		pos[p+2] = pos[p+2] + Air.MapSpd.z;
		Air.SmkTim[i] ++;
		if (Air.SmkTim[i] > SmkTot*SmkInt) {
			pos[p] = 0;
			pos[p+1] = 0;
			pos[p+2] = 0;
			Air.SmkTim[i] = 0;
		}	
	}
	Air.SmkObj.geometry.attributes.position.needsUpdate = true;
	Air.SmkObj.position.copy(Air.AirObj.position);	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//*
//*		CAMERA
//*
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// INIT CAMERA =================================================================

function initCamera() {
	CamSel.Ref.add(CamObj);	// Link camera
}

// MOVE CAMERA =================================================================

function moveCamera() {
	// In external view, the camera is facing in and the armature is pointing out:
	// * x.rotation = -CamSel.Rot.x
	// * y.rotation = CamSel.Rot.y + 180
	camera.position.z = -CamSel.Pos.x;
	CamObj.rotation.x = Mod360(-CamSel.Rot.x)*DegRad;
	CamObj.rotation.y = Mod360(180-CamSel.Rot.y)*DegRad;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//*
//*		MISCELLANEOUS SUBROUTINES
//*
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//- Convert degrees to 360 -----------------------------------------------------
function Mod360(deg) {
	while (deg < 0) deg = deg + 360; // Make deg a positive number
	deg = deg % 360;			// Compute remainder of any number divided by 360
return deg;}

//-  Converts 360 degrees to +/- 180 -------------------------------------------
function PoM360(deg) {
	if (deg > 180) deg = deg-360;
return deg;}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//*
//*		OUTPUTS AND INPUTS
//*
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//= OUTPUTS ====================//==============================================

// Change HUD Values
function chngHUDV(Air) {
	//- Air1
	AC1_Hdg = Air1.AirRot.y;					// Aircraft Heading
	AC1_HdgNode.nodeValue = AC1_Hdg.toFixed(0);
	AC1_Alt = Air1.MapPos.y*Mtr2Ft; 			// Aircraft Altitude (feet)
	AC1_AltNode.nodeValue = AC1_Alt.toFixed(0);
	AC1_Spd = Air1.SpdKPH*Km2Mil;				// Aircraft Speed (MPH)
	AC1_SpdNode.nodeValue = AC1_Spd.toFixed(0);
	AC1_Bnk = Air1.AirRot.z;					// Aircraft Bank (deg)
	if (AC1_Bnk > 180) AC1_Bnk = 360 - AC1_Bnk;
	AC1_BnkNode.nodeValue = AC1_Bnk.toFixed(0);
	AC1_Trn = Air1.HdgDif/DLTime;				// Aircraft Turn Rate (deg)
	AC1_TrnNode.nodeValue = AC1_Trn.toFixed(2);
	AC1_Pit = Air1.AirRot.x;					// Aircraft Pitch (deg)
	AC1_PitNode.nodeValue = AC1_Pit.toFixed(0);
	AC1_AoA = Air1.CfLift*10;					// Aircraft AoA
	AC1_AoANode.nodeValue = AC1_AoA.toFixed(2);
	//- Air2
	AC2_Hdg = Air2.AirRot.y;					// Aircraft Heading
	AC2_HdgNode.nodeValue = AC2_Hdg.toFixed(0);
	AC2_Alt = Air2.MapPos.y*Mtr2Ft;				// Aircraft Altitude (feet)
	AC2_AltNode.nodeValue = AC2_Alt.toFixed(0);
	AC2_Spd = Air2.SpdKPH*Km2Mil;				// Aircraft Speed (MPH)
	AC2_SpdNode.nodeValue = AC2_Spd.toFixed(0);
	AC2_Bnk = Air2.AirRot.z;					// Aircraft Bank (deg)
	if (AC2_Bnk > 180) AC2_Bnk = 360 - AC2_Bnk;
	AC2_BnkNode.nodeValue = AC2_Bnk.toFixed(0);
	AC2_Trn = Air2.HdgDif/DLTime;				// Aircraft Turn Rate (deg)
	AC2_TrnNode.nodeValue = AC2_Trn.toFixed(2);
	AC2_Pit = Air2.AirRot.x;					// Aircraft Pitch (deg)
	AC2_PitNode.nodeValue = AC2_Pit.toFixed(0);
	AC2_AoA = Air2.CfLift*10;					// Aircraft AoA
	AC2_AoANode.nodeValue = AC2_AoA.toFixed(2);
}

//= INPUTS =====================//==============================================

//= Keyboard Input =============================================================

// Key Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	if (event.keyCode == K_SpdU) InpSpd = 1;				// Speed Up
	if (event.keyCode == K_SpdD) InpSpd = -1;				// Speed Dn
	if (event.keyCode == K_BnkL) Air1.InpRot.z = -BnkSpd;	// Bank Left
	if (event.keyCode == K_BnkR) Air1.InpRot.z = BnkSpd;	// Bank Right
	if (event.keyCode == K_PitU) Air1.InpRot.x = CfLSpd;	// Pitch Up
	if (event.keyCode == K_PitD) Air1.InpRot.x = -CfLSpd;	// Pitch Down
	if (event.keyCode == K_YawL) Air1.InpRot.y = -0.1;		// Yaw Left
	if (event.keyCode == K_YawR) Air1.InpRot.y = 0.1;		// Yaw Right
	if (event.keyCode == K_Paws) toglPaws();				// Pause
	if (event.keyCode == K_View) toglView();				// View
}

// Key Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	if (event.keyCode == K_SpdU) InpSpd = 0;				// Speed Up
	if (event.keyCode == K_SpdD) InpSpd = 0;				// Speed Dn
	if (event.keyCode == K_BnkL) Air1.InpRot.z = 0;			// Bank Left
	if (event.keyCode == K_BnkR) Air1.InpRot.z = 0;			// Bank Right
	if (event.keyCode == K_PitU) Air1.InpRot.x = 0;			// Pitch Up
	if (event.keyCode == K_PitD) Air1.InpRot.x = 0;			// Pitch Down
	if (event.keyCode == K_YawL) Air1.InpRot.y = 0;			// Yaw Left
	if (event.keyCode == K_YawR) Air1.InpRot.y = 0;			// Yaw Right
}

//= Mouse Input ================================================================

function onMouseDown(event) {
	event.preventDefault();
	PanFlg = 1;
	onPointerDownX = event.clientX;
	onPointerDownY = event.clientY;
	onPointerDownLon = CamSel.Rot.y;
	onPointerDownLat = CamSel.Rot.x;
}

function onMouseUp(event) {
	PanFlg = 0;
}

function onMouseMove(event) {
// Panning View
	if (PanFlg) {
		CamSel.Rot.x = (onPointerDownY - event.clientY) * 0.2 + onPointerDownLat;
		CamSel.Rot.x = Math.max(-CamLtX, Math.min(CamLtX, CamSel.Rot.x));
		CamSel.Rot.y = (event.clientX - onPointerDownX) * 0.2 + onPointerDownLon;
		CamSel.Rot.y = Mod360(CamSel.Rot.y);
	}
}

function onMouseWheel(event) {
	CamSel.Pos.x = CamSel.Pos.x + event.deltaY * CamSel.Dif;
	if (CamSel.Pos.x > CamSel.Pos.y) CamSel.Pos.x = CamSel.Pos.y;
	if (CamSel.Pos.x < CamSel.Pos.z) CamSel.Pos.x = CamSel.Pos.z;
//	CamSel.Pos.x = Math.max(CamSel.Pos.z, Math.min(CamSel.Pos.y, CamSel.Pos.x));
}

//= Button Input ===============//==============================================

// Toggle Pause
function toglPaws() {
	if (PawsOn == 0) PawsOn = 1;
	else PawsOn = 0;
}

//- Change Camera View
function toglView() {
	if (CamSel == Cam1) CamSel = Cam2;
	else if (CamSel == Cam2) CamSel = Cam1;
	initCamera();
}

//= Window Resize Input ========================================================

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
