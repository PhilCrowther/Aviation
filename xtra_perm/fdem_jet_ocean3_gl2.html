<!doctype html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 16 Sep 2025
-->

<head>
<title>fdem jet ocean3 gl2 r167</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="stylesheet" href="styles/butn_map2b.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Heading.(deg): <span id="AC_Head"></span></div>
		<div>Altitude.(ft): <span id="AC_Hite"></span></div>
		<div>Speed...(mph): <span id="AC_Sped"></span></div>
	</div>
</div>

<button id="PAWS" class="pawsButton">Paws</button>
<button id="VIEW" class="viewButton">View</button>

<button id="SPD-" class="spddButton">-</button>
<button id="PIT-" class="pitdButton">&uarr;</button>
<button id="SPD+" class="spduButton">+</button>
<button id="BNKL" class="bnklButton">&larr;</button>
<button id="CNTR" class="cntrButton">X</button>
<button id="BNKR" class="bnkrButton">&rarr;</button>
<button id="YAWL" class="yawlButton">[</button>
<button id="PIT+" class="pituButton">&darr;</button>
<button id="YAWR" class="yawrButton">]</button>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.167.1/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.167.1/examples/jsm/"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import Stats from "three/addons/libs/stats.module.js";
import {Lensflare, LensflareElement} from "three/addons/objects/Lensflare.js";
// Custom Modules
import {loadGeoMat,GrdMap} from "https://PhilCrowther.github.io/Aviation/xtra_perm/jsm/GrdWtr3.js";
import {Ocean} from "https://PhilCrowther.github.io/Aviation/xtra_perm/jsm/Ocean3.js";

/********************************************************************************
*
*	VARIABLES
*
********************************************************************************/

//= STARTING VALUES ======================//=====================================
// Since three.js uses meters, use Meters for Grid Computations
// For Vector Computations, use US units, converted to Meters 
//- Airplane -------------------------------------------------------------------
let USorSI = "US";				// Starting Units of Measurement (US or SI)
let SpdMPH = 500;				// Aircraft Speed (miles per hour)
let BegPos = new THREE.Vector3(0,5000,0); // Position (ft)
let BnkSpd = 1;					// Bank Speed
let PitSpd = 1;					// Pitch Speed

//= GENERAL ==================//=================================================
//-	Conversions
let	PieVal = Math.PI;			// PI
let	DegRad = Math.PI/180;		// Convert Degrees to Radians
let	RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Mtr2Ft = 3.28084;			// Meters to Feet
let Ft2Mtr = .3048;				// Feet to Meters
let MPHMPS = .44704;			// MPH to meters per second
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//- Convert
if (USorSI = "US") {
//	BegSpd = BegSpd*Mil2Km;
	BegPos.multiplyScalar(Ft2Mtr);
}
//-	Flags
let LodFlg = 0;					// Done initializing
let PawsOn = 0;					// Pause
let WireOn = 0;					// Wireframe View
let StatOn = 1;					// Stats ((0 = off, 1 = on)
let	PanFlg = 0;					// Camera Panning
let CamVOn = 0;					// Camera View
let LnFFlg = 1;					// SkyBoc
//= Time
let DLTime = 1/60;				// Frames per Second
//-	Controls
let onPointerDownX, onPointerDownY, onPointerDownLon, onPointerDownLat;

//= SKYBOX =====================//===============================================
let FogCol = 0xbab4a6;			// Sky (for Fog only)
let SkyLim = 100000;			// Max viewing distance
//- Texture
let	SBxSrc = "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/";
//-	LensFlare
let	LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let	LF1Src = "https://threejs.org/examples/textures/lensflare/lensflare3.png";
let LF0Txt, LF1Txt = 0;

//= SUN VALUES =================//===============================================
let SunCol = "white";			// Sun
let SunInt = 3;					// Default intensity of light/sun
//- Rotation and Position (fixed)
let SunDst = 50;				// Distance (for shadows)
let SunLat = 23;				// Direction - Vert (+/- 90) deg
let SunLon = 312;				// Direction - Horz (0->360) deg
//- Computations
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);
//	Shadows
let ShdBox = 100;				// Size of shadow box
let ShdBLR = 6.5;
let ShdBTB = 4;
let ShdDst = 1500;				// Shadow Distance (meters)

//= CAMERA ======================================================================
//	Lat/Lon = direction the camera is pointing
let CamLtX = 90;				// Max lat
let CmADst = 1500*Ft2Mtr;		// Distance from Center
let	CamRot = new THREE.Vector3(-15,335,1500*Ft2Mtr);	// CamLat, CamLon, CamDst
let CmADif = 1;					// In/out speed
let CmAMax = CmADst * 3;		// Maximum Distance
let CmAMin = CmADst * 0.5;		// Minimum Distance
let CmBDst = 200*Ft2Mtr;		// Distance from Aircraft
let CmBDif = .25;				// In/out Speed
let CmBMax = CmBDst * 3;		// Maximum Distance
let CmBMin = CmBDst * 0.5;		// Minimum Distance
let CamDif = CmADif;			// Starting In/out speed
let CamMax = CmAMax;			// Starting distance
let CamMin = CmAMin;			// Starting distance
let CmODst = CmBDst;			// Old Camera Distance
let CmOLon = 0;					// Old Camera Heading

//= BASIC VALUES ================================================================
//- Display
let	scene = new THREE.Scene();
	scene.background = new THREE.Color(FogCol);
let	renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.BasicShadowMap;
	document.body.appendChild(renderer.domElement);
let	maxAnisotropy = renderer.capabilities.getMaxAnisotropy();	// ### [A]
//- Lights
let ambLight = new THREE.AmbientLight(SunCol, 1.0);
	scene.add(ambLight);
let sunLight = new THREE.DirectionalLight(SunCol, SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = SunDst*0.75;
	sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
	sunLight.shadow.mapSize.width = 256;
	sunLight.shadow.mapSize.height = 256;
	sunLight.shadow.camera.left = -ShdBLR;
	sunLight.shadow.camera.right = ShdBLR;
	sunLight.shadow.camera.top = ShdBTB;
	sunLight.shadow.camera.bottom = -ShdBTB;
	scene.add(sunLight);
//- Camera
let	camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, SkyLim);
	camera.rotation.order = "YXZ";
	camera.position.z = -CamRot.z;
	camera.rotation.y = 180*DegRad;	// Default = looking in
let	CamObj = new THREE.Object3D();	// Armature base - use to rotate camera
	CamObj.rotation.order = "YXZ";
	CamObj.add(camera);
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	renderer.domElement.addEventListener("mousedown", onMouseDown, false);
	renderer.domElement.addEventListener("mouseup", onMouseUp, false);
	renderer.domElement.addEventListener("mousemove", onMouseMove, false);
	renderer.domElement.addEventListener('mousewheel', onMouseWheel, {capture: false, passive: false});
	renderer.domElement.addEventListener("touchstart", onTouchStart, false);
	renderer.domElement.addEventListener("touchmove", onTouchMove, false);
	document.getElementById("PAWS").addEventListener("click", togglePause, false);
	document.getElementById("VIEW").addEventListener("click", toggleCamera, false);
	document.getElementById("SPD+").addEventListener("click", toggleSpdU, false);
	document.getElementById("PIT-").addEventListener("click", togglePitD, false);
	document.getElementById("SPD-").addEventListener("click", toggleSpdD, false);
	document.getElementById("BNKL").addEventListener("click", toggleBnkL, false);
	document.getElementById("CNTR").addEventListener("click", toggleCntr, false);
	document.getElementById("BNKR").addEventListener("click", toggleBnkR, false);
	document.getElementById("PIT+").addEventListener("click", togglePitU, false);
	document.getElementById("YAWL").addEventListener("click", toggleYawL, false);
	document.getElementById("YAWR").addEventListener("click", toggleYawR, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);

//= GRDWTR TEXTURES ============//==============================================
let WtrCol = 0x001080;			// Water (Navy)
//- Canvas (for splitting up textures)
let ImgSiz = 512;						// !!! Change this for each image

//= GRDWTR MODULE ==============//==============================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
//- Inputs
let GrdSiz = 3200;				// 3200 = 2 miles
let GrdRes = 512;
let GrdSeg = 256;				// Segments per Plane (256 = OK, 512 = too much)
let WavMax = 5;					// Maximum wave height (set height of outer waves)
//- Module
let grids = 0;
let grd_ = {
		MSP: new THREE.Vector3().copy(BegPos), // MSX, MPY, MSZ (meters) (from Flight)
		RCs: 16,				// Squares in each of first 2 grids
		Siz: GrdSiz,			// Size of smallest square
		Stp: 4,					// Squares in each of first 2 grids
		Seg: GrdSeg,			// Segments for smallest square
		Grx: [],				// Index of Grids (0-2)
		// Geometry and Materials
		Geo: [],				// Master Index of Basic Geometries
		Mat: [[0],[0],0],		// Materials
		// Displacement		
		Dsp: 0,					// Grid 0 Displacement Map (from Ocean)
		// Normal Map
		Nrm: 0,					// Grid 0-1 Normal Map (from Ocean)
		NMS: new THREE.Vector2(1.0,1.0), // Grid 0-1 Normal Map Scale (from Ocean)
		N2S: "https://threejs.org/examples/textures/waternormals.jpg", // Size = 1024x1024
		NM2: 0,					// Grid 2 Normal Map
		// Indices
		Col: new THREE.Color(WtrCol), // Color
		DfS: "https://PhilCrowther.github.io/Aviation/textures/ocean/transition1F_color4.png",
		Mtl: [0.5,0.5,0.5],		// Metalness (1 for max reflection)
		RfS: "https://PhilCrowther.github.io/Aviation/textures/ocean/transition5.png",
		Ruf: [0.1,0.1,0.1],		// Roughness (0 for max reflection)
		EMI: [0.5,0.48,0.48],	// EnvMap Intensity
		// Maps
		MSz: ImgSiz,			// Image Size
		DfM: [[0],[0],0],		// Diffuse
		RfM: [[0],[0],0],		// Roughness
		// Other
		WMx: WavMax,			// Max wave height, used to lower outer squares
	};
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext("2d",{willReadFrequently: true});
	context.translate(0, ImgSiz);		// Flips vertical for three.js
	context.scale(1,-1);
let GeoAll = [];				// Array used to assemble Grids

//= OCEAN MODULE ===============//==============================================
//- Inputs
let WndSpd = 20.0;
let WndHdg = 0.0;
let Choppy = 1.6;

//- Module
let waves = 0;
let wav_ = {
		// Sources
		Res: GrdRes,			// Resolution - segments per square (default = 512)
		Siz: GrdSiz,			// Size of Smallest Square = default = 3200m = 2 miles
		WSp: WndSpd,			// Wind Speed
		WHd: WndHdg,			// Wind Heading
		Chp: Choppy,			// default = 1
	};
let wavSpd = 1.0;				// Animation speed - use in main program (lower is faster)
let wavTim = 0;

//= AIRPLANE ===================//===============================================
let air_ = {
		// Airplane Rotation
		Rot: new THREE.Vector3(),		// Object Rotation (degrees)
		Obj: new THREE.Object3D(),		// Airplane Object
		// Airplane PBY Changes
		Inp: new THREE.Vector3(),		// Inputs
		Dif: new THREE.Vector3(0,0,0),	// Change
		PPR: new THREE.Vector3(),		// Pitch Plane Angle
		PBY: new THREE.Object3D(),		// Object Rotation Change (converted/radians)
		// Map Speed and Position
		ISp: 0,							// Input Speed
		Spd: SpdMPH,					// Speed in MPH
		MpS: new THREE.Vector3(0,0,0),	// Map Speed (meters)
		MpP: new THREE.Vector3().copy(BegPos),	// Map Position (meters)
		MSP: new THREE.Vector3(0,BegPos.y,0),	// MSX, MPY, MSZ (meters)
	}
let	SpdDLT = 0;					// Aircraft Speed (meters per frame)

//= JET EXHAUST ================//==============================================
let SmkPtr = 0;
let SmkPts = 400;
let SmkPos = [];
let SmkCol = [];
let SmkDns = .3;				// Starting density
let SmkFad = .8;				// Fades by this much every frame
let SmkSpd = 10;
let SmkWid = .05;
let SmkLim = 200;				// Max distance

//= OBJECTS ====================================================================
let CtrObj = new THREE.Object3D();		// For Camera
	CtrObj.rotation.order = "YXZ";
	CtrObj.add(CamObj);
	scene.add(CtrObj);
//- Aircraft
	air_.Obj.rotation.order = "YXZ";
	air_.PBY.rotation.order = "YXZ";
	air_.Obj.add(air_.PBY);
	scene.add(air_.Obj);
let quaternion = new THREE.Quaternion();
//- Other Objects
let sunMsh = 0;	// Sun Mesh and Lensflare Textures

//= KEY BINDINGS ===============//===============================================
let K_SpdU = 45;				// Speed Up (insert)
let K_PitD = 38;				// Pitch down (up arrow)
let K_SpdD = 33;				// Speed Up (page up)
let	K_BnkL = 37;				// Bank Left (left arrow)
let K_Cntr = 35;				// Center (end)
let	K_BnkR = 39;				// Bank Right (right arrow)
let K_YawL = 46;				// Yaw Left (delete)
let K_PitU = 40;				// Pitch up (down arrow)
let K_YawR = 34;				// Yaw Right (page down)
let K_Paws = 80;				// Pause (p)
let K_Wire = 87;				// Wireframe (w)

//= HTML OVERLAY TEXT ==========================================================
let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
	AC_HiteElement.appendChild(AC_HiteNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
	AC_HeadElement.appendChild(AC_HeadNode);
let AC_SpedElement = document.getElementById("AC_Sped");
let AC_SpedNode = document.createTextNode("");
	AC_SpedElement.appendChild(AC_SpedNode);
let AC_Hite,AC_Head,AC_Sped;
	
/********************************************************************************
*
*	MAIN PROGRAM
*
********************************************************************************/

	loadAll();

//= LOAD ALL ====================================================================

function loadAll() {
	air_.Obj.rotation.z = Mod360(360-air_.Rot.z) * DegRad;	// Bank
	air_.Obj.rotation.x = Mod360(air_.Rot.x) * DegRad;		// Pitch
	air_.Obj.rotation.y = Mod360(-air_.Rot.y) * DegRad;		// Heading
	air_.MSP.y = air_.MpP.y;
	loadSkyBox();
	loadGeoMat(imagLoader,txtrLoader,grd_,context);
}

//= INITIALIZE (called by loading manager) ======================================

function initAll() {
	initSkyBox();						// Sky, Fog and Sun
	waves = new Ocean(renderer,wav_);	// Initialize Ocean
	grd_.Dsp = waves.displacementMapFramebuffer.texture;
	grd_.Nrm = waves.normalMapFramebuffer.texture;
	grd_.MSP.copy(air_.MSP);
	grids = new GrdMap(grd_,scene);
	initAirPln();						// Load Aircraft
	initJetExh();
	// Show stats
	if (StatOn > 0) {					// show stats
		StatOn = new Stats();
		StatOn.setMode(0);				// FPS only
		StatOn.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(StatOn.dom);
	}
	LodFlg = 1;
}

//= RENDER (called by program) ==================================================

function rendAll() {
	if (!PawsOn && LodFlg) {
		// Update time
		nowTim = clock.getElapsedTime();
		difTim = nowTim-oldTim;
		wavTim = difTim*wavSpd || 0.0;
		oldTim = nowTim;
		// Move Things
		moveAirPln();
		moveJetExh();
		grd_.MSP.copy(air_.MSP);
		waves.render(wavTim);			// Render Ocean
		grids.update(grd_);				// Grids
		// Stats
		if (StatOn) StatOn.update();	// update stats
	}
	chngHUDV()
	moveCamera();
	renderer.render(scene, camera);		// Render
}

/********************************************************************************
*
*	SKY BOX
*
********************************************************************************/

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	// LensFlare
	if (LnFFlg) {				// SunFlare	
		LF0Txt = txtrLoader.load(LF0Src);
		LF1Txt = txtrLoader.load(LF1Src);
	}
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);
		let LF = new Lensflare();
			LF.addElement(new LensflareElement(LF0Txt,256,0));
			LF.addElement(new LensflareElement(LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

/********************************************************************************
*
*	AIRPLANE
*
********************************************************************************/

//- Load Airplane ---------------------------------------------------------------
function initAirPln() {
	// Front
	let mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 2.5, 15, 3, 1, "false"), new THREE.MeshLambertMaterial({color: 0xff00ff}));
	mesh.rotation.x = -PieVal/2;
	mesh.position.z = -5;
	mesh.castShadow = true;
	air_.PBY.add(mesh);
	// Back
	mesh = new THREE.Mesh(new THREE.CylinderGeometry(.25, 2.5, 25, 3, 1, "false"), new THREE.MeshLambertMaterial({color: 0xff00ff}));
	mesh.rotation.x = PieVal/2;
	mesh.rotation.y = PieVal;
	mesh.position.z = 15;
	mesh.castShadow = true;
	air_.PBY.add(mesh);
	// Wing
	mesh = new THREE.Mesh(new THREE.BoxGeometry(50,.25,5), new THREE.MeshLambertMaterial({color: 0xffffff}));
	mesh.position.y = -.5;
	mesh.position.z = 2.5;
	mesh.castShadow = true;
	air_.PBY.add(mesh);
	// HTail
	mesh = new THREE.Mesh(new THREE.BoxGeometry(12.5,.25,3.25), new THREE.MeshLambertMaterial({color: 0xffffff}));
	mesh.position.y = -.5;
	mesh.position.z = 25;
	mesh.castShadow = true;
	air_.PBY.add(mesh);
	// VTail
	mesh = new THREE.Mesh(new THREE.BoxGeometry(.25,6.25,3.25), new THREE.MeshLambertMaterial({color: 0xff00ff}));
	mesh.position.y = 2.5;
	mesh.position.z = 25;
	mesh.castShadow = true;
	air_.PBY.add(mesh);
	air_.PBY.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
}

//- Move Airplane ---------------------------------------------------------------
function moveAirPln() {
	// Pitch -----------------------------------------------
	air_.Dif.x = air_.Inp.x;				// Change to Pitch Speed
	// Self-centering
	if (air_.Dif.x > -0.001 && air_.Dif.x < 0.001) {
		if (air_.Rot.x == 0) air_.Dif.x = 0;
		if (air_.Rot.x < 5 && air_.Rot.x > -5) air_.Dif.x = -0.01 * air_.Rot.x;
	}
	// Bank ------------------------------------------------
	air_.Dif.z = air_.Inp.z;				// Change to Bank Speed
	// Self-centering
	if (air_.Dif.z > -0.001 && air_.Dif.z < 0.001) {
		if (air_.Rot.z == 0) air_.Dif.z = 0;
		if (air_.Rot.z < 7.5) air_.Dif.z = -0.01 * air_.Rot.z;
		if (air_.Rot.z > 352.5) air_.Dif.z = 0.01 * (360 - air_.Rot.z);
	}
	// Yaw
	air_.Dif.y = air_.Inp.y;
	// Turn Rate = tan(bank) * G/V = tan(bank) * 32.174 / 300 fps (aprox 200 mph)
	let ACHSpd = 0;
	if (air_.Dif.z > -BnkSpd && air_.Dif.z < BnkSpd) {
		let ACBrad = air_.Rot.z * DegRad;
		ACHSpd = Math.tan(ACBrad) * 32.174 / 300;
		if (ACHSpd > 0.2) ACHSpd = 0.2;
		if (ACHSpd < -0.2) ACHSpd = -0.2;
		ACHSpd = ACHSpd * Math.cos(air_.Rot.x*DegRad);
	}
	if (air_.Rot.z > 90 && air_.Rot.z < 270) ACHSpd = -ACHSpd;
	// Rotate
	// Make Bank, Pitch and Yaw Rotations to air_.Obj and air_.PBY
	air_.PBY.rotation.z = -air_.Dif.z*DegRad;
	air_.PBY.rotation.x = air_.Dif.x*DegRad;
	air_.PBY.rotation.y = -air_.Dif.y*DegRad;
	// Transfer Combined Rotation to air_.Obj
	air_.PBY.getWorldQuaternion(quaternion);
	air_.Obj.setRotationFromQuaternion(quaternion);
	// Zero Out air_.PBY Rotations (so values not doubled)
	air_.PBY.rotation.z = 0;
	air_.PBY.rotation.x = 0;
	air_.PBY.rotation.y = 0;
	// Load Resulting Values into Variables (for display)
	air_.Rot.z = Mod360(-air_.Obj.rotation.z*RadDeg);
	air_.Rot.x = air_.Obj.rotation.x*RadDeg;
	// Update air_.Obj Heading for Bank
	air_.Rot.y = Mod360(-air_.Obj.rotation.y*RadDeg+ACHSpd);
	air_.Obj.rotation.y = -air_.Rot.y*DegRad;
	// Compute Speed
	air_.Spd = air_.Spd + air_.ISp;		// MPH
	if (air_.Spd < 50) air_.Spd = 50;
	if (air_.Spd > 1200) air_.Spd = 1200;
	air_.ISp = 0;
	SpdDLT = air_.Spd * MPHMPS * DLTime;
	let ACPrad = air_.Rot.x*DegRad;
	let ACHrad = air_.Rot.y*DegRad;
	air_.MpS.y = SpdDLT * Math.sin(ACPrad);
	let GS = SpdDLT * Math.cos(ACPrad);
	air_.MpS.z = GS * Math.cos(ACHrad);
	air_.MpS.x = GS * Math.sin(ACHrad);
	// Convert Map Speed to Meters
	air_.MpS.x = air_.MpS.x*Ft2Mtr;
	air_.MpS.y = air_.MpS.y*Ft2Mtr;
	air_.MpS.z = air_.MpS.z*Ft2Mtr;
	// Position in Meters
	air_.MpP.y = air_.MpP.y + air_.MpS.y;
	air_.MpP.z = air_.MpP.z + air_.MpS.z;
	air_.MpP.x = air_.MpP.x + air_.MpS.x;
	// Results
	air_.MSP.x = air_.MpS.x;
	air_.MSP.y = air_.MpP.y;
	air_.MSP.z = air_.MpS.z;
}

/********************************************************************************
*
*	JET EXHAUST
*
********************************************************************************/

//- Init Jet Exhaust
function initJetExh() {
	let x,y,z;
	for (let i = 0; i < SmkPts; i++) {
	// create a particle with random position values, -250 -> 250
		x = Math.random() * 4 - 2;		// +/-5
		y = Math.random() * 4 - 2;		// 
		z = Math.random() * SmkLim;		//
		SmkPos.push(x,y,z);				// position
		SmkCol.push(240,240,240,SmkDns);	// color and density
	}
	// create the particle system
	let geometry = new THREE.BufferGeometry();
	geometry.setAttribute('position', new THREE.Float32BufferAttribute(SmkPos, 3));
	geometry.setAttribute('color', new THREE.Float32BufferAttribute(SmkCol, 4));
	let material = new THREE.PointsMaterial({size: 4, vertexColors: true, transparent: true});
	SmkPtr = new THREE.Points(geometry, material);
	SmkPtr.position.z = 30;				// behind the airplane
	// add it to the scene
	air_.PBY.add(SmkPtr);
}

//- Move Jet Exhaust
function moveJetExh() {
	let pos = SmkPtr.geometry.attributes.position.array;
	let col = SmkPtr.geometry.attributes.color.array;
	let p = 0;
	let q = 0;
	for (let i = 0; i < SmkPts; i++) {
		pos[p+2] = pos[p+2]+SmkSpd;		// Z distance
		if (pos[p+2] > SmkLim) {
			pos[p+2] = pos[p+2]-SmkLim;	// cut-off
			col[q+3] = SmkDns;			// density
		}
		col[q+3] = SmkFad*col[q+3];
		p += 3;
		q += 4;
	}
	SmkPtr.geometry.attributes.position.needsUpdate = true;
	SmkPtr.geometry.attributes.color.needsUpdate = true;
}

/********************************************************************************
*
*	CAMERA
*
********************************************************************************/

function moveCamera() {
	// In external view, the camera is facing in and the armature is pointing out:
	// * x.rotation = -CamLat
	// * y.rotation = CamLon + 180
	camera.position.z = -CamRot.z;
	CamObj.rotation.x = Mod360(-CamRot.x)*DegRad;
	CamObj.rotation.y = Mod360(180-CamRot.y)*DegRad;
}

/********************************************************************************
*
*	MISC SUBROUTINES
*
********************************************************************************/

//- Converts degrees to 360
function Mod360(deg) {
	while (deg < 0) deg = deg+360;			// Make deg a positive number
	deg = deg % 360;						// Compute remainder of any number divided by 360
return deg;}

/********************************************************************************
*
*	OUTPUTS
*
********************************************************************************/

//= Print HUD Values ===========//===============================================
function chngHUDV() {
	AC_Head = air_.Rot.y;				// Aircraft Heading
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_Hite = air_.MpP.y*Mtr2Ft;		// Aircraft Altitude (feet)
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);
	AC_Sped = air_.Spd;				// Aircraft Speed (MPH)
	AC_SpedNode.nodeValue = AC_Sped.toFixed(0);
}

/********************************************************************************
*
*	INPUTS
*
********************************************************************************/

//= Keyboard ====================================================================

//- Key Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	if (event.keyCode == K_SpdU) air_.ISp = 1;			// Speed Up
	if (event.keyCode == K_SpdD) air_.ISp = -1;			// Speed Dn
	if (event.keyCode == K_BnkL) air_.Inp.z = -BnkSpd;	// Bank Left
	if (event.keyCode == K_BnkR) air_.Inp.z = BnkSpd;	// Bank Right
	if (event.keyCode == K_PitU) air_.Inp.x = PitSpd;	// Pitch Up
	if (event.keyCode == K_PitD) air_.Inp.x = -PitSpd;	// Pitch Down
	if (event.keyCode == K_Cntr) toggleCntr();			// Center
	if (event.keyCode == K_YawL) air_.Inp.y = -0.1;		// Yaw Left
	if (event.keyCode == K_YawR) air_.Inp.y = 0.1;		// Yaw Right
	if (event.keyCode == K_Paws) togglePause();			// Pause
	if (event.keyCode == K_Wire) toggleWire();			// Wire
}

//- Key Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	if (event.keyCode == K_SpdU) air_.ISp = 0;			// Speed Up
	if (event.keyCode == K_SpdD) air_.ISp = 0;			// Speed Dn
	if (event.keyCode == K_BnkL) air_.Inp.z = 0;		// Bank Left
	if (event.keyCode == K_BnkR) air_.Inp.z = 0;		// Bank Right
	if (event.keyCode == K_PitU) air_.Inp.x = 0;		// Pitch Up
	if (event.keyCode == K_PitD) air_.Inp.x = 0;		// Pitch Down
	if (event.keyCode == K_YawL) air_.Inp.y = 0;		// Yaw Left
	if (event.keyCode == K_YawR) air_.Inp.y = 0;		// Yaw Right
}

//= Mouse Input =================================================================

function onMouseDown(event) {
	event.preventDefault();
	PanFlg = 1;
	onPointerDownX = event.clientX;
	onPointerDownY = event.clientY;
	onPointerDownLon = CamRot.y;
	onPointerDownLat = CamRot.x;
}

function onMouseUp(event) {
	PanFlg = 0;
}

function onMouseMove(event) {
//- Panning View
	if (PanFlg > 0) {
		CamRot.x = (onPointerDownY - event.clientY) * 0.2 + onPointerDownLat;
		CamRot.x = Math.max(-CamLtX, Math.min(CamLtX, CamRot.x));
		CamRot.y = (event.clientX - onPointerDownX) * 0.2 + onPointerDownLon;
		CamRot.y = Mod360(CamRot.y);
	}
}

function onMouseWheel(event) {
	CamRot.z = CamRot.z + event.deltaY * CamDif;
	CamRot.z = Math.max(CamMin, Math.min(CamMax, CamRot.z));
}

//= Touch Screen Input ==========================================================

function onTouchStart(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		onPointerDownX = event.touches[0].clientX;
		onPointerDownY = event.touches[0].clientY;
		onPointerDownLon = CamRot.y;
		onPointerDownLat = CamRot.x;
	}
}

function onTouchMove(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		CamRot.y = (onPointerDownX - event.touches[0].clientX) * 0.2 + onPointerDownLon;
		CamRot.y = Mod360(CamRot.y);
		CamRot.x = (event.touches[0].clientY - onPointerDownY) * 0.2 + onPointerDownLat;
		CamRot.x = Math.max(-85, Math.min(85, CamRot.x));
	}
}

//= Buttons Input ===============================================================

//- Toggle Pause
function togglePause() {
	PawsOn = 1 - PawsOn;
}

//- Toggle Wire
function toggleWire() {
	WireOn = 1 - WireOn;
	if (WireOn) {
		for (let x = 0; x < 16; x++) {
			grd_.Mt0[x].wireframe = true;
			grd_.Mt0[x].needsUpdate = true;		
		}
	}
	else {
		for (let x = 0; x < 16; x++) {
			grd_.Mt0[x].wireframe = false;
			grd_.Mt0[x].needsUpdate = true;
		}
	}
}

//- Change Camera View
function toggleCamera() {
	// From External to Linked
	if (CamVOn == 0) {
		CtrObj.remove(CamObj);
		air_.PBY.add(CamObj);			// Link camera to aircraft
		let OldVal = 0;
		OldVal = CmODst;
		CmODst = CamRot.z;			// Old Camera Distance
		CamRot.z = OldVal;			
		CamDif = CmBDif;			// In/out speed
		CamMax = CmBMax;			// Max distance
		CamMin = CmBMin;			// Max distance
		CamVOn = 1;	
	}
	// From Linked to External
	else if (CamVOn == 1) {
		air_.PBY.remove(CamObj);
		CtrObj.add(CamObj);			// Link camera to map
		let OldVal = 0;
		OldVal = CmODst;
		CmODst = CamRot.z;			// Old Camera Distance
		CamRot.z = OldVal;
		OldVal = CmOLon;
		CmOLon = CamRot.y;			// Old Camera Heading
		CamRot.y = OldVal;					
		CamDif = CmADif;			// In/out speed
		CamMax = CmAMax;			// Max distance
		CamMin = CmAMin;			// Max distance
		CamVOn = 0;
	}
}

//- Flight Controls

function toggleSpdU() {
	if (air_.ISp == 0) air_.ISp = 10;
	else air_.ISp = 0;
}

function togglePitD() {
	if (air_.Inp.x == 0) air_.Inp.x = -PitSpd;
	else air_.Inp.x = 0;
}

function toggleSpdD() {
	if (air_.ISp == 0) air_.ISp = -10;
	else air_.ISp = 0;
}

function toggleBnkL() {
	if (air_.Inp.z == 0) air_.Inp.z = -BnkSpd;
	else air_.Inp.z = 0;
}

function toggleCntr() {
	air_.Inp.z = 0;
	air_.Inp.x = 0;
	air_.Inp.y = 0;
	air_.Rot.z = 0;
	air_.Rot.x = 0;
	air_.Obj.rotation.z = 0;			// No Bank
	air_.Obj.rotation.x = 0;			// No Pitch
}

function toggleBnkR() {
	if (air_.Inp.z == 0) air_.Inp.z = BnkSpd;
	else air_.Inp.z = 0;
}

function togglePitU() {
	if (air_.Inp.x == 0) air_.Inp.x = PitSpd;
	else air_.Inp.x = 0;
}

function toggleYawL() {
	if (air_.Inp.y == 0) air_.Inp.y = -0.1;
	else air_.Inp.y = 0;
}

function toggleYawR() {
	if (air_.Inp.y == 0) air_.Inp.y = 0.1;
	else air_.Inp.y = 0;
}

//= Window Resize Input =========================================================

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
