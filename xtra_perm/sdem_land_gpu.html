<!doctype html>
<html>

<!--
Copyright 2017-26, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 24 Feb 2026

This programs shows procedurally generated farmland plus medium quality trees.
-->

<head>
<title>sdem land gpu r183.1</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="styles/body2z1.css">
</head>
<body>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Type No..: <span id="Typ_Num"></span></div>
		<div>Altitude.: <span id="Cam_Alt"></span> ft</div>
		<div>Heading..: <span id="Cam_Hdg"></span> deg</div>
	</div>
</div>

<button id="TYP" class="d1TypeButton">Type</button>

<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
			"three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
			"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/"
		}
	}
</script>

<script type="module">
import * as THREE from "three";
import {color,texture,uniform,positionLocal,normalMap} from 'three/tsl';
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {OrbitControls} from "three/addons/controls/OrbitControls.js";
import {LensflareMesh,LensflareElement} from "three/addons/objects/LensflareMesh.js";
import Stats from "three/addons/libs/stats.module.js";
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

/********************************************************************************
*
*	VARIABLES
*
********************************************************************************/

//= 1. MAIN VARIABLES ==========//===============================================

let dtType = 4;					// Texture Type (0-9)

//- CONSTANTS ------------------//-----------------------------------------------
//	Conversions
let	DegRad = Math.PI/180;		// Convert Degrees to Radians
let	RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let	Mtr2Ft = 3.28084;
			
//- GENERAL VARIABLES ----------//-----------------------------------------------
let gen_ = {
		//- Display
		StatOn:	1,				// Stats (0 = off, 1 = on)
		LnFFlg:	1,				// Lensflare
		// Program Flags
		LodFlg:	0,				// Set at end of initialization
		// Altitude Adjustment
		AltAdj:	0.99,			// Raises objects above map as altitude increases
		AltDif:	0,
		// Misc
		contxt: 0,
		canvas: 0,
		MaxAni: 0,
	}

//= 2. SKY VARIABLES ===========//===============================================
let sky_ = {
		// Sun
		SunCol: "white",		// Sun
		SunInt: 3,
		// Fog
		FogCol: 0xbab4a6,		// Sky (for Fog only)
		// SkyBox
		SBxSrc: "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/",
		envMap: 0,				// For this SkyBox
		// Sun (position in SkyBox)
		SunLat: 23,				// Direction - Vert (+/- 90) deg
		SunLon: 312,			// Direction - Horz (0->360) deg
		// LensFlare		
		LF0Src: "https://PhilCrowther.github.io/Aviation/textures/fx/lensflare1.png",
		LF1Src: "https://PhilCrowther.github.io/Aviation/textures/fx/lensflare3.png",
		LF0Txt: 0,
		LF1Txt: 0,
		// Shadow Beg Info
		SunDst: 10000,			// Distance
		ShdBox: 6,				// Size of shadow box
		ShdBLR: 6.5,
		ShdBTB: 4,
		ShdDst: 1500,			// Shadow Distance (meters)
	}

//= SUN VALUES =================//===============================================
//- New	
let SunSph = new THREE.Spherical(sky_.SunDst,(90-sky_.SunLat)*DegRad,Mod360(180-sky_.SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);

//= CAMERA VARIABLES ============================================================
let SkyLim = 100000;			// Max viewing distance 

//= BASIC SETUP =================================================================
//- Scene
let	scene = new THREE.Scene();
//- Lights
let sunLight = new THREE.DirectionalLight(sky_.SunCol,sky_.SunInt);
//	sunLight.position.copy(SunPos).normalize();
	sunLight.position.copy(SunPos);	// x = -3420, y = 1954, z = -3080
//	console.log(SunPos.x,SunPos.y,SunPos.z);
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.castShadow = true;
	sunLight.shadow.camera.left = -sky_.ShdBLR;
	sunLight.shadow.camera.right = sky_.ShdBLR;
	sunLight.shadow.camera.top = sky_.ShdBTB;
	sunLight.shadow.camera.bottom = -sky_.ShdBTB;
	sunLight.shadow.camera.far = sky_.ShdDst;
	sunLight.shadow.bias = -0.0005;
	sunLight.shadow.camera.updateProjectionMatrix();
	scene.add(sunLight);
let helper = new THREE.DirectionalLightHelper(sunLight,5);
//	scene.add( helper );
//- Camera
let	camera = new THREE.PerspectiveCamera(55.0,window.innerWidth/window.innerHeight,0.5,SkyLim);
	camera.position.set(-40,10,400);
//- Renderer
let	renderer = new THREE.WebGPURenderer({antialias: true});	//### r167
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	document.body.appendChild(renderer.domElement);
	gen_.MaxAni = renderer.getMaxAnisotropy();
	await renderer.init();		// Allows time for backend to initialize
//- Controls
let	controls = new OrbitControls(camera,renderer.domElement);
//- Inputs
	document.getElementById("TYP").addEventListener("click", toggleType, false);
	window.addEventListener("resize",onWindowResize,false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);

//= CAMERA ======================================================================
let	CamDst, CamLat, CamHdg, CamAlt = 0;	

//= Data ========================================================================
//- Maps ------------------------------------------------------------------------
let Df0Txt = "https://PhilCrowther.github.io/Aviation/scenery/textures/transition1F2.jpg";
let Df1Txt = "https://PhilCrowther.github.io/Aviation/scenery/textures/transition1G2.jpg";
let Df2Txt = "https://PhilCrowther.github.io/Aviation/scenery/textures/transition1G3.jpg";
//- Ground Square ---------------------------------------------------------------
let dqSize = 805;	// size of quarter section in meters = 2640 feet (2 ft per row = 1320 rows)
let datMax = 6;
//- Data Textures ---------------------------------------------------------------
let dtSize = 1024;		// 8 pixels per row = 128 rows
let dtArea = dtSize*dtSize;
let d0Data = new Uint8Array(4*dtArea);	// Dirt
let d1Data = new Uint8Array(4*dtArea);	// Pasture
let d2Data = new Uint8Array(4*dtArea);	// Plowed
let d3Data = new Uint8Array(4*dtArea);	// Green
let d4Data = new Uint8Array(4*dtArea);	// Beans
let d5Data = new Uint8Array(4*dtArea);	// Wheat
let dtPtrs = [d0Data,d1Data,d2Data,d3Data,d4Data,d5Data];
//- Data Textures Names ---------------------------------------------------------
let dtName = ["Dirt","Pasture","Plowed","Green","Beans","Wheat"];
//- Materials -------------------------------------------------------------------
let dtMats = [0,0,0,0,0,0,0,0,0,0];
//- Meshes ----------------------------------------------------------------------
let dtMesh = [0,0,0,0,0,0,0,0,0,0];
//- Colors ----------------------------------------------------------------------
let red = [0,0];
let grn = [0,0];
let blu = [0,0];
let drtclr = [0xbaa590,0x654321];	// Dirt
let pstclr = [0x00b000,0x005000];	// Pasture
let cvrclr = [0x00c000,0x004000];	// Green
let bnsclr = [0x00e000,0x006000];	// Beans
let whtclr = [0xfbf4e5,0xeabb63];	// Wheat

//= TREELINE ===================//==============================================
let tre_ = {
		ObjNum: 2,
		ObjMpZ: [0,25],			// Map Address Z (+South,-North)
		ObjMpX: [0,0],			// Map Address X
		ObjRot: [0,-90],		// Rotation (0 or -90)
}

let	tr1_ = {
		ObjNum: 2,
		ObjSrc: ["https://PhilCrowther.github.io/Aviation/scenery/models/treelineEW.glb",
				 "https://PhilCrowther.github.io/Aviation/scenery/models/treelineNS.glb"],
		ObjAdr: [],				// Object Address
}

let	tr2_ = {
		ObjNum: 2,
		ObjSrc: ["https://PhilCrowther.github.io/Aviation/scenery/models/treelineEW2.glb",
				 "https://PhilCrowther.github.io/Aviation/scenery/models/treelineNS2.glb"],
		ObjAdr: [],				// Object Address
}

//= HTML OVERLAY TEXT ==========================================================
let Typ_NumElement = document.getElementById("Typ_Num"); // Type
let Typ_NumNode = document.createTextNode("");
	Typ_NumElement.appendChild(Typ_NumNode);
let Cam_AltElement = document.getElementById("Cam_Alt"); // Altitude
let Cam_AltNode = document.createTextNode("");
	Cam_AltElement.appendChild(Cam_AltNode);
let Cam_HdgElement = document.getElementById("Cam_Hdg"); // Heading
let Cam_HdgNode = document.createTextNode("");
	Cam_HdgElement.appendChild(Cam_HdgNode);
let Typ_Num,Cam_Alt,Cam_Hdg;

/********************************************************************************
*
*	MAIN PROGRAM
*
********************************************************************************/

	loadAll();

//= 0 LOAD ALL =================//===============================================

function loadAll() {
	loadSkyBox();
	loadTreLin(tre_,tr1_,tr2_);
	loadDifTxt();
	if (gen_.StatOn) {			// Load Stats
		gen_.StatOn = new Stats();
		document.body.appendChild(gen_.StatOn.dom);
		gen_.StatOn.domElement.style.cssText = "position:absolute;top:90%;left:95%;";
	}
}

//= 1 INIT ALL =================//===============================================

function initAll() {
	initSkyBox();
	initCover();
	gen_.LodFlg = 1;
}

// 2 REND ALL ==================//================================================

function rendAll() {
	if (gen_.LodFlg) {
		moveTreLin(tr1_,tr2_);
		// Update camera position
		if(camera.position.y < 0.0) {
			camera.position.y = 2.0;
		}
		if (gen_.StatOn) gen_.StatOn.update(); // update stats
	}
	prntHUDval();
	renderer.render(scene,camera);
//	console.log(renderer.info);
}

/********************************************************************************
*
*	SKY BOX
*
********************************************************************************/

function loadSkyBox() {
	sky_.envMap = cubeLoader
		.setPath(sky_.SBxSrc)
		.load(["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]);
	sky_.envMap.format = THREE.RGBAFormat;
	sky_.envMap.colorSpace = THREE.SRGBColorSpace; // r152
	scene.background = sky_.envMap;
	// LensFlare
	if (gen_.LnFFlg) {				// LensFlare	
		sky_.LF0Txt = txtrLoader.load(sky_.LF0Src);
		sky_.LF1Txt = txtrLoader.load(sky_.LF1Src);
	}
}

//= INIT SKY ===================//===============================================
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)

function initSkyBox() {
	scene.fog = new THREE.Fog(sky_.FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (gen_.LnFFlg) {			// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);	
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(sky_.LF0Txt,256,0));
			LF.addElement(new LensflareElement(sky_.LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(sky_.LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

/********************************************************************************
*
*	LAND
*
********************************************************************************/
// 5280 feet = 1024 pixels X 10 repss = 10240 pixels
// 0.515 feet = 1 pixel

//= LOAD ========================================================================

function loadDifTxt() {
	//- Diffuse Texture
	txtrLoader.load(Df0Txt,function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.needsUpdate = true;
		Df0Txt = texture;
	});
	//- Diffuse Texture
	txtrLoader.load(Df1Txt,function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.needsUpdate = true;
		Df1Txt = texture;
	});
	//- Diffuse Texture
	txtrLoader.load(Df2Txt,function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.needsUpdate = true;
		Df2Txt = texture;
	});
}

//= INIT ========================================================================

function initCover() {
// 1024/8 = 128 rows
// 2640 ft - 80 ft border =  2,560 ft 
// 2560 ft at 1 row per 2 ft = 1280 rows = 10 reps
	initTxtr();
	dtMesh[dtType].visible = true;
}

function initTxtr() {
	// Dirt Underneath All
	for (let i = 0; i < datMax; i++) {
		makeDirt(i);
	}
	// Add Other Textures
	makePast(1);						// Pasture
	makePlow(2);						// Plowed
	makeCovr(3);						// Green Line
	makeWeat(4);						// Yellow Line
	makeBean(5);						// Green Dots
	// Init
	// Make Materials and Meshes
	let geometry = new THREE.PlaneGeometry(dqSize, dqSize);
	for (let i = 0; i < datMax; i++) {
		let dtData = dtPtrs[i];
		let DatTxt = new THREE.DataTexture(dtData, dtSize, dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(1,0);
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = gen_.MaxAni;
		DatTxt.needsUpdate = true;
		if (i < 2) {
			dtMats[i] = new THREE.MeshLambertNodeMaterial({
				colorNode: texture(DatTxt).mul(texture(Df0Txt)),
			});
		}
		if (i > 3) {
			dtMats[i] = new THREE.MeshLambertNodeMaterial({
				colorNode: texture(DatTxt).mul(texture(Df1Txt)),
			});
		}
		if (i == 2 || i == 3) {
			dtMats[i] = new THREE.MeshLambertNodeMaterial({
				colorNode: texture(DatTxt).mul(texture(Df2Txt)),
			});
		}
		dtMesh[i] = new THREE.Mesh(geometry,dtMats[i]);
		dtMesh[i].rotation.x = -90*DegRad;
		dtMesh[i].receiveShadow = true;
		scene.add(dtMesh[i]);
		dtMesh[i].visible = false;
	}
}

function makeDirt(typ) {
// Two colors, weighted towards color1
	let dtData = dtPtrs[typ];
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(drtclr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	for (let y = 0; y < dtSize; y++) {
		for (let x = 0; x < dtSize; x++) {
			let i = Math.floor(1.6*Math.random());
			let idx = (y*dtSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makePast(typ) {
	let dtData = dtPtrs[typ];
//	makeDirt();
	let clr;
// Two colors, weighted towards color1
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(pstclr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let y = 0; y < dtSize; y++) {
		for (let x = 0; x < dtSize; x++) {
			i = Math.floor(4*Math.random());
			idx = (y*dtSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

function makePlow() {
// Two colors - one on each side of row
	let clr;
	for (let i = 0; i < 2; i++) {
		clr = new THREE.Color(drtclr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	makeHrzL(2);
	makeShdH(2);
}

function makeCovr() {
// Two colors - one on each side of row
	let clr;
	for (let i = 0; i < 2; i++) {
		clr = new THREE.Color(cvrclr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	makeHrzL(3);
	makeShdH(3);
}

function makeBean() {
// Two colors - one on each side of row
	let clr;
	for (let i = 0; i < 2; i++) {
		clr = new THREE.Color(bnsclr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	makeVrtD(4);
	makeShdV(4);
}

function makeWeat() {
// Two colors - one on each side of row
	let clr;
	for (let i = 0; i < 2; i++) {
		clr = new THREE.Color(whtclr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	makeVrtL(5);
	makeShdV(5);
}

function makeVrtL(typ) {
	let dtData = dtPtrs[typ];
	let idx, i;
	for (let x = 4; x < dtSize; x+=8) {	// Rows
		for (let y = 0; y < dtSize; y++) {
			idx = (y*dtSize + x) * 4;
			i = Math.floor(1.9*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(1.5*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(1.5*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(1.9*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

function makeHrzL(typ) {
	let dtData = dtPtrs[typ];
	let idx, i;
	for (let y = 4; y < dtSize; y+=8) {	// Rows
		for (let x = 0; x < dtSize; x++) {
			idx = (y*dtSize + x) * 4;
			i = Math.floor(1.9*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4*dtSize;
			i = Math.floor(1.5*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4*dtSize;
			i = Math.floor(1.5*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4*dtSize;
			i = Math.floor(1.9*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

function makeVrtD(typ) {
	let dtData = dtPtrs[typ];
	let idx, i;
	for (let x = 4; x < dtSize; x+=8) {	// Rows
		for (let y = 0; y < dtSize; y++) {
			idx = (y*dtSize + x) * 4;
			i = Math.floor(8*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(8*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(8*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(8*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

//- Make Shadow ----------------------------------------------------------------

function makeShdV(typ) {
	let dtData = dtPtrs[typ];
	let idx;
	for (let x = 7; x < dtSize; x+=8) {	// Rows
		for (let y = 0; y < dtSize; y++) {
			idx = (y*dtSize + x) * 4;
			dtData[idx  ] = dtData[idx  ] * 0.25;
			dtData[idx+1] = dtData[idx+1] * 0.25;
			dtData[idx+2] = dtData[idx+2] * 0.25;
			//
			idx = idx+4;
			dtData[idx  ] = dtData[idx  ] * 0.25;
			dtData[idx+1] = dtData[idx+1] * 0.25;
			dtData[idx+2] = dtData[idx+2] * 0.25;
		}
	}
}

function makeShdH(typ) {
	let dtData = dtPtrs[typ];
	let idx;
	for (let y = 11; y < dtSize; y+=8) {	// Rows
		for (let x = 0; x < dtSize; x++) {
			idx = (y*dtSize + x) * 4;
			dtData[idx  ] = dtData[idx  ] * 0.25;
			dtData[idx+1] = dtData[idx+1] * 0.25;
			dtData[idx+2] = dtData[idx+2] * 0.25;
			//
			idx = idx+4*dtSize;
			dtData[idx  ] = dtData[idx  ] * 0.25;
			dtData[idx+1] = dtData[idx+1] * 0.25;
			dtData[idx+2] = dtData[idx+2] * 0.25;
		}
	}
}

/********************************************************************************
*
*	TREELINE
*
********************************************************************************/

//= LOAD ========================================================================

function loadTreLin(tre_,tr1_,tr2_) {
	// load all the treelines
	let ObjSrc = 0;
	for (let n = 0; n < tre_.ObjNum; n++) {
		// MidPoly Trees
		ObjSrc = tr1_.ObjSrc[0]; // EW (default)
		if (tre_.ObjRot[n]) ObjSrc = tr1_.ObjSrc[1]; // NS
		gltfLoader.load(ObjSrc, function (gltf) {
			tr1_.ObjAdr[n] = gltf.scene;		
			tr1_.ObjAdr[n].position.x = tre_.ObjMpX[n];
			tr1_.ObjAdr[n].position.z = tre_.ObjMpZ[n];		
			scene.add(tr1_.ObjAdr[n]);
		});
		// LowPoly Trees
		ObjSrc = tr2_.ObjSrc[0]; // EW (default)
		if (tre_.ObjRot[n]) ObjSrc = tr2_.ObjSrc[1]; // NS
		gltfLoader.load(ObjSrc, function (gltf) {
			tr2_.ObjAdr[n] = gltf.scene;		
			tr2_.ObjAdr[n].position.x = tre_.ObjMpX[n];
			tr2_.ObjAdr[n].position.z = tre_.ObjMpZ[n];		
			scene.add(tr2_.ObjAdr[n]);
			tr2_.ObjAdr[n].visible = "false";
		});
	}
//	moveTreLin();
}

//= MOVE ========================================================================

function moveTreLin(tr1_,tr2_) {
	let a = "";
	for (let n = 0; n < tre_.ObjNum; n++) {
		// Near
		if (Math.abs(CamDst) < 500) {
			tr1_.ObjAdr[n].visible = "true";
			tr1_.ObjAdr[n].position.x = tre_.ObjMpX[n];
			tr1_.ObjAdr[n].position.y = 0;
			tr1_.ObjAdr[n].position.z = tre_.ObjMpZ[n];
			tr2_.ObjAdr[n].visible = "false";
			tr2_.ObjAdr[n].position.x = -10000;
			tr2_.ObjAdr[n].position.y = -10000;
			tr2_.ObjAdr[n].position.z = -10000;
//			a = "near";
		}
		// Far
		else {
			tr1_.ObjAdr[n].visible = "false";
			tr1_.ObjAdr[n].position.x = -10000;
			tr1_.ObjAdr[n].position.y = -10000;
			tr1_.ObjAdr[n].position.z = -10000;
			tr2_.ObjAdr[n].visible = "true";
			tr2_.ObjAdr[n].position.x = tre_.ObjMpX[n];
			tr2_.ObjAdr[n].position.y = 0;
			tr2_.ObjAdr[n].position.z = tre_.ObjMpZ[n];
//			a = "far";
		}
	}
//	console.log(Math.round(CamDst),a);
}

/********************************************************************************
*
*	MISC SUBROUTINES
*
********************************************************************************/

//= Converts degrees to 360 ====//==============================================
function Mod360(deg) {
	while (deg < 0) deg = deg+360;	// Make deg a positive number
	deg = deg % 360;			// Compute remainder of any number divided by 360
return deg;}

/********************************************************************************
*
*	OUTPUTS
*
********************************************************************************/

//= Print HUD Values ===========//===============================================

function prntHUDval() {
	CamLat = controls.getPolarAngle();
	CamLat = 90-CamLat*RadDeg;
	CamHdg = controls.getAzimuthalAngle();
	CamHdg = Mod360(-CamHdg*RadDeg)
	CamDst = controls.getDistance();
	CamAlt = CamDst*Math.sin(CamLat*DegRad);		
	//
	Typ_NumNode.nodeValue = dtName[dtType];
	Cam_Alt = Mtr2Ft*CamAlt;	// Altitude
	Cam_AltNode.nodeValue = Cam_Alt.toFixed(0);
	Cam_Hdg = CamHdg;			// Heading
	Cam_HdgNode.nodeValue = Cam_Hdg.toFixed(0);
}

/********************************************************************************
*
*	INPUTS
*
********************************************************************************/

//= Keyboard ====================================================================

// Toggle Type
function toggleType() {
	dtMesh[dtType].visible = false;
	dtType++;
	if (dtType == datMax) dtType = 0;
	dtMesh[dtType].visible = true;
}

//= Window Resize Input =========================================================

function onWindowResize() {
	camera.aspect = window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>
