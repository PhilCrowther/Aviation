<!DOCTYPE html>
<html lang="en">

<head>
<title>Ocean3 WebGL2 r180</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/butn_map2b.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Altitude.: <span id="Cam_Alt"></span> ft</div>
		<div>Heading..: <span id="Cam_Hdg"></span> deg</div>
	</div>
</div>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.180.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {OrbitControls} from "three/addons/controls/OrbitControls.js";
import Stats from "three/addons/libs/stats.module.js";
import {Ocean} from "https://PhilCrowther.github.io/Aviation/xtra/jsm/Ocean3.js";

/********************************************************************************
*
*	VARIABLES
*
********************************************************************************/

//= GENERAL =====================================================================
//-	Math Predefined
var DegRad = Math.PI/180;		// Convert Degrees to Radians
var RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let	Mtr2Ft = 3.28084;
//- Flags
let LodFlg = 0;
let PawsOn = 0;
let WireOn = 0;
let StatOn = 1;					// Stats ((0 = off, 1 = on)

//= SKYBOX ======================================================================
let SkyCol = 0x1732c1;		// Sky
let SkyLim = 100000;			// Max viewing distance 
//- Texture
let SBPath = "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/";

//= SUN =========================================================================
let SunCol = 0xffffff;			// Sun
let SunInt = 3;					// Intensity
//- Rotation and Position (fixed)
let SunLat = 23;				// Direction - Vert (+/- 90)
let SunLon = 312;				// Direction - Horz (0->360)
let SunDst = 10000;				// Distance (for shadows and lensflare)
//- New
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);

//= BASIC VALUES ================================================================
//- Camera
let	camera = new THREE.PerspectiveCamera(55.0, window.innerWidth/window.innerHeight, 0.5, SkyLim);
	camera.position.set(0,350,800);
//- Display
let	scene = new THREE.Scene();
	scene.background = new THREE.Color(SkyCol);
let	renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.BasicShadowMap;
	container.appendChild(renderer.domElement);
let	maxAnisotropy = renderer.capabilities.getMaxAnisotropy();	// ### [A]
//- Lights
let sunLight = new THREE.DirectionalLight(SunCol,3.0);
	sunLight.position.copy(SunPos).normalize();
	scene.add(sunLight);
//- Controls
let	controls = new OrbitControls(camera, renderer.domElement);
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("keydown",onDocumentKeyDown,false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);

//= CAMERA ======================================================================
let	CamDst, CamLat, CamHdg, CamAlt = 0;	

//= MATERIALS ===================================================================
let WtrCol = 0x001080;			// Water (Navy)
//- Textures --------------------------------------------------------------------
let DifTxt = "https://PhilCrowther.github.io/Aviation/textures/ocean/transition1F_color4.png";
//- Maps ------------------------------------------------------------------------
let RufMap = "https://PhilCrowther.github.io/Aviation/textures/ocean/transition5.png";

//= GRID DATA ================================================================*/
let GrdSiz = 2400;				// Size of Smallest Grid Square (meters)
let GrdRes = 512;
let GrdSeg = 512;				// Segments per Plane (256 = OK, 512 = too much)
//- Planes
let GrdRCs = 2;
let GrdPtr = [0];
let WavMZV = [0];
let WavMXV = [0];
//- Common Values
let WtrGeo,WtrMat,WtrMsh = 0;

//= OCEAN ====================================================================*/
let WndSpd = 20;
let WndHdg = 315;
let Choppy = 1.6;
//
let waves = 0;
let wav_ = {
		// Sources
		Res: GrdRes,			// Resolution - segments per square (default = 512)
		Siz: GrdSiz,			// Size of Smallest Square = default = 3200m = 2 miles
		WSp: WndSpd,			// Wind Speed
		WHd: WndHdg,			// Wind Heading
		Chp: Choppy,			// default = 1
		// Results
		Dsp: 0,					// The Displacement Map
		Nrm: 0,					// The Normal Map
	};
let wavSpd = 1;					// Animation speed - use in main program (lower is faster)
let wavTim = 0;

//= Key Bindings ===============//===============================================
let K_Paws = 80;				        // Pause (p)
let K_Wire = 87;				        // Wireframe (w)

//= HTML OVERLAY TEXT ==========//===============================================
let Cam_AltElement = document.getElementById("Cam_Alt"); // Altitude
let Cam_AltNode = document.createTextNode("");
	Cam_AltElement.appendChild(Cam_AltNode);
let Cam_HdgElement = document.getElementById("Cam_Hdg"); // Heading
let Cam_HdgNode = document.createTextNode("");
	Cam_HdgElement.appendChild(Cam_HdgNode);
let Cam_Alt,Cam_Hdg;

/********************************************************************************
*
*	MAIN PROGRAM
*
********************************************************************************/

	loadAll();
	rendAll();

//= LOAD ALL ====================================================================

function loadAll() {
	loadSkyBox();
	loadOceans();
}

//= INITIALIZE =================//===============================================

function initAll() {
	initOceans();
	// Show stats
	if (StatOn) {				// show stats
		StatOn = new Stats();
		StatOn.setMode(0);		// FPS only
		StatOn.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(StatOn.dom);
	}
	LodFlg = 1;
}

//= RENDER ======================================================================

function rendAll() {
	requestAnimationFrame(rendAll);
	if (!PawsOn && LodFlg) {
		// Update camera position
		if(camera.position.y < 0.0) {
			camera.position.y = 2.0;
		}
		// Update time
		nowTim = clock.getElapsedTime();
		difTim = nowTim-oldTim;
		wavTim = difTim*wavSpd || 0.0;
		oldTim = nowTim;
		//
		waves.render(wavTim);			// Ocean
		if (StatOn) StatOn.update();	// Stats
	}
	prntHUDval();
	renderer.render(scene, camera);		// Render
}

/********************************************************************************
*
*	SKY BOX
*
********************************************************************************/

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(SBPath)
		.load(["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // r152
	scene.background = envMap;
}

/********************************************************************************
*
*	OCEANS
*
********************************************************************************/

//=	LOAD ========================================================================

function loadOceans() {
	//- Diffuse Texture
	txtrLoader.load(DifTxt,function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.needsUpdate = true;
		DifTxt = texture;
	});
	//- Roughness Map
	txtrLoader.load(RufMap,function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.needsUpdate = true;
		RufMap = texture;
	});
}

//= INITIALIZE =================//===============================================

function initOceans() {
	waves = new Ocean(renderer, wav_);
	WtrGeo = new THREE.PlaneGeometry(GrdSiz, GrdSiz, GrdSeg, GrdSeg);	
	WtrGeo.rotateX(-Math.PI * 0.5);
	WtrMat = new THREE.MeshPhysicalMaterial({
//		color: WtrCol,
		map: DifTxt,
		metalness: 0.0,				// 1 for max reflection (1.0)
		reflectivity: 0.5,			// 1 for max reflection (0.5)	
		roughness: 0.2,				// 0 for max reflection (0.7)
		normalMap: waves.normalMapFramebuffer.texture,
		normalScale: new THREE.Vector2(2.5,2.5),
		envMap: scene.background,
		envMapIntensity: 0.5,
		premultipliedAlpha: true,
		// Special Instructions Required for Displacement Map
		onBeforeCompile: shader => {
			shader.uniforms.dmap = {value: waves.displacementMapFramebuffer.texture};
			shader.vertexShader = `
				uniform sampler2D dmap;
				${shader.vertexShader}
			`
			.replace(
				`#include <begin_vertex>`,
				`#include <begin_vertex>
					transformed += vec3(1.0,1.0,1.0)*(texture(dmap, uv).rgb * 1.0 + 0.0);
				`
			);
		}					
	});
	// Compute Starting Z and X Values
	let zx = -0.5*(GrdRCs)*GrdSiz+0.5*GrdSiz;
	for (let i = 0; i < GrdRCs; i++) {
		WavMZV[i] = zx;
		WavMXV[i] = zx;
		zx = zx + GrdSiz;
	}
	// 4 Adjacent Planes
	let n = 0;
	for (let z = 0; z < GrdRCs; z++) {		// Row X2
		for (let x = 0; x < GrdRCs; x++) {	// Column X2
			GrdPtr[n] = new THREE.Mesh(WtrGeo,WtrMat);
			scene.add(GrdPtr[n]);
			GrdPtr[n].position.set(WavMXV[x],0,-WavMZV[z]);
			n++;
		}
	}
}

/********************************************************************************
*
*	MISC SUBROUTINES
*
********************************************************************************/

//= Converts degrees to 360 ====//===============================================

function Mod360(deg) {
	while (deg < 0) deg = deg+360; // Make deg a positive number
	deg = deg % 360;			// Compute remainder of any number divided by 360
return deg;}

/********************************************************************************
*
*	OUTPUTS
*
********************************************************************************/

//= Print HUD Values ===========//===============================================

function prntHUDval() {
	CamLat = controls.getPolarAngle();
	CamLat = 90-CamLat*RadDeg;
	CamHdg = controls.getAzimuthalAngle();
	CamHdg = Mod360(-CamHdg*RadDeg)
	CamDst = controls.getDistance();
	CamAlt = CamDst*Math.sin(CamLat*DegRad);		
	//
	Cam_Alt = Mtr2Ft*CamAlt;	// Altitude
	Cam_AltNode.nodeValue = Cam_Alt.toFixed(0);
	Cam_Hdg = CamHdg;			// Heading
	Cam_HdgNode.nodeValue = Cam_Hdg.toFixed(0);
}

/********************************************************************************
*
*	INPUTS
*
********************************************************************************/

//= Keyboard ====================================================================

//- Key Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	if (event.keyCode == K_Paws) togglePaws(); // Pause
	if (event.keyCode == K_Wire) toggleWire(); // Wireframe
}

//- Key Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	//
}

//- Toggle Pause
function togglePaws() {
	PawsOn = 1 - PawsOn;
}

//- Toggle Wire
function toggleWire() {
	WireOn = 1 - WireOn;
	if (WireOn) {
		for (let x = 0; x < 16; x++) {
			WtrMat.wireframe = true;
			WtrMat.needsUpdate = true;		
		}
	}
	else {
		for (let x = 0; x < 16; x++) {
			WtrMat.wireframe = false;
			WtrMat.needsUpdate = true;
		}
	}
}

//= Window Resize Input ========//==============================================

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
