<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>LensFlare Cam test</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
body {
	overflow: hidden;
	margin:0;
	color: black;
	font-family: Courier;
	font-size: 20pt;
	font-weight: bold;
}
</style>
</head>

<body oncontextmenu="return false;">

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.166.1/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/",
			"three/nodes": "https://unpkg.com/three@0.166.1/examples/jsm/nodes/Nodes.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import WebGPU from 'three/addons/capabilities/WebGPU.js';
import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
import Stats from "three/addons/libs/stats.module.js";
import {Lensflare, LensflareElement} from "three/addons/objects/Lensflare.js";

//= VARIABLES ==================================================================
//-	Conversions
var DegRad = Math.PI/180;		// Convert Degrees to Radians
var RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Ft2Mtr = 0.3048;			// Convert Feet to Meters (exact)
//-	Sky
let SkyCol = 0x1732c1;			// Sky
let FogCol = 0xbab4a6;			// Sky (for Fog only)
let SkyLim = 100000;			// Max viewing distance
//- Sun
let SunCol = 0xffffff;			// Sun
let SunDst = 10000;				// for shadows and lensflare
let	SunLLD = new THREE.Vector3(23,312,SunDst);	// Lat,Lon,Dst for Sun Mesh and Lensflare
let SunPos = new THREE.Vector3();
//-	Controls
let onPointerDownX, onPointerDownY, onPointerDownLon, onPointerDownLat;
//-	Stats
let stats = 0;
//- Flags
let LodFlg = 0;
let StsFlg = 1;					// Stats ((0 = off, 1 = on)
//- Misc
let V3temp = new THREE.Vector3();

//= CAMERA =====================================================================
let CamDst = 1500*Ft2Mtr;				// Distance from Center
let	CamLLD = new THREE.Vector3(SunLLD.x,SunLLD.y,CamDst);	// CamLat, CamLon, CamDst
let CamRSp = 0.5;						// Rotation speed
let CamDSp = 1;							// In/out speed
let CamRot = 180;
let PanFlg = 0;
//- Limits
let CamMxX = 90;						// Max lat
let CamMxD = CamDst * 3;				// Max distance
let CamMnD = CamDst * 0.5;				// Min distance
//- 
let	CamMsh = makMsh();					// Armature base - use to rotate camera
	CamMsh.rotation.order = "YXZ";
let CtrMsh = makMsh();					// Center of Rotation
	CtrMsh.rotation.order = "YXZ";
	CtrMsh.add(CamMsh);

//= SKYBOX =====================================================================
let SBPath = "https://threejs.org/examples/textures/cube/skyboxsun25deg/";

//=	LENSFLARE ==================================================================
let LFquat = new THREE.Quaternion();
let LFsrc0 = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let LFsrc1 = "https://threejs.org/examples/textures/lensflare/hexangle.png";
let Sp0Src = "https://threejs.org/examples/textures/sprite1.png";		// TEST
let Sp1Src = "https://threejs.org/examples/textures/sprite1.png";		// TEST
//
let LFcamR = new THREE.Vector3(0,0,0);	// Camera heading (lat/lon)
let LFsunX = new THREE.Vector3(0,0,0);	// Sun Offset (lat/lon)
//- 2 Sprites
let LFtxt0, LFtxt1 = 0;					// Textures
let LFspr0, LFspr1 = 0;					// Sprites
//
let LFspM0 = makMsh();					// Sprite rotator1
	LFspM0.position.z = -CamLLD.z;		// Same as Camera
	LFspM0.rotation.y = CamRot*DegRad;	// Same as Camera (fixed)
	CamMsh.add(LFspM0);					// Same as Camera
let LFrad0 = 100;						// Sprite0 distance from Camera
let LFsiz0 = 20;						// Scale
let LFmlt0 = -0.4;						// Offset multiplier
//
let LFspM1 = makMsh();					// Sprite rotator2
	LFspM1.position.z = -CamLLD.z;		// Same as Camera
	LFspM1.rotation.y = CamRot*DegRad;			// Same sas Camera (fixed)
	CamMsh.add(LFspM1);					// Same as Camera
let LFrad1 = 50;						// Sprite0 distance from Camera
let LFsiz1 = 50;						// Scale
let LFmlt1 = 0.4;						// Offset multiplier

//= BASIC VALUES ===============================================================
let	container = document.createElement('div');
	document.body.appendChild(container);
//- Scene
let	scene = new THREE.Scene();
//- Renderer
let renderer = new WebGPURenderer({antialias: true});	// ### WebGPU
    renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.BasicShadowMap;
	container.appendChild(renderer.domElement);
//- Lights
let sunLight = new THREE.DirectionalLight(SunCol, 3.0);
	scene.add(sunLight);
//- Camera
let	camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 1, SkyLim);
	camera.rotation.order = "YXZ";
	camera.position.z = -CamLLD.z;
	camera.rotation.y = CamRot*DegRad;			// Default = looking in at center
	CamMsh.add(camera);
	scene.add(CtrMsh);
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	renderer.domElement.addEventListener("mousedown", onMouseDown, false);
	renderer.domElement.addEventListener("mouseup", onMouseUp, false);
	renderer.domElement.addEventListener("mousemove", onMouseMove, false);
	renderer.domElement.addEventListener('mousewheel', onMouseWheel, {capture: false, passive: false});
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);

//= MAIN PROGRAM ===============================================================
	loadAll();

//= 0 LOAD ALL =================================================================
function loadAll() {
	loadSkyBox();
	loadLensFl();						// LensFlare
}

//= 1 INITIALIZE ===============================================================
function initAll() {
	initSkyBox();						// Sky, Fog and Sun
	initLensFl();						// LensFlare
	initCtrBox();
	// Show stats
	if (StsFlg) {						// show stats
		stats = new Stats();
		stats.setMode(0);				// FPS only
		stats.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(stats.dom);
	}
	LodFlg = LodFlg+1;
}

//= 2 RENDER ===================================================================
function rendAll() {
//	requestAnimationFrame(rendAll);	
	if (LodFlg == 2) {
		// Update time
		nowTim = clock.getElapsedTime();
		difTim = nowTim-oldTim;
		oldTim = nowTim;
		//
		moveLensFl();					// LensFlare
		moveCamera();
		if (StsFlg) stats.update();		// Stats
	}
	renderer.render(scene, camera);		// Render
}

//= SKY BOX ====================================================================

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(SBPath)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace;	// ### r152
	scene.background = envMap;
	LodFlg = 1;
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// SunLight Position
	SunPos = new THREE.Vector3(SunLLD.x,Mod360(180-SunLLD.y),SunLLD.z);
	SunPos = rotLLD(SunPos);	// Set Position above Light
	sunLight.position.copy(SunPos).normalize();
//	console.log(Math.round(SunPos.x),Math.round(SunPos.y),Math.round(SunPos.z));	//ok
//	console.log(sunLight.position.x,sunLight.position.y,sunLight.position.z);		//ok
}

//- Rotates Vector -------------------------------------------------------------
function rotLLD(LLD) {
	let lat = LLD.x*DegRad;
	let lon = LLD.y*DegRad;
	// Latitude
	LLD.y = LLD.z * Math.sin(lat);
	LLD.z = LLD.z * Math.cos(lat);
	// Longitude
	LLD.x = LLD.z * Math.sin(lon);
	LLD.z = LLD.z * Math.cos(lon);
	return LLD;
}

//= LENSFLARE ==================================================================

function loadLensFl() {
	LFtxt0 = txtrLoader.load(LFsrc1);	// Hex Shape
	LFtxt1 = txtrLoader.load(LFsrc1);	// Hex Shape
}

function initLensFl() {
	// Sprite 0
	let LFmat0 = new THREE.SpriteMaterial({
		map: LFtxt0,
		blending: THREE.AdditiveBlending,
		depthTest:false,
		depthWrite:false
	});
	LFspr0 = new THREE.Sprite(LFmat0);
	LFspr0.scale.set(LFsiz0,LFsiz0,1);
	LFspr0.position.z = LFrad0;
	LFspM0.attach(LFspr0);							// Attach Sprite to Rotator
	// Sprite 1
	let LFmat1 = new THREE.SpriteMaterial({
		map: LFtxt1,
		blending: THREE.AdditiveBlending,
		depthTest:false,
		depthWrite:false
	});
	LFspr1 = new THREE.Sprite(LFmat1);
	LFspr1.scale.set(LFsiz1,LFsiz1,1);
	LFspr1.position.z = LFrad1;
	LFspM1.attach(LFspr1);							// Attach Sprite to Rotator
}

function moveLensFl() {
	LFspM0.position.z = -CamLLD.z;					// Same as Camera
	LFspM1.position.z = -CamLLD.z;					// Same as Camera
	// Get Difference Between Sun and Camera Directions
	LFcamR.x = -PoM360(Mod360(CamMsh.rotation.x*RadDeg));	// Camera Lat - deg (+/-)
	LFcamR.y = Mod360(180-CamMsh.rotation.y*RadDeg);		// Camera Lon - deg (0 to 360)
//	console.log(Math.round(LFcamR.x),Math.round(LFcamR.y));	// ok
	LFsunX.x = LFcamR.x-SunLLD.x;					// Camera Lat Offset
	LFsunX.y = PoM360(Mod360(SunLLD.y-LFcamR.y));	// Camera Lat Offset
//	console.log(Math.round(LFsunX.x),Math.round(LFsunX.y)); // ok
	// Rotate Sprites
	LFspM0.rotation.x = -LFsunX.x*LFmlt0*DegRad;
	LFspM0.rotation.y = (LFsunX.y*LFmlt0+CamRot)*DegRad;
	LFspM1.rotation.x = -LFsunX.x*LFmlt1*DegRad;
	LFspM1.rotation.y = (LFsunX.y*LFmlt1+CamRot)*DegRad;
	// Visibility
	LFspr0.visible = true;	
	LFspr1.visible = true;
	// If Outside Limit, turn off
	let ratio = window.innerWidth/window.innerHeight;
	if (Math.abs(LFsunX.x) > 45 || Math.abs(LFsunX.y) > 45*ratio) {
		LFspr0.visible = false;
		LFspr1.visible = false;
	}
}

//= MAKE BOX IN CENTER =========================================================

function initCtrBox() {
	let BoxGeo = new THREE.BoxGeometry(10,10,10); 
	let BoxMat = new THREE.MeshBasicMaterial({color: 0xff0000}); 
	let BoxMsh = new THREE.Mesh(BoxGeo,BoxMat); 
	scene.add(BoxMsh)
}

//= MOVE CAMERA ================================================================

function moveCamera() {
	// In external view, the camera is facing in and the armature is pointing out:
	// * x.rotation = -CamLat
	// * y.rotation = CamLon + 180
	camera.position.z = -CamLLD.z;
	CamMsh.rotation.x = Mod360(-CamLLD.x)*DegRad;
	CamMsh.rotation.y = Mod360(180-CamLLD.y)*DegRad;
}

//= 4 MISC SUBROUTINES =========================================================

//- Converts degrees to 360
function Mod360(deg) {
	while (deg < 0) deg = deg+360;	// Make deg a positive number
	deg = deg % 360;				// Compute remainder of any number divided by 360
return deg;}

//  Converts 360 degrees to +/- 180
function PoM360(deg) {
	if (deg > 180) deg = deg-360;
return deg;}

//- Rotates Vector
function RoteV3(lon,lat,dst) {
	// Latitude
	V3temp.y = dst * Math.sin(lat);
	V3temp.z = dst * Math.cos(lat);
	// Longitude
	V3temp.x = V3temp.z * Math.sin(lon);
	V3temp.z = V3temp.z * Math.cos(lon);
return V3temp;}

function makMsh() {
	let geometry = new THREE.BoxGeometry(0.01,0.01,0.01); 
	let material = new THREE.MeshBasicMaterial({transparent:true,opacity:0}); 
	let mesh = new THREE.Mesh(geometry, material);
return mesh;}

//= 5 INPUTS ===================================================================

//= Mouse Input ================================================================

function onMouseDown(event) {
	event.preventDefault();
	PanFlg = 1;
	onPointerDownX = event.clientX;
	onPointerDownY = event.clientY;
	onPointerDownLon = CamLLD.y;
	onPointerDownLat = CamLLD.x;
}

function onMouseUp(event) {
	PanFlg = 0;
}

function onMouseMove(event) {
//- Panning View
	if (PanFlg > 0) {
		CamLLD.x = (onPointerDownY - event.clientY) * CamRSp + onPointerDownLat;
		CamLLD.x = Math.max(-CamMxX, Math.min(CamMxX, CamLLD.x));
		CamLLD.y = (event.clientX - onPointerDownX) * CamRSp + onPointerDownLon;
		CamLLD.y = Mod360(CamLLD.y);
	}
}

function onMouseWheel(event) {
	CamLLD.z = CamLLD.z + event.deltaY * CamDSp;
	CamLLD.z = Math.max(CamMnD, Math.min(CamMxD, CamLLD.z));
}

//= WINDOW RESIZE ==============================================================
function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>