<!doctype html>
<html>

<!--
Copyright 2017-23, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 27 Apr 2023
This program demonstrates how to simulate an aircraft in flight using a simplified vector-based method.
The custom files are:
AH205.txt - contains aircraft specifications which you can modify with a text editor.
AHflyt.js - contains the routines for rotating the aircraft and computing vectors.mx
PointerLockControls.mod.js - a modified version of PointerLockControls.js
-->

<head>
<title>Flight</title>
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<p>Flight Model Demo</p>
	</div>
	<div class="overlay2">
		<div>Height: <span id="AC_Hite"></span></div>
		<div>ACPtch: <span id="AC_Ptch"></span></div>
		<div>SpeedZ: <span id="AC_SpdZ"></span></div>
		<div>ACBank: <span id="AC_Bank"></span></div>
		<div>SpeedX: <span id="AC_SpdX"></span></div>	
		<div>Headng: <span id="AC_Head"></span></div>
		<div>DirFly: <span id="AC_DFly"></span></div>
	</div>
	<div class="overlay3">
		<p>
		<div><span id="On_Paws"></span></div>
		<div><span id="On_Info01"></span></div>
		<br>
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
		<div><span id="On_Info05"></span></div>
		<div><span id="On_Info06"></span></div>
		<div><span id="On_Info07"></span></div>
		<div><span id="On_Info08"></span></div>
		<div><span id="On_Info09"></span></div>
		</p>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br/>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script src="https://PhilCrowther.github.io/Aviation/models/u1h/data/AHflytGlobal.js"></script>
<script src="https://PhilCrowther.github.io/Aviation/models/u1h/data/AHdataUS.U1H.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.158.0/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import Stats from "three/addons/libs/stats.module.js";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {Lensflare, LensflareElement} from "three/addons/objects/Lensflare.js";
import {PointerLockControls} from "https://PhilCrowther.github.io/Aviation/jsm/PointerLockControls2.js";
import {init3dFlyt,move3dFlyt,Mod360,PoM360,RotVec} from "https://PhilCrowther.github.io/Aviation/jsm/FlightH.js";
import {ParticleSystem} from "https://PhilCrowther.github.io/Aviation/jsm/Smoke.js";

/* = AHFLYT VARIABLES ========================================================*/
/*	Aircraft Orientation */
//	ACBank = Aircraft Bank = Aircraft Bank relative to Horizon (0 to 360)
//	ACPtch = Aircraft Pitch = Aircraft Pitch relative to Horizon (-90 to +90)
//	ACHead = Aircraft Heading = Compass Heading of Aircraft (0 to 360)
//	ACBDif = Change in ACBank
//  AGBank = Aileron Bank on Ground
//	YawDif = Change in Yaw
//	DLTime = Frame Rate (e.g. 1/60)
//	SpdUPH = Aircraft Speed (MPH)
/*	Speed */
//	MSpdZS = Map Speed (North/South) (distance/seconds)
//	MPosXS = Map Speed (East/West)
//	MSpdZV = Map Speed (North/South) (distance/frames)
//	MPosXF = Map Speed (East/West)
/*	Position */
//	MPosZV = Map Position (North/South)
//	MPosXV = Map Position (East/West)
//	MPosYV = Altitude
/*	Ground */
//	GrFlag = 1 = on ground
/*	Math Predefined */
//	PieVal = PI (= Mth.PI)
//	DegRad = Convert Degrees to Radians (= PI / 180)
//	RadDeg = Convert Radians to Degrees (= 180 / PI)

/* = INPUT VALUES ============================================================*/
// 	Aircraft File
let ACType = "u1h";					// Name of subdirectory where model is stored
let ACFile = "u1h_flyt.glb";		// Name of aircraft model file (rotated blender file)
let VCFile = 0;						// Name of aircraft model file (rotated blender file)
let XPType = "fm2";					// Name of subdirectory where external plane model is stored
let XPFile = "fm2_flyt_xp1.glb";	// Name of aircraft model file (rotated blender file)
//	Background
let SkyLim = 100000;				// Used for Camera and SkyCube
let SkyCol = 0xa9e5ff;				// Color of Sky
let SunCol = 0xfff9ab;
let CldCol = 0xffffff;				// Cloud
//	Light
let SunLat = 90;					// Vertical position of light/sun
let SunLon = 0;						// Compass direction of light/sun
let LFFlag = 1;						// Lensflare flag
//	Camera
let VCFlag = 0;						// Default = external view
let CamPit = 10;					// Ptch - Default
let CamPmx = 45;					// Ptch - Max (down)
let CamPmn = 300;					// Ptch - Min
let CamHed = 0;						// Head - Default
let CamHmx = 100;					// Head - Max
let CamHmn = 260;					// Head - Min
//	Sound File
let acsnd1 = "xbell_rotor03a.wav";	// File (my engine)
let acvol1 = 0.3;					// Volume
let xpsnd1 = "fm2_prop.wav";		// File (xp prop)
let xpvol1 = 1.0;					// Volume
let RefDst = 25;					// Reference distance for Positional Sound
//	Flags
let PawsOn = 0;						// Pause
let InfoOn = 0;						// Info
//	Input Delay
let AltInD = 4;						// Delays Input for this many cycles
let AltInE = 4;						// Emits delay over this many cycles
let PitInD = 1;						// Delays Input for this many cycles
let PitInE = 1;						// Emits delay over this many cycles
let BnkInD = 1;						// Delays Input for this many cycles
let BnkInE = 1;						// Emits delay over this many cycles
let YawInD = 1;						// Delays Input for this many cycles
let YawInE = 1;						// Emits delay over this many cycles
//	Stats
let StsFlg = 1;						// Stats ((0 = off, 1 = on)
let stats = 0;

/* = FIXED VALUES ============================================================*/
/* = General -----------------------------------------------------------------*/
// Standard File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/" + ACType + "/";		// My Plane
let XPPath = "https://PhilCrowther.github.io/Aviation/models/vehicles" + "/";		// Other Planes
// Aircraft Animations
let anmfps = 24;					// Blender FPS
let aoarng = 20;					// AoA range (model)
// Light
let LgtClr = 0xffffff;				// Color of light/sun
let LgtInt = 1;						// Default intensity of light/sun
let LgtDst = 5000;					// [feet]
let LgtBox = 25;					// Size of shadow box
// Camera
let CamDst = 25;					// Distance from model (default)
// Input Delay
let AltInF = 1 / AltInD;			// Input allowed 
let AltInG = 1 - AltInF;			// Input delayed
let AltInH = 1 / AltInE;			// Cumulative released
let PitInF = 1 / PitInD;			// Input allowed 
let PitInG = 1 - PitInF;			// Input delayed
let PitInH = 1 / PitInE;			// Cumulative released
let BnkInF = 1 / BnkInD;			// Input allowed 
let BnkInG = 1 - BnkInF;			// Input delayed
let BnkInH = 1 / BnkInE;			// Cumulative released
let YawInF = 1 / YawInD;			// Input allowed 
let YawInG = 1 - YawInF;			// Input delayed
let YawInH = 1 / YawInE;			// Cumulative released
// Altitude Adjustment
let AltAdj = 0.96;					// Raises objects above map as altitude
/* = My Aircaft --------------------------------------------------------------*/
// Aircraft Animations
// Mixers - Aircraft
let mxRtrB = 0;						// Main Rotor - Blades
let mxRtrP = 0;						// Main Rotor - Pitch
let mxRtrK = 0;						// Main Rotor - Bank
let mxRtrV = 0;						// Main Rotor - Vertical
let mxRtrT = 0;						// Tail Rotor
let mxDorL = 0;						// Main Doors - Left
let mxDorR = 0;						// Main Doors - Right
// All range from 0 to 360 with center at 180
let pitprp = 180;					// Main Rotor - Pitch
let bnkprp = 180;					// Main Rotor - Bank
let spnprp = 180;					// Main Rotor - Spin
let spnrtr = 180;					// Tail Rotor - Spin (not used)
let doormn = 0;						// Main Doors
// CVE
// Mixers
let mxCVf1 = 0;						// flag01
let mxCVf2 = 0;						// flag02
let mxCVf3 = 0;						// flag03
let mxCVf4 = 0;						// flag04
let mxCVf5 = 0;						// flag05
let mxCVf6 = 0;						// flag06
let mxCVf7 = 0;						// flag07
let mxCVrd = 0;						// radar
// Values
let CVflag = 180;					// flag
let CVradr = 180;					// radar

/* = GRID DATA ===============================================================*/
let GrdSiz = 2000;						// Small Grid Squares
// Textures --------------------------------------------------------------------
let ImgSrc = ["https://PhilCrowther.github.io/Aviation/textures/ocean/ocean00_512.png"];
let WtrTxt = 0;							// Pointer to Material
let BmpSrc = ["https://PhilCrowther.github.io/Aviation/textures/ocean/oceanBW_512.png"];
let WtrBmp = 0;							// Pointer to Bump Map
/* = Ground Squares ==========================================================*/
// Layer 1 constains smaller higher definition squares
// Layer 2 contains larger lower definition squares (3X size of Layer 1 squares)
/* = Both Grids --------------------------------------------------------------*/
let Grd0 = {
		Siz:	GrdSiz,				// Size of Smallest Grid Square
		Stp:	3,					// Size of Outer Grid / Size of Inner Grid
		NSA:	0,					// Shared North/South Adjustment (updated)
		EWA:	0,					// Shared East/West Adjustment (updated)
		MSZ:	0,					// Map ZSpeed (updated by program)
		MSX:	0,					// Map XSpeed (updated by program)
		MPY:	0,					// Aircraft Altitude (updated by program)
		Mat:	0					// Material
	}
/* = Inner Grid --------------------------------------------------------------*/
let Grd1 = {
		Typ:	0,					// Type of Grid - Inner or Outer
		RCs:	27,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	Grd0.Siz,			// Size of square
		Stp:	Grd0.Stp,			// Steps
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	0					// Outer Grid Only
	}
/* = Outer Grid --------------------------------------------------------------*/
let Grd2 = {
		Typ:	1,					// Type of Grid - Inner or Outer
		RCs:	27,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	Grd0.Siz*Grd0.Stp,	// Size of square
		Stp:	1,					// Steps
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	0,					// Shadow enabled
		RCF:	Grd1.RCs/Grd0.Stp	// Cut-Out Area
	}
/* = Objects -----------------------------------------------------------------*/
let ObjNum = 5;						// number of objects
let ObjTyp = [0];					// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];					// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];					// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];					// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];					// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];					// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];					// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];					// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
// Hangars
let ObjIdx = 0;
	ObjTyp[ObjIdx] = 0;				// 0 = Fixed standard object
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 200;			// [ft]
	ObjMPY[ObjIdx] = 29;			// [ft]
	ObjMPZ[ObjIdx] = 2100;			// [ft]
	ObjIdx++;
// Homebase
	ObjTyp[ObjIdx] = 1;				// 1 = Fixed large object
	ObjNam[ObjIdx] = "homebase";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/homebase_ctr0.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/textures/homebase.png";
	ObjMPX[ObjIdx] = 2000;			// [ft]
	ObjMPY[ObjIdx] = 100;			// [ft]
	ObjMPZ[ObjIdx] = 900;			// [ft]
	ObjIdx++;
// Giaros Island
	ObjTyp[ObjIdx] = 1;				// 1 = Fixed - large feature
	ObjNam[ObjIdx] = "giaro";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/textures/giaros.png";
	ObjMPX[ObjIdx] = -5280;			// [ft]
	ObjMPY[ObjIdx] = 2;				// [ft]
	ObjMPZ[ObjIdx] = 8000;			// [ft]
	ObjIdx++;
// CVE
	ObjTyp[ObjIdx] = 21;			// 21 = Moving - ground vehicle
	ObjNam[ObjIdx] = "CVE";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/vehicles/CVE.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = -10000;		// [ft]
	ObjMPY[ObjIdx] = 0.2;			// [ft]
	ObjMPZ[ObjIdx] = 480;			// [ft]
	ObjIdx++;
// Aircraft
	ObjTyp[ObjIdx] = 12;			// 31 = Moving - air vehicle
	ObjNam[ObjIdx] = "FM2";
	ObjMdl[ObjIdx] = XPPath + XPFile;
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 500;			// [ft]
	ObjMPY[ObjIdx] = 300;			// [ft]
	ObjMPZ[ObjIdx] = 1000;			// [ft]
/* = Moving Objects ----------------------------------------------------------*/
// Ship
let	XSSped = 30;					// Speed [f/s]
let XSHead = 0;						// Heading
let XSBank = 0;						// Bank
let XSPtch = 0;						// Pitch
let XSSpdZ = 0;						// 
let XSSpdX = 0;
// Plane
let	XPSped = 300;					// Speed [f/s]
let XPHead = 0;						// Heading
let XPPtch = 0;						// Pitch
let XPBank = 30;					// Bank
let mixXPS = 0;						// Propeller
let mixXPP = 0;
let mixXPB = 0;
let PtchXP = 0;
let BankXP = 0;
// Ship Wake
let WakPtr = 0;						// Address
let WakPts = 2000;					// Number of points
let WakPos = [];					// Psition
let WakCol = [];					// Color
let WakFad = 0.8;					// Rate of fade
let WakLim = 1000;					// Max distance of wake
let WakViz = 5000;					// Max visibility range
if (USorSI == "US") {				// Convert to meters
	WakLim = WakLim*Ft2Mtr;
	WakViz = WakViz*Ft2Mtr;
}
/* = Minimum Altitude --------------------------------------------------------*/
// Base (Centered at 0,0)
let BasAlt = 29;					// [feet]
let BasXlf = -61;					// [meters]
let BasXrt = 61;					// 200 ft
let BasZfr = 2260;					// 7420 ft
let BasZbk = -154;					// -505 ft
// CVE (Centered at CVE Group)
let CVEAlt = 43.267;				// [feet]
let CVEXlf = -13.2;					// [meters]
let CVEXrt = 13.2;
let CVEZfr = 70.5;
let CVEZbk = -70.5;
let SpXdif, SpZdif;

/* = VARIABLES ===============================================================*/
// Key Inputs
let InpAlt = 0;						// Power
let InpACP = 0;						// Pitch
let InpACB = 0;						// Bank (rotation rate)
let InpYaw = 0;						// Yaw
// Mouse Inputs (Mousewheel Only)
let MosWDf = 0;						// Power
// SkyCube
let envMap = 0;
// Objects
let mesh, geometry, material, texture, textbmp, sprite, fname;
let prprot = 0;						// Prop/Engine rotation
// Camera
let CamLat = 10;
let CamLon = 0;
let CamLax = 80;					// Max/Min Lat in Pan View
let PanFlg = 0;
// Camera Tracking
let PitLim = 25;
let PitDky = 0.999;
let PitOld = 0;
let PitCum = 0;
// Sound
let SndFlg = 0;
// View Keys
let U45flg = 0;						// Up 45 degrees
let D45flg = 0;						// Down 45 degrees
let	L45flg = 0;						// Left 45 degrees
let R45flg = 0;						// Right 45 degrees
let L90flg = 0;						// Left 90 degrees
let R90flg = 0;						// Right 90 degrees
//
let ACHrad = 0;

/* = WebGL Values ============================================================*/
// Display
const scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
const renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.outputColorSpace = THREE.SRGBColorSpace;	// ### r152
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
//	renderer.shadowMap.type = THREE.PCFShadowMap;				// SHADOW (default)
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
// Light
let DirLight = new THREE.DirectionalLight(LgtClr, LgtInt);
	DirLight.castShadow = true;
	DirLight.target.position.set(0,0,0);
	DirLight.shadow.bias = -0.00005;					// Defaul = 0 - causes lines;
	DirLight.shadow.mapSize.width = 8192;
	DirLight.shadow.mapSize.height = 8192;
	DirLight.shadow.camera.near = 0.001;
	DirLight.shadow.camera.far = LgtDst+LgtBox;
	DirLight.shadow.camera.left = -LgtBox;
	DirLight.shadow.camera.right = LgtBox;
	DirLight.shadow.camera.top = LgtBox;
	DirLight.shadow.camera.bottom = -LgtBox;
	scene.add(DirLight);
const AmbLight = new THREE.AmbientLight(LgtClr, 0.075);
	scene.add(AmbLight);
// const helper = new THREE.DirectionalLightHelper(light);
// const helper = new THREE.CameraHelper(DirLight.shadow.camera);
//	scene.add(helper);
// Sounds
let	listener = new THREE.AudioListener();
let sound1 = new THREE.PositionalAudio(listener);
let sound2 = new THREE.PositionalAudio(listener);
let sound3 = new THREE.PositionalAudio(listener);
let sound4 = new THREE.PositionalAudio(listener);
let EngObj = new THREE.Object3D();								// Aircraft Engine
	EngObj.add(sound1);											// Engine
	EngObj.add(sound2);											// Guns
	EngObj.add(sound3);											// Prop
//	EngObj.position.z = -5;
// Camera
let	camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.4, SkyLim);
	camera.rotation.order = "YXZ";
	camera.add(listener);
let CamObj = new THREE.Object3D();
	CamObj.add(camera);
	CamObj.add(EngObj);											// Engine Sounds
	scene.add(CamObj);
	CamObj.rotation.order = "YXZ";
// Clock
var state = {
    clock: new THREE.Clock(),
    frame: 0,
    maxFrame: 90,
    fps: 60, // capping at 60 fps
    per: 0
};
// Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener('mousewheel', onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
// Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
let audioLoader = new THREE.AudioLoader(loadingManager);
// Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;		//keep = 0
//
let isUserInteracting = false;	// Initial value

/* Pointer Lock (updated to r136) ------------------------------------------- */
//let controls = new PointerLockControls(camera, document.body);
let controls = new PointerLockControls(camera, renderer.domElement);
let blocker = document.getElementById('blocker');
let instructions = document.getElementById('instructions');
	instructions.addEventListener('click', function () {controls.lock();}, false);
	controls.addEventListener( 'lock', function () {
		instructions.style.display = 'none';
		blocker.style.display = 'none';
	});
	controls.addEventListener('unlock', function () {
		blocker.style.display = 'block';
		instructions.style.display = '';
	});

/* = 3D OBJECTS AND LINKS ====================================================*/
let ACMine = 0;						// My Aircraft
let VCMine = 0;						// My Virtual Cockpit
// CVE Group
let CVEGrp = new THREE.Group();				// To hold ACMine and VCMine
	CVEGrp.rotation.order = "YXZ";
	scene.add(CVEGrp);					// CVEGrp => (CVE + WakPtr)
// Other Pointers
let CldPtr = 0;
let CldTxt = 0;							// Clouds - Alpha Map
let SunPtr = 0;
let LF0Txt = 0;							// Lensflare Textures
let LF1Txt = 0;

/* = HTML OVERLAY TEXT =======================================================*/

let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
AC_HiteElement.appendChild(AC_HiteNode);
let AC_PtchElement = document.getElementById("AC_Ptch");
let AC_PtchNode = document.createTextNode("");
AC_PtchElement.appendChild(AC_PtchNode);
let AC_SpdZElement = document.getElementById("AC_SpdZ");
let AC_SpdZNode = document.createTextNode("");
AC_SpdZElement.appendChild(AC_SpdZNode);
let AC_BankElement = document.getElementById("AC_Bank");
let AC_BankNode = document.createTextNode("");
AC_BankElement.appendChild(AC_BankNode);
let AC_SpdXElement = document.getElementById("AC_SpdX");
let AC_SpdXNode = document.createTextNode("");
AC_SpdXElement.appendChild(AC_SpdXNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
AC_HeadElement.appendChild(AC_HeadNode);
let AC_DFlyElement = document.getElementById("AC_DFly");
let AC_DFlyNode = document.createTextNode("");
AC_DFlyElement.appendChild(AC_DFlyNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
On_PawsElement.appendChild(On_PawsNode);
let On_Info01Element = document.getElementById("On_Info01");
let On_Info01Node = document.createTextNode("");
On_Info01Element.appendChild(On_Info01Node);
let On_Info02Element = document.getElementById("On_Info02");
let On_Info02Node = document.createTextNode("");
On_Info02Element.appendChild(On_Info02Node);
let On_Info03Element = document.getElementById("On_Info03");
let On_Info03Node = document.createTextNode("");
On_Info03Element.appendChild(On_Info03Node);
let On_Info04Element = document.getElementById("On_Info04");
let On_Info04Node = document.createTextNode("");
On_Info04Element.appendChild(On_Info04Node);
let On_Info05Element = document.getElementById("On_Info05");
let On_Info05Node = document.createTextNode("");
On_Info05Element.appendChild(On_Info05Node);
let On_Info06Element = document.getElementById("On_Info06");
let On_Info06Node = document.createTextNode("");
On_Info06Element.appendChild(On_Info06Node);
let On_Info07Element = document.getElementById("On_Info07");
let On_Info07Node = document.createTextNode("");
On_Info07Element.appendChild(On_Info07Node);
let On_Info08Element = document.getElementById("On_Info08");
let On_Info08Node = document.createTextNode("");
On_Info08Element.appendChild(On_Info08Node);
let On_Info09Element = document.getElementById("On_Info09");
let On_Info09Node = document.createTextNode("");
On_Info09Element.appendChild(On_Info09Node);

let AC_Hite, AC_Ptch, AC_SpdZ, AC_Bank, AC_SpdX, AC_Head, AC_DFly;
let On_Paws, On_Info01, On_Info02, On_Info03, On_Info04, On_Info05, On_Info06, On_Info07, On_Info08;

/* = PARTICLE SYSTEM =========================================================*/
let timeElapsed = 0;
let previousRAF = null;
let NPSPtr = 0;
//	window.addEventListener("DOMContentLoaded", initPrtSys, false);


/* = Main Programs ===========================================================*/

	loadAll();
	rendAll();

/* 0 Load All ================================================================*/

function loadAll() {
	WaitScreen();						// load loading screen
	loadGrdMap();
	loadSkyBox();
	loadObject();						// load objects	
	initShpWak();
	init3dFlyt();						// initalize variables
	loadACMine();						// load airplane model
	window.addEventListener("DOMContentLoaded", initPrtSys, false);
}

/* Wait Screen ===============================================================*/

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	geometry = new THREE.PlaneGeometry(1,1);
	texture = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	material = new THREE.MeshBasicMaterial({map: texture});
	loadingScreen.box = new THREE.Mesh(geometry, material);
	loadingScreen.box.rotation.set(PieVal,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

/* = Initialize ==============================================================*/

function initAll() {
	// MPosYV set in init3dFlyt, but somehow overwritten in loading process
//	if (GrFlag > 0) MPosYV = BegAGL + GrdAlt;
	Grd0.MPY = MPosYV;
	if (USorSI == "US") Grd0.MPY = MPosYV*Ft2Mtr;
	initGrdMap(Grd1);					// Inner Grid
	initGrdMap(Grd2);					// Outer Grid
	initObject();						// Make Visible
	initSkyBox();
	moveCamera();						// position camera
	noPause();
	noInfo();
	chngHUDV();							// change HUD value
	// Show stats
	if (StsFlg > 0) {					// show stats
		stats = new Stats();
		stats.setMode(0);				// FPS only
		stats.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(stats.dom);
	}
//	window.addEventListener("DOMContentLoaded", initPrtSys, false);
	state.clock.start();
}

/* Load SkyBox ===============================================================*/

function loadSkyBox() {
	// Cloud Alpha
	CldTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/fx/cloudtrans.png");
	// LensFlare
	LF0Txt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/fx/lensflare1.png");
	LF1Txt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/fx/hexangle.png");
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	scene.background = new THREE.Color(SkyCol);
	// Fog (doesn't work with Normal Material)
	let fogColor = new THREE.Color(SkyCol);
	scene.fog = new THREE.Fog(fogColor, 0.25, 95000);	// less than camera distance, sky colored fog
	// Sun Light
	RotVec(1000,SunLat*DegRad,SunLon*DegRad);		// Set Position of Sun
	DirLight.position.set(VectRX,VectRY,VectRZ);
	// Sun Object
	geometry = new THREE.SphereGeometry(64, 16, 16);
	material = new THREE.MeshBasicMaterial({color: SunCol});
	SunPtr = new THREE.Mesh(geometry, material);
	scene.add(SunPtr);
	RotVec(5000,SunLat*DegRad,SunLon*DegRad);		// Set Position above Light
	SunPtr.position.set(VectRX,VectRY,VectRZ);
	// Cloud Plane
	geometry = new THREE.PlaneGeometry(150000,150000);
	material = new THREE.MeshBasicMaterial({
		color: CldCol,
		alphaMap: CldTxt,
		transparent: true,
		depthWrite: false
	});	
	CldPtr = new THREE.Mesh(geometry,material);
	CldPtr.rotation.order = "YXZ";
	CldPtr.rotation.x = 90*DegRad;
	CldPtr.rotation.y = 180*DegRad;
	CldPtr.position.y = 5000; 
	scene.add(CldPtr);
	// LensFlare
	let LF = new Lensflare();
	LF.addElement(new LensflareElement(LF0Txt, 512, 0));
	LF.addElement(new LensflareElement(LF1Txt, 32, 0.2));
	LF.addElement(new LensflareElement(LF1Txt, 64, 0.5));
	LF.addElement(new LensflareElement(LF1Txt, 256, 0.9));
	DirLight.add(LF);
}

/* Render ====================================================================*/

// Move and Draw Objects
function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		requestAnimationFrame(rendAll);		
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(PieVal,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;													// Stop the function here.
	}
	requestAnimationFrame(rendAll);
	if (PawsOn == 0 && controls.isLocked === true) {
		// Rolling Average (10 items)
		DLTime = 1/60;					// ### Until we fix overspeed
		// Move Everything Along Map
		moveACMine();					// Move aircaft
		moveObject();					// Move objects
		moveShpWak();
		movePrtSys();
		moveMinAlt();
		// Move Maps
		Grd0.MSZ = MSpdZV;				// Update Common Grid Data
		Grd0.MSX = MSpdXV;
		Grd0.MPY = MPosYV;
		if (USorSI == "US") {			// Convert to meters
			Grd0.MSZ = MSpdZV*Ft2Mtr;
			Grd0.MSX = MSpdXV*Ft2Mtr;
			Grd0.MPY = MPosYV*Ft2Mtr;
		}
		moveGrdMap(Grd1);				// Move Inner Grid
		moveGrdMap(Grd2);				// Move Outer Grid
		//
		moveCamera();
		moveSounds();
		chngHUDV();						// change HUD value
		if (StsFlg > 0) stats.update();	// update stats
	}
	renderer.render(scene, camera);
}

/* Flat Moving Map ===========================================================*/

function loadGrdMap() {
	txtrLoader.load(ImgSrc, function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.needsUpdate = true;
		WtrTxt = texture;
	});
	// Bump Maps
	txtrLoader.load(BmpSrc, function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.needsUpdate = true
		WtrBmp = texture;
	});
}

function initGrdMap(Grd) {
	let n, v;
	// Load Variables
	Grd.RCi = Grd.RCs-1;			// Max Index Value
	Grd.MZV[Grd.RCi] = 0;			// Z-Values
	Grd.MXV[Grd.RCi] = 0;			// X-Values
	Grd.Nor = Grd.RCi;				// Max North Square (updated)
	Grd.Est = Grd.RCi;				// Max East Square (updated)
	Grd.Num = Grd.RCs * Grd.RCs;	// Size of array
	Grd.Ptr[Grd.Num-1] = 0;			// Mesh Pointers
	// Compute Starting Z and X Values
	n = 0;
	let zx = -0.5*(Grd.RCs)*Grd.Siz+0.5*Grd.Siz;
	for (let i = 0; i < Grd.RCs; i++) {
		Grd.MZV[i] = zx;
		Grd.MXV[i] = zx;
		zx = zx + Grd.Siz;
	}
	// Load Texture - Same for All
	let rpt = 8;
	if (Grd.Typ == 1) {
		Grd0.NSA = (Grd.RCs-Grd.RCF)/2;
		Grd0.EWA = Grd0.NSA;
		rpt = rpt*Grd0.Stp;
	}
	geometry = new THREE.PlaneGeometry(Grd.Siz, Grd.Siz);
	texture = WtrTxt;
	texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
	texture.offset.set(0,0);
	texture.repeat.set(rpt,rpt);
	textbmp = WtrBmp;
	textbmp.wrapS = textbmp.wrapT = THREE.RepeatWrapping;
	textbmp.offset.set(0,0);
	textbmp.repeat.set(rpt,rpt);
	material = new THREE.MeshPhongMaterial({map: texture, bumpMap: textbmp});
	for (let n = 0; n < Grd.Num; n++) {
		mesh = new THREE.Mesh(geometry,material);
		if (Grd.Shd == 1) mesh.receiveShadow = true;
		Grd.Ptr[n] = mesh;
	}
	// Set Starting Position of Squares
	n = 0;
	for (let r = 0; r < Grd.RCs; r++) {		// Row
		for (let c = 0; c < Grd.RCs; c++) {	// Column
			Grd.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Grd.Ptr[n]);
			Grd.Ptr[n].position.set(Grd.MXV[c],-Grd0.MPY,-Grd.MZV[r]);
			n++;
		}
	}
}

// Move Grid Map
function moveGrdMap(Grd) {
	let j, v, n;
	let max = 0.5*Grd.RCs*Grd.Siz;
	let min = -max;
	// Update Z, X and Y-Values
	for (let i = 0; i < Grd.RCs; i++) {
		Grd.MZV[i] = Grd.MZV[i] - Grd0.MSZ;	// Rows
		Grd.MXV[i] = Grd.MXV[i] - Grd0.MSX;	// Columns
	}
	// Test North/South
	if (Grd0.MSZ < 0) {					// If Moving South
		j = Grd.Nor;
		if (Grd.MZV[j] >= max) {
			v = min+(Grd.MZV[j]-max);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Grd.RCi;
				v = v - Grd.Siz;
			}
			Grd.Nor = Grd.Nor - Grd.Stp;
			if (Grd.Nor < 0) Grd.Nor = Grd.Nor + Grd.RCs;
			if (Grd.Typ == 1) Grd0.NSA = Grd0.NSA + 1;
			else Grd0.NSA = Grd0.NSA - 1;
		}
	}
	if (Grd0.MSZ > 0) {				// If Moving North
		j = Grd.Nor + 1;
		if (j > Grd.RCi) j = 0;
		if (Grd.MZV[j] <= min) {
			v = max-(min-Grd.MZV[j]);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MZV[j] = v;
				j++;
				if (j > Grd.RCi) j = 0;
				v = v + Grd.Siz;
			}
			Grd.Nor = Grd.Nor + Grd.Stp;
			if (Grd.Nor > Grd.RCi) Grd.Nor = Grd.Nor - Grd.RCs;
			if (Grd.Typ == 1) Grd0.NSA = Grd0.NSA - 1;
			else Grd0.NSA = Grd0.NSA + 1;
		}
	}
	// Test East/West
	if (Grd0.MSX < 0) {				// If Moving West
		j = Grd.Est;
		if (Grd.MXV[j] >= max) {
			v = min+(Grd.MXV[j]-max);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Grd.RCi;
				v = v - Grd.Siz;
			}
			Grd.Est = Grd.Est - Grd.Stp;
			if (Grd.Est < 0) Grd.Est = Grd.Est + Grd.RCs;
			if (Grd.Typ == 1) Grd0.EWA = Grd0.EWA + 1;
			else Grd0.EWA = Grd0.EWA - 1;
		}
	}
	if (Grd0.MSX > 0) {				// If Moving East
		j = Grd.Est + 1;
		if (j > Grd.RCi) j = 0;	
		if (Grd.MXV[j] <= min) {
			v = max-(min-Grd.MXV[j]);
			for (let i = 0; i < Grd.Stp; i++) {			
				Grd.MXV[j] = v;
				j = j + 1;
				if (j > Grd.RCi) j = 0;
				v = v + Grd.Siz;
			}
			Grd.Est = Grd.Est + Grd.Stp;
			if (Grd.Est > Grd.RCi) Grd.Est = Grd.Est - Grd.RCs;
			if (Grd.Typ == 1) Grd0.EWA = Grd0.EWA - 1;
			else Grd0.EWA = Grd0.EWA + 1;
		}
	}
	// Set Position
	n = 0;
	for (let r = 0; r < Grd.RCs; r++) {	// Row
		for (let c = 0; c < Grd.RCs; c++) {	// Col
			Grd.Ptr[n].position.set(Grd.MXV[c],-Grd0.MPY,-Grd.MZV[r]);
			Grd.Ptr[n].visible = true;	// Default for Outer Grid
			n++;
		}
	}
	// Outer Grid Only - Make Cut-Out Area Invisible
	if (Grd.Typ == 1) {
		let r = Grd.Nor + 1 + Grd0.NSA;	// Get Lower index
		if (r > Grd.RCi) r = r - Grd.RCs;
		let c = Grd.Est + 1 + Grd0.EWA;	// Get Left Index
		if (c > Grd.RCi) c = c - Grd.RCs;
		for (let i = 0; i < Grd.RCF; i++) {
			n = r * Grd.RCs + c;
			if (n < 0) n = n + Grd.Num;
			if (n > Grd.Num) n = n - Grd.Num;
			let n2 = (r+1) * Grd.RCs - 1;
			if (n2 > Grd.Num) n2 = n2 - Grd.Num;
			if (n2 < 0) n2 = n2 + Grd.Num;
			for (let j = 0; j < Grd.RCF; j++) {
				Grd.Ptr[n].visible = false;
				n = n + 1;
				if (n > n2) n = n - Grd.RCs; 
				if (n < 0) n = n + Grd.Num;
				if (n > Grd.Num) n = n - Grd.Num;
			}
			r++;
			if (r > Grd.RCi) r = r - Grd.RCs;
		}
	}
}

/* Load and Move Fixed Objects ====================================================*/
/* These objects include the airfield, islands and hangar */

// Load Objects
function loadObject() {
	for (let i = 0; i < ObjNum; i++) {
		// General Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		// Island
		if (ObjTyp[i] == 1) {
			txtrLoader.load(ObjTxt[i], function (texture) {	
				let mat = new THREE.MeshLambertMaterial({map: texture, transparent: true});
				gltfLoader.load(ObjMdl[i], function (gltf) {
					gltf.scene.traverse(function (child) {
					// Note: Blender object must include a UV map
						if (child.isMesh) {
							child.material = mat;				// temporary variable prevents cross-contamination				
							child.receiveShadow = true;			// works but creates problems with smoke
						}
					});
					ObjPtr[i] = gltf.scene;
					let s = 5280;
					if (USorSI == "US") s = s*Ft2Mtr;	// Convert to meters
					ObjPtr[i].scale.set(s,s,s);
					ObjPtr[i].rotation.order = "ZXY";	// Bank, Pitch, Heading
				});
			});
		}
		if (ObjNam[i] == "CVE") loadBXSCVE(i);
		if (ObjNam[i] == "FM2") loadBXPPln(i);
	}
}

// Load CVE
function loadBXSCVE(n) {
	gltfLoader.load(ObjMdl[n], function (gltf) {
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
		});
		ObjPtr[n] = gltf.scene;
		// Set Scale
		if (USorSI == "US") ObjPtr[n].scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		// Animated Flag	
		// Flag1
		let clip = THREE.AnimationClip.findByName(gltf.animations, "Flag01Action");
		mxCVf1 = new THREE.AnimationMixer(ObjPtr[n]);
		let actun = mxCVf1.clipAction(clip);
		actun.play();
		if (mxCVf1) mxCVf1.setTime(CVflag/anmfps);
		// Flag2
		clip = THREE.AnimationClip.findByName(gltf.animations, "Flag02Action");
		mxCVf2 = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVf2.clipAction(clip);
		actun.play();
		if (mxCVf2) mxCVf2.setTime(CVflag/anmfps);
		// Flag3
		clip = THREE.AnimationClip.findByName(gltf.animations, "Flag03Action");
		mxCVf3 = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVf3.clipAction(clip);
		actun.play();
		if (mxCVf3) mxCVf3.setTime(CVflag/anmfps);
		// Flag4
		clip = THREE.AnimationClip.findByName(gltf.animations, "Flag04Action");
		mxCVf4 = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVf4.clipAction(clip);
		actun.play();
		if (mxCVf4) mxCVf4.setTime(CVflag/anmfps);
		// Flag5
		clip = THREE.AnimationClip.findByName(gltf.animations, "Flag05Action");
		mxCVf5 = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVf5.clipAction(clip);
		actun.play();
		if (mxCVf5) mxCVf5.setTime(CVflag/anmfps);
		// Flag6
		clip = THREE.AnimationClip.findByName(gltf.animations, "Flag06Action");
		mxCVf6 = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVf6.clipAction(clip);
		actun.play();
		if (mxCVf6) mxCVf6.setTime(CVflag/anmfps);
		// Flag7
		clip = THREE.AnimationClip.findByName(gltf.animations, "Flag07Action");
		mxCVf7 = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVf7.clipAction(clip);
		actun.play();
		if (mxCVf7) mxCVf7.setTime(CVflag/anmfps);
		// Animated Radar
		clip = THREE.AnimationClip.findByName(gltf.animations, "RadarAction");
		mxCVrd = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mxCVrd.clipAction(clip);
		actun.play();
		if (mxCVrd) mxCVrd.setTime(CVradr/anmfps);
		//
		ObjPtr[n].position.set(0,0,0);	// position within group is always 0,0,0
	});
}

// Load Plane
function loadBXPPln(n) {
	gltfLoader.load(ObjMdl[n], function (gltf) {
		ObjPtr[n] = gltf.scene;
		// Convert from feet to meters
		if (USorSI == "US") ObjPtr[n].scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		// Propeller
		let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
		mixXPS = new THREE.AnimationMixer(ObjPtr[n]);
		let actun = mixXPS.clipAction(clip);
		actun.play();
		if (mixXPS) mixXPS.setTime(spnprp/anmfps);
		// Bank
		clip = THREE.AnimationClip.findByName(gltf.animations, "AC_BankAction");
		mixXPB = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mixXPB.clipAction(clip);
		actun.play();
		if (mixXPB) mixXPB.setTime(BankXP/anmfps);
		// Pitch
		clip = THREE.AnimationClip.findByName(gltf.animations, "AC_PtchAction");
		mixXPP = new THREE.AnimationMixer(ObjPtr[n]);
		actun = mixXPP.clipAction(clip);
		actun.play();
		if (mixXPP) mixXPP.setTime(PtchXP/anmfps);
		// Rotation
		ObjPtr[n].rotation.order = "YXZ";	// Heading, Pitch, Bank
		ObjPtr[n].rotation.y = XPHead*DegRad;
		//
		ObjPtr[n].add(sound4);				// Engine sound
	});
}

// Initialize Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above water as we climb to prevent flicker)
		let X = ObjMPX[i]-MPosXV;
		let Y = ObjMPY[i]-MPosYV*.99;
		let Z = MPosZV-ObjMPZ[i];
		if (USorSI == "US") {
			X = X*Ft2Mtr;
			Y = Y*Ft2Mtr;
			Z = Z*Ft2Mtr;
		}
		if (ObjNam[i] == "CVE") {
			CVEGrp.position.set(X,Y,Z);
			CVEGrp.add(ObjPtr[i]);
		}				
		else {
			ObjPtr[i].position.set(X,Y,Z);
			scene.add(ObjPtr[i]);
		}
	}
}

/* Move Objects --------------------------------------------------------------*/

function moveObject() {
	// Position of Objects Relative to My Plane
	// Cause Objects to elevate by 0.01 of my altitude to avoid flicker.
	for (let i = 0; i < ObjNum; i ++) {
		if (ObjNam[i] == "CVE") moveBXSCVE(i);		// Moving Carrier
		if (ObjNam[i] == "FM2") moveBXPPln(i);		// Moving Aircraft
		// Set Position
		let X = ObjMPX[i]-MPosXV;
		let Y = ObjMPY[i]-MPosYV*.99;
		let Z = MPosZV-ObjMPZ[i];
		if (USorSI == "US") {
			X = X*Ft2Mtr;
			Y = Y*Ft2Mtr;
			Z = Z*Ft2Mtr;
		}
		if (ObjNam[i] == "CVE") CVEGrp.position.set(X,Y,Z);
		else {ObjPtr[i].position.set(X,Y,Z);}
	}
}

// Move Carrier
function moveBXSCVE(n) {
	// Rotation
	let XSHSpd = 0;						// for now
	XSHSpd = XSHSpd * DLTime;
	XSHead = XSHead + XSHSpd;
	CVEGrp.rotation.set(XSPtch*DegRad,XSHead*DegRad,XSBank*DegRad);
	// Speed (Only Horizontal for Now)
	let SpdTim = XSSped * DLTime;		// Speed (u/t)
	XSSpdZ = -SpdTim * Math.cos(XSHead * DegRad);
	XSSpdX = -SpdTim * Math.sin(XSHead * DegRad);
	// Position
	ObjMPZ[n] = ObjMPZ[n] + XSSpdZ;
	ObjMPX[n] = ObjMPX[n] - XSSpdX;
	// Animation - Flag
	CVflag = CVflag + 1;
	if (CVflag > 359) CVflag = 0;		// A complete cycle
	if (mxCVf1) mxCVf1.setTime(CVflag/anmfps);
	if (mxCVf2) mxCVf2.setTime(CVflag/anmfps);
	if (mxCVf3) mxCVf3.setTime(CVflag/anmfps);
	if (mxCVf4) mxCVf4.setTime(CVflag/anmfps);
	if (mxCVf5) mxCVf5.setTime(CVflag/anmfps);
	if (mxCVf6) mxCVf6.setTime(CVflag/anmfps);
	if (mxCVf7) mxCVf7.setTime(CVflag/anmfps);
	// Animation - Radar
	CVradr = CVradr - 0.1;
	if (CVradr < 0) CVradr = 359;
	if (mxCVrd) mxCVrd.setTime(CVradr/anmfps);
}

// Move Aircraft
function moveBXPPln(n) {
	// Rotation
	let XPHSpd = Math.tan(XPBank*DegRad)*XPSped/GrvUPS;
	XPHSpd = XPHSpd * DLTime;
	XPHead = XPHead + XPHSpd;
	ObjPtr[n].rotation.set(0,XPHead*DegRad,XPBank*DegRad);
	// Speed (Only Horizontal for Now)
	let SpdTim = XPSped * DLTime;		// Speed (u/t)
	let SpeedZ = -SpdTim * Math.cos(XPHead * DegRad);
	let SpeedX = -SpdTim * Math.sin(XPHead * DegRad);
	// Position
	ObjMPX[n] = ObjMPX[n] + SpeedX;
	ObjMPZ[n] = ObjMPZ[n] - SpeedZ;
	// Animation - Prop (same as mine)
	if (mixXPS) mixXPS.setTime(spnprp/anmfps);
}

/* Ship Wake =================================================================*/

function initShpWak() {
	// Make 2 Trails of Random Particles
	let x,y,z;
	let a = 25;		// meters
	for (let i = 0; i < WakPts; i++) {
	// create a particle with random position values, -250 -> 250
		x = Math.random() * (16 - 8 + a)*Ft2Mtr;	// +/-8
		y = Math.random() * (4 - 2 + 3)*Ft2Mtr;	// +/-2+3
		z = Math.random() * WakLim;				// +/-200
		WakPos.push(x,y,z);				// Position
		WakCol.push(240, 240, 240, .75);	// Colors
		a=-a;
	}
	// create the particle system
	geometry = new THREE.BufferGeometry();
	geometry.setAttribute('position', new THREE.Float32BufferAttribute(WakPos, 3));
	geometry.setAttribute('color', new THREE.Float32BufferAttribute(WakCol, 4));
	material = new THREE.PointsMaterial({size: 1, vertexColors: true, transparent: true});
	WakPtr = new THREE.Points(geometry, material);
	WakPtr.position.set(0,.99,76.2);	// meters
	CVEGrp.add(WakPtr);
}

function moveShpWak() {
	// Set Density (decreases with distance)
	let t = 0;
	let x = CVEGrp.position.x;
	let z = CVEGrp.position.z;
	let xz = Math.sqrt(x*x+z*z);		// Compute distance
	if (xz<WakViz) t = (WakViz-xz)/WakViz;
	// Recycle at different rates
	let n = Math.floor(.25*WakPts);		// 1/4 of pts
	let d = WakLim;						// 1000
	moveShpWk0(0,n,d,t);
	d = d*WakFad;						// 800
	moveShpWk0(n,2*n,d,t);
	d = d*WakFad;						// 640
	moveShpWk0(2*n,3*n,d,t);
	d = d*WakFad;						// 512
	moveShpWk0(3*n,WakPts,d,t);
	WakPtr.geometry.attributes.position.needsUpdate = true;
	WakPtr.geometry.attributes.color.needsUpdate = true;
}

function moveShpWk0(n1,n2,d,t) {
	let WakSpd = XSSped * DLTime;
	if (USorSI == "US") WakSpd = WakSpd * Ft2Mtr;
	let pos = WakPtr.geometry.attributes.position.array;
	let col = WakPtr.geometry.attributes.color.array;
	let p = n1*3;
	let q = n1*4;
	for (let i = n1; i < n2; i++) {
		pos[p+2] = pos[p+2] + WakSpd;	// Z distance
		if (pos[p+2]>d) pos[p+2] = pos[p+2]-d;	// cut-off
		col[q+3] = t;
		p += 3;
		q += 4;
	}
}

/* Move Areas of Minimum Altitude ============================================*/
/* The Home Airfield and the CVE Deck */

// Move Minimum Altitude
function moveMinAlt() {
	GrdZed = 0;							// Default
	/* Home Airfield ----------------------------------*/
	// Compare to my Position (All in Positive Units)
	if (BasXlf < MPosXV && BasXrt > MPosXV && BasZfr > MPosZV && BasZbk < MPosZV) GrdZed = BasAlt*.92;
	/* CVE Group --------------------------------------*/
	// CVEGrp.position is relative to me; z and x axes are reversed
	// MPosZV and MPosXV are actual positions on map
	let PX = -CVEGrp.position.x;
	let PZ = CVEGrp.position.z;
	// Compare to my Position (All in Positive Units)
	if (CVEXlf < PX && CVEXrt > PX && CVEZfr > PZ && CVEZbk < PZ) {
		GrdZed = CVEAlt;				// If Above
		let CVEUPH = XSSped * 3600 / 5280;	// CVE speed
		if (GrFlag > 0) {
			// Compute Speed and Position
			MSpdZV = -XSSpdZ;
			MSpdXV = -XSSpdX;
			MPosZV = MPosZV + MSpdZV;
			MPosXV = MPosXV + MSpdXV;
			// Recompute SpdDLT
			SpdUPH = CVEUPH;					// (MPH)
			SpdUPS = SpdUPH * 5280 / 3600;		// (fps)
		}
	}
}

/* Particle System ===========================================================*/

function initPrtSys() {
	NPSPtr = new ParticleSystem({
		parent: scene,
		camera: camera,
	});
//	NPSPtr.renderOrder = 99;
}

function movePrtSys() {
	let x = (2000-MPosXV)*Ft2Mtr;
	let y = (450-MPosYV*AltAdj)*Ft2Mtr;
	let z = (MPosZV-1000)*Ft2Mtr;
	NPSPtr.setPosition(x,y,z);
	//
	let t = 0;
//	timeElapsed = t - previousRAF
	timeElapsed = 1000*(1/60);
	const timeElapsedS = timeElapsed * 0.001;
	NPSPtr.Step(timeElapsedS);
	previousRAF = t;
}

/* Load Aircraft =============================================================*/

// Load Airplane
function loadACMine() {
	fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {			// The OnLoad function
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (
				child.name == "glass_fuse0" ||
				child.name == "glass_doors" ||
				child.name == "glass_doorL" ||
				child.name == "glass_doorR")
			{
				child.castShadow = false;
				child.receiveShadow = false;
			}
		});
		ACMine = gltf.scene;
		ACMine.rotation.order = "YXZ";
		// Convert from feet to meters
		if (USorSI == "US") ACMine.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		/* Animations ------------------------------------------------------------- */
		// Main Rotor - Bank
		let clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMKAction");
		mxRtrK = new THREE.AnimationMixer(ACMine);
		let actun = mxRtrK.clipAction(clip);
		actun.play();
		if (mxRtrK) mxRtrK.setTime(bnkprp/anmfps);
		// Main Rotor - Pitch
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMPAction");
		mxRtrP = new THREE.AnimationMixer(ACMine);
		actun = mxRtrP.clipAction(clip);
		actun.play();
		if (mxRtrP) mxRtrP.setTime(pitprp/anmfps);
		// Main Rotor - Blades
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMBAction");
		mxRtrB = new THREE.AnimationMixer(ACMine);
		actun = mxRtrB.clipAction(clip);
		actun.play();
		if (mxRtrB) mxRtrB.setTime(spnprp/anmfps);
		// Main Rotor - Vertical
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMVAction");
		mxRtrV = new THREE.AnimationMixer(ACMine);
		actun = mxRtrV.clipAction(clip);
		actun.play();
		if (mxRtrV) mxRtrV.setTime(spnprp/anmfps);
		// Tail Rotor
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorTAction");
		mxRtrT = new THREE.AnimationMixer(ACMine);
		actun = mxRtrT.clipAction(clip);
		actun.play();
		if (mxRtrT) mxRtrT.setTime(spnrtr/anmfps);
		// DoorL
		clip = THREE.AnimationClip.findByName(gltf.animations, "doorLAction");
		mxDorL = new THREE.AnimationMixer(ACMine);
		actun = mxDorL.clipAction(clip);
		actun.play();
		if (mxDorL) mxDorL.setTime(doormn/anmfps);
		// DoorR
		clip = THREE.AnimationClip.findByName(gltf.animations, "doorRAction");
		mxDorR = new THREE.AnimationMixer(ACMine);
		actun = mxDorR.clipAction(clip);
		actun.play();
		if (mxDorR) mxDorR.setTime(doormn/anmfps);
		//
		scene.add(gltf.scene);
		// Initialize
		loadSounds();										// load sound
	});
}

/* Initialize and Rotate Subroutines ==========================================*/

// Rotate Airplane
function moveACMine() {
	// Parse Input from PointerLockControls
	if (PanFlg == 1) {
		CamLat = CamLat + MosYDf * .5;						// Camera Position (Lat)
		if (CamLat >  CamLax) CamLat =  CamLax;				// Limit Max Lat
		if (CamLat < -CamLax) CamLat = -CamLax;				// Limit Min Lat
		CamLon = Mod360(CamLon - MosXDf * .5);				// Camera Position (Lon)
		MosXDf = 0;
		MosYDf = 0;
	}
	// Altitude Change
	AltDif = MosWDf + InpAlt;
	MosWDf = 0;												// Reset
	// Pitch Speed Change
	ACPDif = MosYDf * PitMul;
	ACPDif = PoM360(Mod360(ACPDif + InpACP));
	MosYDf = 0;												// Reset
	// Bank Speed Change
	ACBDif = MosXDf * BnkMul;
	ACBDif = PoM360(Mod360(ACBDif + InpACB));				// Inputs are +/-
	MosXDf = 0;												// Reset
	// Input Yaw
	YawDif = InpYaw;
	// Compute Rotation and Vectors
	move3dFlyt();
	/* Animations ----------------------------------------------------------- */
	// Rotors - Speed
	let prpspd = 33;
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359;							// A complete circle
	/* Aircraft ------------------------------------------------------------- */
	// Rotate Aircraft (order:YXZ)
	ACMine.rotation.order = "YXZ";
	ACMine.rotation.y = Mod360(-ACHead) * DegRad;			// Heading
	// Pitch - exclude first 11 degrees
	let PitDfR = ACPtch;
	if (PitDfR > 0) {
		PitDfR = PitDfR - 11;
		if (PitDfR < 0) PitDfR = 0;
	}
	if (PitDfR < 0) {
		PitDfR = PitDfR + 11;
		if (PitDfR > 0) PitDfR = 0;
	}
	ACMine.rotation.x = Mod360(PitDfR) * DegRad;			// Pitch
	// Bank
	// Pitch - exclude first 11 degrees
	let BnkDfR = PoM360(ACBank);
	if (BnkDfR > 0) {
		BnkDfR = BnkDfR - 11;
		if (BnkDfR < 0) BnkDfR = 0;
	}
	if (BnkDfR < 0) {
		BnkDfR = BnkDfR + 11;
		if (BnkDfR > 0) BnkDfR = 0;
	}
	ACMine.rotation.z = Mod360(360 - BnkDfR) * DegRad;		// Bank
	// Main Rotor - Speed
	if (mxRtrB) mxRtrB.setTime(spnprp/anmfps);
	if (mxRtrV) mxRtrV.setTime(spnprp/anmfps);
	// Main Rotor - Pitch
	pitprp = 180 + ACPtch * 179 / 5;
	if (pitprp > 359) pitprp = 359;
	if (pitprp < 1) pitprp = 1; 
	if (mxRtrP) mxRtrP.setTime(pitprp/anmfps);
	// Main Rotor - Bank
	bnkprp = 180 + PoM360(ACBank) * 179 / 5;
	if (bnkprp > 359) bnkprp = 359;
	if (bnkprp < 1) bnkprp = 1; 
	if (mxRtrK) mxRtrK.setTime(bnkprp/anmfps);
	// Tail Rotor
	if (mxRtrT) mxRtrT.setTime(spnprp/anmfps);
	// Doors
//	if (mxDoor) mxDoor.setTime(doormn/anmfps);
	/* View Keys ----------------------------------------------------------- */
	if (PanFlg == 0) {										// Only if Not Panning
		// Default View
		CamLat = 0;
		CamLon = 0;
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg == 0)	{
			if (VCFlag == 0) CamLat = 10;
		}
		// Down 45
		else if (D45flg > 0) {
			CamLat = 0;
			// Look Back
			if (L90flg > 0 && L90flg > 0 && R90flg > 0) CamLon = 180;
			// Look Back Left 90 + 45
			else if (L90flg > 0) CamLon = 135;
			// Look Back Right 270 - 45
			else if (R90flg > 0) CamLon = 225;
			// Look Down
			else {
				CamLon = 0;
				CamLat = 45;
			}
		}
		// Up 45
		else if (U45flg > 0) {
			CamLat = 315;
			if (VCFlag == 0 && GrFlag > 0) CamLat = 0;
			// Look Up Left 45
			if (L45flg > 0) CamLon = 45;
			// Look Up Right 45
			else if (R45flg > 0) CamLon = 315;
			// Look Up Left 90
			else if (L90flg > 0) CamLon = 90;
			// Look Up Right 90
			else if (R90flg > 0) CamLon = 270;
			// Look Up
			else CamLon = 0;
		}
		// Level
		else {
			CamLat = 0;
			// Look Left 45
			if (L45flg > 0) CamLon = 45;
			// Look Right 45
			else if (R45flg > 0) CamLon = 315;
			// Look Left 90
			else if (L90flg > 0) CamLon = 90;
			// Look Right 90
			else if (R90flg > 0) CamLon = 270;
		}
	}
}

/* Load Sounds ===============================================================*/

// Load Sounds
function loadSounds() {	
	/* My Engine ------------------------------------------------------------ */
	fname = ACPath + "sounds/" + acsnd1;
	audioLoader.load(fname, function(buffer) {
		sound1.setBuffer(buffer);
		sound1.setRefDistance(RefDst);
		sound1.setLoop(true);
		sound1.setVolume(0);
	});
	/* XP Engine ------------------------------------------------------- */
	fname = XPPath + "sounds/" + xpsnd1;						// [NEW]
	audioLoader.load(fname, function(buffer) {
		sound4.setBuffer(buffer);
		sound4.setRefDistance(RefDst);							// Distance at which sound is full volume
		sound4.setLoop(true);
		sound4.setVolume(0);
		sound4.playbackRate = 1.3;
	});
}

// Change Sounds
function moveSounds() {
	// My Engine
	sound1.setVolume(acvol1);									// Range = .1 to .2
	sound1.setPlaybackRate(1);									// Range = 1 to 1.5
	// XP Engine
	sound4.setVolume(xpvol1);
}

/* Rotate and Move Camera ====================================================*/
/* There are two types of external camera movement:
/* 1. Default Mode - the camera looks through the aircraft center to the direction of flight
/* 2. Panning Mode - the camera orbits around the aircraft
*/

// Rotate and Move Camera
function moveCamera() {
	//	Pivot Rotation (rotation order = YXZ)
	let x = Mod360(ACPtch) * DegRad;						// Pitch (ACPAdj is not part of this)
	let y = Mod360(-ACHead) * DegRad;						// Heading
	let z = Mod360(360-ACBank) * DegRad;					// Bank
	CamObj.rotation.set(x, y, z);
	// Both Mouse Pan and Mouse Direction
	x = Mod360(CamLat) * DegRad;
	y = Mod360(CamLon) * DegRad;
	RotVec(CamDst, x, y);									// Returns VectR values
	if (VectRY < (GrdZed + MinAGL - MPosYV)) VectRY = GrdZed + MinAGL - MPosYV;	// Not below aircraft level
	camera.position.set(VectRX, VectRY, VectRZ);
	camera.rotation.set(-x, y, 0);							// Camera Doesn't Rotate on Z-Axis
}

/* Outputs ===================================================================*/

// Change HUD Values
function chngHUDV() {
	AC_Hite = MPosYV;											// Altitude
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);
	AC_Ptch = ACPtch;											// Pitch
	AC_PtchNode.nodeValue = AC_Ptch.toFixed(0);
	AC_SpdZ = PSpdZS * 3600 / 5280;								// Speed - Forward
	AC_SpdZNode.nodeValue = AC_SpdZ.toFixed(0);
	AC_Bank = ACBank;											// Bank
	AC_BankNode.nodeValue = AC_Bank.toFixed(0);
	AC_SpdX = PSpdXS * 3600 / 5280;								// Speed - Lateral
	AC_SpdXNode.nodeValue = AC_SpdX.toFixed(0);
	AC_Head = Mod360(Math.round(ACHead));						// Heading
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_DFly = DirFlt;											// Direction of Flight
	AC_DFlyNode.nodeValue = AC_DFly.toFixed(0);
}

// Paused On
function onPause(){
	On_PawsNode.nodeValue = "Paused";
}

// Paused Off
function noPause(){
	On_PawsNode.nodeValue = "Press P to Pause";
}

// Info On
function onInfo1(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "CONTROLS";
	On_Info03Node.nodeValue = "Use Mouse Wheel or Q/W Keys to change Altitude";
	On_Info04Node.nodeValue = "Use Mouse or Arrow Keys to change Pitch and Bank";
	On_Info05Node.nodeValue = "Use Mouse Buttons or Z/X Keys to change Yaw";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "Press S to toggle sound";
}

// Info On
function onInfo2(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "VIEW KEYS";
	On_Info03Node.nodeValue = "Hold Shift and use Mouse to pan around aircraft";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "Press DELETE or PAGE DOWN to look left/right";
	On_Info06Node.nodeValue = "Press HOME and the above to look up";
	On_Info07Node.nodeValue = "Press END and DELETE or PAGE DOWN to look back";
	On_Info08Node.nodeValue = "Press all 3 keys to look back";
	On_Info09Node.nodeValue = "";
}

// Info Off
function noInfo(){
	On_Info01Node.nodeValue = "Press I for Info";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

/* Inputs ====================================================================*/
/* The PointerLockControls creates inputs for mouse movement.
/* This creates inputs for mouse buttons and keys.
*/

/* Mouse ---------------------------------------------------------------------*/

// Mouse Buttons - Down
function onDocumentMouseDown(event) {
	event.preventDefault();
	// Yaw Left
	if (event.button == 0) {
		InpYaw = -0.4;
	}
	// Yaw Right
	if (event.button == 2) {
		InpYaw = 0.4;
	}
}

// Mouse Buttons - Up
function onDocumentMouseUp(event) {
	// Yaw Left Off
	if (event.button == 0) {
		InpYaw = 0;
	}
	// Yaw Right Off
	if (event.button == 2) {
		InpYaw = 0;
	}
}

// Mousewheel - Altitude
function onDocumentMouseWheel(event) {
	event.preventDefault();
	MosWDf = - event.deltaY * 0.0001;
}

/* Keyboard ------------------------------------------------------------------*/

// Keyboard - Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Altitude Up
	if (event.keyCode == K_AltU) InpAlt = 0.001;
	// Altitude Down
	if (event.keyCode == K_AltD) InpAlt = -0.001;
	// Pitch Up
	if (event.keyCode == K_PitU) InpACP = 0.1;
	// Pitch Down
	if (event.keyCode == K_PitD) InpACP = -0.1;
	// Bank Left
	if (event.keyCode == K_BnkL) InpACB = -0.1;
	// Bank Right
	if (event.keyCode == K_BnkR) InpACB = 0.1;
	// Yaw Left
	if (event.keyCode == K_YawL) InpYaw = -0.4;
	// Yaw Right
	if (event.keyCode == K_YawR) InpYaw = 0.4;
	// Doors
	if (event.keyCode == K_Door) DrFlag = 1;
	// View - 45 deg up
	if (event.keyCode == K_VU45) U45flg = 1;
	// View - 45 deg down
	if (event.keyCode == K_VD45) D45flg = 1;
	// View - 45 deg left
	if (event.keyCode == K_VL45) L45flg = 1;
	// View - 45 deg right
	if (event.keyCode == K_VR45) R45flg = 1;
	// View - 90 deg left
	if (event.keyCode == K_VL90) L90flg = 1;
	// View - 90 deg right
	if (event.keyCode == K_VR90) R90flg = 1;
	// Pan View
	if (event.keyCode == K_Look) PanFlg = 1;
	// Toggle Sound
	if (event.keyCode == K_Soun) {
		if (SndFlg < 1) {
			SndFlg = 1;
			sound1.play();
			sound4.play();
		}
		else {
			SndFlg = 0;
			sound1.stop();
			sound4.stop();
		}
	}
	// Toggle Pause
	if (event.keyCode == K_Paws) {
		if (PawsOn < 1) {
			PawsOn = 1;
			onPause();
		}
		else {
			PawsOn = 0;
			noPause();
		}
	}
	// Toggle Info
	if (event.keyCode == K_Info) {
		if (InfoOn == 0) {
			InfoOn = 1;
			onInfo1();
		}
		else if (InfoOn == 1) {
			InfoOn = 2;
			onInfo2();
		}
		else {
			InfoOn = 0;
			noInfo();
		}
	}
}

// Keyboard - Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Altitude Up
	if (event.keyCode == K_AltU) InpAlt = 0;
	// Altitude Down
	if (event.keyCode == K_AltD) InpAlt = 0;
	// Pitch Up
	if (event.keyCode == K_PitU) InpACP = 0;	
	// Pitch Down
	if (event.keyCode == K_PitD) InpACP = 0;
	// Bank Left
	if (event.keyCode == K_BnkL) InpACB = 0;
	// Bank Right
	if (event.keyCode == K_BnkR) InpACB = 0;			
	// Yaw Left
	if (event.keyCode == K_YawL) InpYaw = 0;
	// Yaw Right
	if (event.keyCode == K_YawR) InpYaw = 0;
	// Doors
	if (event.keyCode == K_Door) DrFlag = 0;
	// View - 45 deg up
	if (event.keyCode == K_VU45) U45flg = 0;
	// View - 45 deg down
	if (event.keyCode == K_VD45) D45flg = 0;
	// View - 45 deg left
	if (event.keyCode == K_VL45) L45flg = 0;
	// View - 45 deg right
	if (event.keyCode == K_VR45) R45flg = 0;
	// View - 90 deg left
	if (event.keyCode == K_VL90) L90flg = 0;
	// View - 90 deg right
	if (event.keyCode == K_VR90) R90flg = 0;
	// Pan View
	if (event.keyCode == K_Look) {
		PanFlg = 0;
		CamLat = CamPit;
		CamLon = CamHed;
	}
}

// Window Resize
function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>