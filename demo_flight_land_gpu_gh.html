<!doctype html>
<html>

<!--
Copyright 2017-24, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 1 May 2024

-->

<head>
<title>Moving Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/butn_map2b.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Heading.(deg): <span id="AC_Head"></span></div>
		<div>Altitude.(ft): <span id="AC_Hite"></span></div>
		<div>Speed...(mph): <span id="AC_Sped"></span></div>
	</div>
</div>

<button id="PAW" class="pauseButton">Paws</button>

<button id="CAM" class="cameraButton">View</button>

<button id="SLO" class="spddButton">-</button>
<button id="PTD" class="pitdButton">&uarr;</button>
<button id="FST" class="spduButton">+</button>
<button id="BKL" class="bnklButton">&larr;</button>
<button id="CTR" class="cntrButton">X</button>
<button id="BKR" class="bnkrButton">&rarr;</button>
<button id="YWL" class="yawlButton">[</button>
<button id="PTU" class="pituButton">&darr;</button>
<button id="YWR" class="yawrButton">]</button>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.163.0/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/",
			"three/nodes": "https://unpkg.com/three@0.163.0/examples/jsm/nodes/Nodes.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {
		color,
		float,
		texture,
		MeshLambertNodeMaterial
} from 'three/nodes';
import WebGPU from 'three/addons/capabilities/WebGPU.js';		// ### WebGPU
import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';	// ### WebGPU
import Stats from "three/addons/libs/stats.module.js";
import {Lensflare, LensflareElement} from "three/addons/objects/Lensflare.js";
//import {nodeFrame} from 'three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js';	// ### Nodes

/*= Start ===================================================================*/
// Note: Since three.js uses meters, computer Speed and Altitude in Meters
// But can display speed in MPH and altitude in feet 
// Altitude: 10,000 meters = 32,800 feet
// Grid 4 Square Size: 0.5 miles = 804.67 meters (basic building block)
// Grid 5 Square Size: 1.5 miles = 2.41 km (2X size of FSX textures)
// Grid 6 Square Size: 4.5 miles = 7.24 km (Visibility: 4.5 * 13.5 = 60.78 miles)
let ACHite = 2000;					// Aircraft Altitude (ft)
//	ACHite = 1000;					// ### TEST
let ACHead = 0;						// Aircraft Heading
let ACBank = 0;						// Aircraft Bank
let ACPtch = 0;						// Aircraft Pitch
let SpdMPH = 800;					// Aircraft Speed (miles per hour)
//	SpdMPH = 0;						// ### TEST
let GrdSiz = 804.67;				// Size of Smallest Grid Square (1/4 section = 1/2 mile)
//	GrdSiz = 10;					// ### TEST
let GrdDrt = "#1c160e";				// Color of underlying dirt (affects brightness)
let	SunRot = new THREE.Vector3(23,312,5000);	// SunLat, SunLon, SunDst (for LensFlare)

/*= Variables ================================================================*/
let DLTime = 1/60;					// Frames per Second
let InpACB = 0;						// Aircraft Bank
let InpPPP = 0;						// Aircraft Pitch
let InpYaw = 0;						// Aircraft Yaw
let InpSpd = 0;						// Aircraft Speed Change (mph)
let ACBDif = 0;						// Aircraft Bank Change
let PPPDif = 0;						// Aircraft Pitch Change
let YawDif = 0;						// Aircraft Yaw Change
let	SpdDLT = 0;						// Aircraft Speed (meters per frame)
let	MSpdZV = 0;						// Aircraft ground speed (N/S)
let	MSpdXV = 0;						// Aircraft ground speed (E/W)
let	MSpdYV = 0;						// Vertical Speed
let	MPosZV = 0;						// Aircraft position (N/S)
let	MPosXV = 0;						// Aircraft position (E/W)
let	MPosYV = ACHite;				// Aircraft position (E/W)
//- Controls
let onPointerDownX, onPointerDownY, onPointerDownLon, onPointerDownLat;
//- General
let mesh, geometry, material;
//- Flags
let	PanFlg = 0;						// Camera Panning
let PawsOn = 0;						// Pause
let CamVOn = 0;						// Camera View
let LodFlg = 0;						// Done initializing
//- Stats
let StsFlg = 1;						// Stats ((0 = off, 1 = on)
let stats = 0;

/*= Constants ================================================================*/
// Math Predefined
let	PieVal = Math.PI;				// PI
let	DegRad = PieVal / 180;			// Convert Degrees to Radians
let	RadDeg = 180 / PieVal;			// Convert Radians to Degrees
let Mtr2Ft = 3.28084;				// Meters to Feet
let Ft2Mtr = .3048;					// Feet to Meters
let MPHMPS = .44704;				// MPH to meters per second
//-	Background
let SkyCol = 0xbab4a6;				// Sky (for Fog only)
//- Light
let SunCol = 0xffffff;				// Sun
let SunInt = 3;						// Default intensity of light/sun
let SunDst = 5000;					// [feet]
let SunLat = 23;					// ### LensFlare
let SunLon = 312;					// ### LensFlare
let	SunPos = new THREE.Vector3();	// ### LensFlare
let envMap = 0;						// Environment Map
//-	Shadows
let ShdBox = 100;					// Size of shadow box
//- Camera - Lat/Lon = direction the camera is pointing
let SkyLim = 100000;				// Max viewing distance
let CamLat = -30;					// (+/-90)
//	CamLat = -90;					// ### TEST
let CamLtX = 90;					// Max lat
let CamLon = 10;					// (0-360)
let CmADst = 1500*Ft2Mtr;			// Distance from Center
let CmADif = 1;						// In/out speed
let CmAMax = CmADst * 3;			// Maximum Distance
let CmAMin = CmADst * 0.5;			// Minimum Distance
let CmBDst = 200*Ft2Mtr;			// Distance from Aircraft
let CmBDif = .25;					// In/out Speed
let CmBMax = CmBDst * 3;			// Maximum Distance
let CmBMin = CmBDst * 0.5;			// Minimum Distance
let CamDst = CmADst;				// Starting Camera Distance
let CamDif = CmADif;				// Starting In/out speed
let CamMax = CmAMax;				// Starting distance
let CamMin = CmAMin;				// Starting distance
let CmODst = CmBDst;				// Old Camera Distance
let CmOLon = 0;						// Old Camera Heading
//- Controls
let BnkSpd = 1;						// Bank Speed
let PitSpd = 1;						// Bank Speed
//- Jet Exhaust
let SmkPtr = 0;
let SmkPts = 400;
let SmkPos = [];
let SmkCol = [];
let SmkDns = .3;					// Starting density
let SmkFad = .8;					// Fades by this much every frame
let SmkSpd = 10;
let SmkWid = .05;
let SmkLim = 200;					// Max distance
//- Key Values
let K_SpdU = 45;					// Speed Up (insert)
let K_PitD = 38;					// Pitch down (up arrow)
let K_SpdD = 33;					// Speed Up (page up)
let	K_BnkL = 37;					// Bank Left (left arrow)
let K_Cntr = 35;					// Center (end)
let	K_BnkR = 39;					// Bank Right (right arrow)
let K_YawL = 46;					// Yaw Left (delete)
let K_PitU = 40;					// Pitch up (down arrow)
let K_YawR = 34;					// Yaw Right (page down)
//- Vector Values
let V3temp = new THREE.Vector3();

/* = Ground Squares ==========================================================*/
// Layer 1 constains smaller higher definition squares
// Layer 2 contains larger lower definition squares (3X size of Layer 1 squares)
/* = Both Grids --------------------------------------------------------------*/
let Grd0 = {
		MSZ:	0,					// Map ZSpeed (updated by program)
		MSX:	0,					// Map XSpeed (updated by program)
		MPY:	0					// Aircraft Altitude (updated by program)
	}
/* = Grid 4 ------------------------------------------------------------------*/
let Grd4 = {
		Typ:	4,					// Type of Grid - Inner or Outer
		RCs:	27,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	GrdSiz,				// Size of square
		Stp:	3,					// Steps
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	0,					// N/A
		NSA:	0,					// N/A
		EWA:	0,					// N/A
		Mat:	0					// N/A
	}
/* = Grid 5 ------------------------------------------------------------------*/
let Grd5 = {
		Typ:	5,					// Type of Grid - Inner or Outer
		RCs:	27,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	Grd4.Siz*Grd4.Stp,	// Size of square
		Stp:	3,					// Steps (### changed)
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	Grd4.RCs/Grd4.Stp,	// Cut-Out Area (27/3 = 9)
		NSA:	0,					// Shared North/South Adjustment (updated)
		EWA:	0,					// Shared East/West Adjustment (updated)
		Mat:	0					// Match Texture of Outer and Inner Blocks
	}
/* = Grid 6 ------------------------------------------------------------------*/
let Grd6 = {
		Typ:	6,					// Type of Grid - Inner or Outer
		RCs:	27,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	Grd5.Siz*Grd5.Stp,	// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	Grd5.RCs/Grd5.Stp,	// Cut-Out Area
		NSA:	0,					// Shared North/South Adjustment (updated)
		EWA:	0,					// Shared East/West Adjustment (updated)
		Mat:	0					// Match Texture of Outer and Inner Blocks
	}

/* = Textures Data ===========================================================*/

// Canvas
let canvas = document.createElement("canvas");
	canvas.width = 1024;
	canvas.height = 1024;
let	context = canvas.getContext('2d');

// Dimensions
let dqSize = 1024;					// For Sections
let dqArea = dqSize*dqSize;
let dtSize = 512;					// Default
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;						// Total Textures

// Color Variables
let Gr0Mul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];

// Colors
let drtclr = [0x8e6d3d,0x47361e];		// Dirt
let pstclr = [0x00b000,0x005000];		// Pasture
let cvrclr = [0x75b24c,0x466b2d];		// Green
let whtclr = [0xfbf4e5,0xeabb63];		// Wheat
let bnsclr = [0xacd193,0x5d8e3d];		// Beans

//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
// [https://icolorpalette.com/color/dirt-brown

/* = Grid 4 Data =============================================================*/

// Grid 4 Colors
// 1/4 section squares (1/2 mile X 1/2 mile)

// Image Data
let G4DPtr = [];
	G4DPtr[txtTot-1] = 0;

// Materials
let G4MPtr = [];
	G4MPtr[txtTot-1] = 0;

// Patterns of Grid 4 Materials
// Used to draw Grid 4 textures
// And to Create Grid 5 3X3 Textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G4Pd00 = [4,3,5,4,3,0,5,2,1];
let G4Pd01 = [3,0,4,1,2,4,5,3,5];
let G4Pd02 = [5,1,3,4,5,0,2,4,3];
let G4Pd03 = [2,4,1,3,5,3,5,0,4];
let G4Pd04 = [5,1,5,0,3,4,2,4,3];
let G4Pd05 = [3,0,5,3,4,5,1,2,4];
let G4Pd06 = [2,0,3,5,3,1,4,4,5];
let G4Pd07 = [1,5,4,3,5,0,2,4,3];
let G4Pd08 = [2,3,0,5,3,1,4,5,4];
let G4Pd09 = [0,2,5,3,4,3,5,1,4];	// 1 = airport
let G4Pd10 = [4,3,5,4,5,2,1,3,0];
let G4Pd11 = [4,5,3,1,0,4,3,5,2];
let G4Pd12 = [3,1,2,4,5,3,5,0,4];
let G4Pd13 = [0,5,3,1,4,2,4,3,5];
let G4Pd14 = [1,4,2,5,3,0,4,5,3];
let G4Pd15 = [4,1,5,0,3,4,3,5,2];
let G4PPtr = [
		G4Pd00,G4Pd01,G4Pd02,G4Pd03,G4Pd04,G4Pd05,G4Pd06,G4Pd07,G4Pd08,G4Pd09,
		G4Pd10,G4Pd11,G4Pd12,G4Pd13,G4Pd14,G4Pd15
	];

/* = Grid 5 Data =============================================================*/
// 1.5 mile squares (= 2.4km = 2X2 FSDX texture)
// Composed of 3X3 Grid4 textures, arranged in pattern specified by G4PPtr 
// Texture Data (Max of 81 Textures - repeated 9X on Map)
// Limited by Need to Scroll Grid 4 = 27X27 Grid 4 squares = 9X9 Grid 5 squares
// Data Arranged by Unique Squares
// Eash Square is Unique 3X3 Display of Grid 4 Squares

let Gr5Mul = 3;
let Gr5Siz = Math.floor(dtSize/Gr5Mul);

// Image Data (Source Data - Resized)
let G5SPtr = [];
	G5SPtr[G4PPtr.length-1] = 0;

// Image Data
let G5DPtr = [];
	G5DPtr[G4PPtr.length-1] = 0;

// Materials
let G5MPtr = [];
	G5MPtr[G5DPtr.length-1] = 0;

// Index to G5 Textures by Pattern
// Used to position Grid 4 squares
// And to Create Grid 5 3X3 Textures
let G5Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,		//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4, 9,13, 8,12, 7,		// 9 = airport
		 4, 7,15,12, 3,11, 9,13, 4,
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];

/* = Grid 6 Data =============================================================*/
// 
// Composed of 3X3 Grid5 Textures - Repeated 27X
// 4.5 mile squares (max visibility = 60.75 miles)
	
let Gr6Mul = 3;
let Gr6Siz = Math.floor(dtSize/Gr6Mul);

// Image Data (Source Data - Resized)
let G6SPtr = [0,0,0,0,0,0,0,0,0];

// Image Data
let G6DPtr = [0,0,0,0,0,0,0,0,0];

// Materials
let G6MPtr = [0,0,0,0,0,0,0,0,0];

/* = Roads ===================================================================*/
// North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}
// East West
let Rod2 = {
		Typ:	2,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}

// Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);

/* = Trees ===================================================================*/
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e

/* = Basic Values ============================================================*/
// Display
let	scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
let renderer = new WebGPURenderer({antialias: true});	// ### WebGPU
    renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);					// ### nodes
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
//let maxAnisotropy = renderer.capabilities.getMaxAnisotropy();		// ### Still err with r160
let	maxAnisotropy = 16;	// ### WebgGPU
//- Lights
let sunLight = new THREE.DirectionalLight(SunCol, SunInt);
	sunLight.castShadow = true;
	sunLight.shadow.mapSize.width = 4096;
	sunLight.shadow.mapSize.height = 4096;
	sunLight.shadow.camera.near = 0.001;	
	sunLight.shadow.camera.far = SunDst+ShdBox;
	sunLight.shadow.camera.left = -ShdBox;
	sunLight.shadow.camera.right = ShdBox;
	sunLight.shadow.camera.top = ShdBox;
	sunLight.shadow.camera.bottom = -ShdBox;
	sunLight.shadow.bias = - 0.0005;					// ### WebGPU
	sunLight.target.position.set(0,0,0);
	sunLight.position.set(0, 1000, 0);		// ### TEST
	scene.add(sunLight);
//- Camera
let	camera = new THREE.PerspectiveCamera(45.0, window.innerWidth/window.innerHeight, 5.0, SkyLim);
	camera.rotation.order = "YXZ";
	camera.position.z = -CamDst;
	camera.rotation.y = 180*DegRad;		// Default = looking in
let	CamObj = new THREE.Object3D();			// Armature base - use to rotate camera
	CamObj.rotation.order = "YXZ";
	CamObj.add(camera);
//- Inputs
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	renderer.domElement.addEventListener("mousedown", onMouseDown, false);
	renderer.domElement.addEventListener("mouseup", onMouseUp, false);
	renderer.domElement.addEventListener("mousemove", onMouseMove, false);
	renderer.domElement.addEventListener('mousewheel', onMouseWheel, {capture: false, passive: false});
	renderer.domElement.addEventListener("touchstart", onTouchStart, false);
	renderer.domElement.addEventListener("touchmove", onTouchMove, false);
	document.getElementById("PAW").addEventListener("click", togglePause, false);
	document.getElementById("CAM").addEventListener("click", toggleCamera, false);
	document.getElementById("FST").addEventListener("click", toggleSpdU, false);
	document.getElementById("PTD").addEventListener("click", togglePitD, false);
	document.getElementById("SLO").addEventListener("click", toggleSpdD, false);
	document.getElementById("BKL").addEventListener("click", toggleBnkL, false);
	document.getElementById("CTR").addEventListener("click", toggleCntr, false);
	document.getElementById("BKR").addEventListener("click", toggleBnkR, false);
	document.getElementById("PTU").addEventListener("click", togglePitU, false);
	document.getElementById("YWL").addEventListener("click", toggleYawL, false);
	document.getElementById("YWR").addEventListener("click", toggleYawR, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);

//= OBJECTS ====================================================================
let CtrObj = new THREE.Object3D();		// For Camera
	CtrObj.rotation.order = "YXZ";
	CtrObj.add(CamObj);
	scene.add(CtrObj);
//- Aircraft Mount
let	AirAxe = new THREE.Object3D();
	scene.add(AirAxe);
	AirAxe.rotation.order = "YXZ";
	AirAxe.rotation.z = Mod360(360-ACBank) * DegRad;	// Bank
	AirAxe.rotation.x = Mod360(ACPtch) * DegRad;		// Pitch
	AirAxe.rotation.y = Mod360(-ACHead) * DegRad;		// Heading
//- Aircraft Pitch Bank Yaw
let	AirPBY = new THREE.Object3D();
	AirAxe.add(AirPBY);
	AirPBY.rotation.order = "YXZ";
let quaternion = new THREE.Quaternion();
//- Other Objects
let LF0Txt, LF1Txt = 0;					// Lensflare Textures

//= HTML OVERLAY TEXT ==========================================================
let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
	AC_HiteElement.appendChild(AC_HiteNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
	AC_HeadElement.appendChild(AC_HeadNode);
let AC_SpedElement = document.getElementById("AC_Sped");
let AC_SpedNode = document.createTextNode("");
	AC_SpedElement.appendChild(AC_SpedNode);
let AC_Hite,AC_Head,AC_Sped;
	
//= MAIN PROGRAM ===============================================================
	if (WebGPU.isAvailable() === false) {
		document.body.appendChild(WebGPU.getErrorMessage());
		throw new Error('No WebGPU support');
	}
	loadAll();

//= 0 LOAD ALL =================================================================
function loadAll() {
	loadSkyBox();
}

//= 1 INITIALIZE ===============================================================
function initAll() {
	initSkyBox();					// SkyDome, Fog and Sun
	initGrdTxt();
	Grd0.MPY = MPosYV*Ft2Mtr;
	initGrdMap();
	initRoads();
	initTrees();
	loadAirPln();
//	initJetExh();
	// Show stats
	if (StsFlg > 0) {					// show stats
		stats = new Stats();
		stats.setMode(0);				// FPS only
		stats.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(stats.dom);
	}
	LodFlg = 1;
}

//= 2 RENDER ===================================================================
function rendAll() {
//	requestAnimationFrame(rendAll);
//	nodeFrame.update();					// ### Nodes
	if (PawsOn == 0 && LodFlg > 0) {
		moveAirPln();
//		moveJetExh();
		Grd0.MSZ = MSpdZV*Ft2Mtr;		// update Grid Data
		Grd0.MSX = MSpdXV*Ft2Mtr;
		Grd0.MPY = MPosYV*Ft2Mtr;
		moveGrdMap();					// Move Grid Map
		moveRoads();
		moveTrees();
		if (StsFlg > 0) stats.update();	// update stats
	}
	chngHUDV()
	moveCamera();
	renderer.render(scene, camera);		// Render
}

/* Make Sky Box ==============================================================*/

function loadSkyBox() {
	let fpath = "https://threejs.org/examples/textures/cube/skyboxsun25deg/";
	envMap = new THREE.CubeTextureLoader(loadingManager)
		.setPath(fpath)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace;	// ### r152
	scene.background = envMap;
	// LensFlare
	LF0Txt = txtrLoader.load("https://threejs.org/examples/textures/lensflare/lensflare1.png");
	LF1Txt = txtrLoader.load("https://threejs.org/examples/textures/lensflare/hexangle.png");
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	let fogColor = new THREE.Color(SkyCol);
	scene.fog = new THREE.Fog(fogColor, 0.25, 95000);	// less than camera distance, sky colored fog
//	initLensFlare();
}

function initLensFlare() {	// ### Disabled
let sunPos = new THREE.Vector3();
	SunRot.z = 1000;					// For Sun Mesh and Lensflare
	sunPos = RoteV3(SunRot.x*DegRad,Mod360(180-SunRot.y)*DegRad,SunRot.z);	// Set Position above Light
	sunLight.position.set(sunPos.x,sunPos.y,sunPos.z).normalize();	
let	spotLight = new THREE.PointLight(0xffffff);
	scene.add(spotLight);
	spotLight.position.set(sunPos.x,sunPos.y,sunPos.z);
	let LF = new Lensflare();
	LF.addElement(new LensflareElement(LF0Txt, 256, 0));
	LF.addElement(new LensflareElement(LF1Txt, 32, 0.2));
	LF.addElement(new LensflareElement(LF1Txt, 256, 0.9));
	spotLight.add(LF);
}

//= Rotates Vector (LensFlare Only)
function RoteV3(lat,lon,dst) {
	// Latitude
	V3temp.y = dst * Math.sin(lat);
	V3temp.z = dst * Math.cos(lat);
	// Longitude
	V3temp.x = V3temp.z * Math.sin(lon);
	V3temp.z = V3temp.z * Math.cos(lon);
	return V3temp;
}

/* = Create Image Data and Materials =========================================*/

function initGrdTxt() {
	initGr4Txt();
	initGr5Txt();
	initGr6Txt();
}

function initGr4Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G4DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G4DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);	// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);	// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(Gr0Mul,Gr0Mul);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		G4MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});		
		G4MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G4DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr5Siz,Gr5Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G5SPtr[n] = context.getImageData(0,0,Gr5Siz,Gr5Siz);				//
	}
}

function initGr5Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr5Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G4PPtr.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G4PPtr[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
//				let ImgDat = G4DPtr[stIndx[idx]];
				let ImgDat = G5SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G5DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G5DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		G5MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});
		G5MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G5DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr6Siz,Gr6Siz);
		G6SPtr[n] = context.getImageData(0,0,Gr6Siz,Gr6Siz);
	}
}

function initGr6Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr6Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G6SPtr[G5Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G6DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G6DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;		// ###
			DatTxt.needsUpdate = true;
//			G6MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});
			G6MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

/* Make Grid Map Textures ====================================================*/

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

/* Scrolling 2X Nested Grid Map ==============================================*/

function initGrdMap() {
	init1GrMap(Grd4);
	init1GrMap(Grd5);
	init1GrMap(Grd6);
}

function moveGrdMap() {
	move1GrMap(Grd4);
	move1GrMap(Grd5);
	move1GrMap(Grd6);
}

/* Init Moving Map -----------------------------------------------------------*/

function init1GrMap(Grd) {
	// Load Variables
	Grd.RCi = Grd.RCs-1;				// Max Index Value
	Grd.MZV[Grd.RCi] = 0;				// Z-Values
	Grd.MXV[Grd.RCi] = 0;				// X-Values
	Grd.Nor = Grd.RCi;					// Max North Square (updated)
	Grd.Est = Grd.RCi;					// Max East Square (updated)
	Grd.Num = Grd.RCs * Grd.RCs;		// Size of array
	Grd.Ptr[Grd.Num-1] = 0;				// Mesh Pointers
	if (Grd.Typ > 4) {
		Grd.NSA = (Grd.RCs-Grd.RCF)/2;	// (27-3=6)
		Grd.EWA = Grd.NSA;
	}
	// Compute Starting Z and X Values
	let zx = -0.5*(Grd.RCs)*Grd.Siz+0.5*Grd.Siz;
	for (let i = 0; i < Grd.RCs; i++) {
		Grd.MZV[i] = zx;
		Grd.MXV[i] = zx;
		zx = zx + Grd.Siz;
	}
	
	// Common Variables
	let n, si, d2, yd0, xd0;
	geometry = new THREE.PlaneGeometry(Grd.Siz, Grd.Siz);
	
	// Default to Prevent Err (Lower Left to Upper Right)
//	material = new THREE.MeshLambertMaterial({color: 0xc00000});
	material = new MeshLambertNodeMaterial({colorNode: color(0xc00000)});
	// Assign Textures and Save Square Pointers
	for (let i = 0; i < Grd.Num; i++) {
		mesh = new THREE.Mesh(geometry,material);
		if (Grd.Shd) mesh.receiveShadow = true;
		Grd.Ptr[i] = mesh;
	}
	
	if (Grd.Typ == 4) {
		n = 0;	
		// Use Combination of Grid 4 3x3 Index and Grid 5 Index to Determine Material for Each Square 
		for (let yd = 0; yd < 9; yd++) {	// For each 3X3 section
			for (let xd = 0; xd < 9; xd++) {
				yd0 = yd * 81;
				xd0 = xd * 3;
				let G4Indx = G4PPtr[G5Indx[n]];		//G5Indx points to 3X3 type, G4PPtr points to sequence
				si = 0;
				// Within single 3x3 Grid
				for (let yd2 = 0; yd2 < 3; yd2++) {
					for (let xd2 = 0; xd2 < 3; xd2++) {
						si = yd2*3+xd2;
						d2 = yd0 + xd0 + yd2*27 + xd2;
						material = G4MPtr[G4Indx[si]];
						Grd.Ptr[d2] = new THREE.Mesh(geometry,material);
						if (Grd.Shd) Grd.Ptr[d2].receiveShadow = true;		// not work
						si++;
					}
				}
				n++;		
			}
		}	
	}
	
	if (Grd.Typ == 5) {
		// 81 textures are repeated 9X on the full map
		// Assign Textures
		n = 0;
		for (let yd = 0; yd < 9; yd++) {
			for (let xd = 0; xd < 9; xd++) {
				// From Upper Left
				material = G5MPtr[G5Indx[n]];
				yd0 = yd*Grd.RCs;
				// Assign Textures and Save Square Pointers
				for (let ad = 0; ad < 3; ad++) {
					d2 = yd0 + xd + ad*9*Grd.RCs;
					for (let bd = 0; bd < 3; bd++) {
						Grd.Ptr[d2] = new THREE.Mesh(geometry,material);
						if (Grd.Shd) Grd.Ptr[d2].receiveShadow = true;		// not work
						d2 = d2 + 9;
					}
				}
				n++;
			}
		}
	}
	
	if (Grd.Typ == 6) {
		// 27 textures are repeated 27X on the full map
		n = 0;
		for (let yd = 0; yd < 3; yd++) {	// Source
			for (let xd = 0; xd < 3; xd++) {
				material = G6MPtr[n];
				yd0 = yd*Grd.RCs;			// Within the lower left square
				// Assign Textures and Save Square Pointers
				for (let ad = 0; ad < 9; ad++) {
					d2 = yd0 + xd + ad*3*Grd.RCs;
					for (let bd = 0; bd < 9; bd++) { 
						Grd.Ptr[d2] = new THREE.Mesh(geometry,material);
						if (Grd.Shd) Grd.Ptr[d2].receiveShadow = true;		// not work
						d2 = d2 + 3;
					}
				}
				n++;
			}
		}
	}
	
	n = 0;
	// Set Starting Position of Squares
	for (let y = 0; y < Grd.RCs; y++) {		// Row
		for (let x = 0; x < Grd.RCs; x++) {	// Column
			Grd.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Grd.Ptr[n]);
			Grd.Ptr[n].position.set(Grd.MXV[x],-Grd0.MPY,-Grd.MZV[y]);
			n++;
		}
	}
}

/* Move Moving Map -----------------------------------------------------------*/

// Move Grid Map
function move1GrMap(Grd) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Grd.RCs*Grd.Siz;
	let min = -max;
	// Update Z, X and Y-Values
	for (let i = 0; i < Grd.RCs; i++) {
		Grd.MZV[i] = Grd.MZV[i] - Grd0.MSZ;	// Rows
		Grd.MXV[i] = Grd.MXV[i] - Grd0.MSX;	// Columns
	}
	// Test North/South
	if (Grd0.MSZ < 0) {					// If Moving South
		j = Grd.Nor;
		if (Grd.MZV[j] >= max) {
			v = min+(Grd.MZV[j]-max);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Grd.RCi;
				v = v - Grd.Siz;
			}
			Grd.Nor = Grd.Nor - Grd.Stp;
			if (Grd.Nor < 0) Grd.Nor = Grd.Nor + Grd.RCs;
			if (Grd.Typ == 4) Grd5.NSA = Grd5.NSA - 1;
			if (Grd.Typ == 5) {
				Grd.NSA = Grd.NSA + Grd.Stp;
				Grd6.NSA = Grd6.NSA - 1;
			}
			if (Grd.Typ == 6) Grd6.NSA = Grd6.NSA + Grd.Stp;
		}
	}
	if (Grd0.MSZ > 0) {					// If Moving North
		j = Grd.Nor + 1;
		if (j > Grd.RCi) j = 0;
		if (Grd.MZV[j] <= min) {
			v = max-(min-Grd.MZV[j]);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MZV[j] = v;
				j++;
				if (j > Grd.RCi) j = 0;
				v = v + Grd.Siz;
			}
			Grd.Nor = Grd.Nor + Grd.Stp;
			if (Grd.Nor > Grd.RCi) Grd.Nor = Grd.Nor - Grd.RCs;
			if (Grd.Typ == 4) Grd5.NSA = Grd5.NSA + 1;
			if (Grd.Typ == 5) {
				Grd.NSA = Grd.NSA - Grd.Stp;
				Grd6.NSA = Grd6.NSA + 1;
			}
			if (Grd.Typ == 6) Grd6.NSA = Grd6.NSA - Grd.Stp;
		}
	}
	// Test East/West
	if (Grd0.MSX < 0) {					// If Moving West
		j = Grd.Est;
		if (Grd.MXV[j] >= max) {
			v = min+(Grd.MXV[j]-max);
			for (let i = 0; i < Grd.Stp; i++) {
				Grd.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Grd.RCi;
				v = v - Grd.Siz;
			}
			Grd.Est = Grd.Est - Grd.Stp;
			if (Grd.Est < 0) Grd.Est = Grd.Est + Grd.RCs;
			if (Grd.Typ == 4) Grd5.EWA = Grd5.EWA - 1;
			if (Grd.Typ == 5) {
				Grd.EWA = Grd.EWA + Grd.Stp;
				Grd6.EWA = Grd6.EWA - 1;
			}
			if (Grd.Typ == 6) Grd6.EWA = Grd6.EWA + Grd.Stp;
		}
	}
	if (Grd0.MSX > 0) {						// If Moving East
		j = Grd.Est + 1;
		if (j > Grd.RCi) j = 0;	
		if (Grd.MXV[j] <= min) {
			v = max-(min-Grd.MXV[j]);
			for (let i = 0; i < Grd.Stp; i++) {			
				Grd.MXV[j] = v;
				j++;
				if (j > Grd.RCi) j = 0;
				v = v + Grd.Siz;
			}
			Grd.Est = Grd.Est + Grd.Stp;
			if (Grd.Est > Grd.RCi) Grd.Est = Grd.Est - Grd.RCs;
			if (Grd.Typ == 4) Grd5.EWA = Grd5.EWA + 1;
			if (Grd.Typ == 5) {
				Grd.EWA = Grd.EWA - Grd.Stp;
				Grd6.EWA = Grd6.EWA + 1;
			}
			if (Grd.Typ == 6) Grd6.EWA = Grd6.EWA - Grd.Stp;
		}
	}
	// Set Position
	let n = 0;
	for (let r = 0; r < Grd.RCs; r++) {	// Row
		for (let c = 0; c < Grd.RCs; c++) {	// Col
			Grd.Ptr[n].position.set(Grd.MXV[c],-Grd0.MPY,-Grd.MZV[r]);
			Grd.Ptr[n].visible = true;	// Default for Outer Grid
			n++;
		}
	}
	// Outer Grids Only - Make Cut-Out Area Invisible
	if (Grd.Typ > 4) {
		let r = Grd.Nor + 1 + Grd.NSA;			// Get Lower index
		if (r > Grd.RCi) r = r - Grd.RCs;
		let c = Grd.Est + 1 + Grd.EWA;			// Get Left Index
		if (c > Grd.RCi) c = c - Grd.RCs;
		for (let i = 0; i < Grd.RCF; i++) {
			n = r * Grd.RCs + c;
			if (n < 0) n = n + Grd.Num;
			if (n > Grd.Num) n = n - Grd.Num;
			let n2 = (r+1) * Grd.RCs - 1;
			if (n2 > Grd.Num) n2 = n2 - Grd.Num;
			if (n2 < 0) n2 = n2 + Grd.Num;
			for (let j = 0; j < Grd.RCF; j++) {
				Grd.Ptr[n].visible = false;
				n++;
				if (n > n2) n = n - Grd.RCs; 
				if (n < 0) n = n + Grd.Num;
				if (n > Grd.Num) n = n - Grd.Num;
			}
			r++;
			if (r > Grd.RCi) r = r - Grd.RCs;
		}
	}
}

/* Roads ==================================================================*/

function initRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

function initRoad2(Rod) {

	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(20*Ft2Mtr, Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		let material = new THREE.MeshLambertMaterial({map: DatTxt});
		let material = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz, 20*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		let material = new THREE.MeshLambertMaterial({map: DatTxt});
		let material = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].position.set(Rod.MXV[x],-Grd0.MPY*.999+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

// Move Roads
function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - Grd0.MSZ;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - Grd0.MSX;	// Columns
	}
	// Test North/South
	if (Grd0.MSZ < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (Grd0.MSZ > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (Grd0.MSX < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (Grd0.MSX > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-Grd0.MPY*.999+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

/* Trees =====================================================================*/

/* Init Trees ----------------------------------------------------------------*/

function initTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)	// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;		// ###
	txttre.needsUpdate = true;
//	let mtltre = new THREE.MeshLambertMaterial({map: txttre});
	let mtltre = new MeshLambertNodeMaterial({colorNode: texture(txttre)});
//	let mtltrn = new THREE.MeshLambertMaterial({color:0x161005});
	let mtltrn = new MeshLambertNodeMaterial({colorNode: color(0x161005)});
//	let mtlshd = new THREE.MeshLambertMaterial({
//		color: 0x000000,
//		transparent: true,
//		opacity: .5,
//		depthWrite: false
//	});
	let mtlshd = new MeshLambertNodeMaterial({colorNode: color(0x000000)});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = 2640*Math.floor(27*(Math.random()-0.5))+50;
		TreePZ[n] = 2640*Math.floor(27*(Math.random()-0.5))+50;
	}
}

// Move Trees
function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*2640;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-MPosXV-1320;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		x = x*Ft2Mtr;
		let z = MPosZV-TreePZ[n]-1320;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		z = z*Ft2Mtr;
		let y = -Grd0.MPY*.99+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

/* Airplane ==================================================================*/

/* Load Airplane -------------------------------------------------------------*/

function loadAirPln() { 
	// Front
	mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 2.5, 15, 3, 1, "false"), new MeshLambertNodeMaterial({colorNode: color(0xff00ff)}));	// ### Nodes
	mesh.rotation.x = -90*DegRad;
	mesh.position.z = -5;
	mesh.castShadow = true;
	AirPBY.add(mesh);
	// Back
	mesh = new THREE.Mesh(new THREE.CylinderGeometry(.25, 2.5, 25, 3, 1, "false"), new MeshLambertNodeMaterial({colorNode: color(0xff00ff)}));
	mesh.rotation.x = 90*DegRad;
	mesh.rotation.y = 180*DegRad;
	mesh.position.z = 15;
	mesh.castShadow = true;
	AirPBY.add(mesh);
	// Wing
	mesh = new THREE.Mesh(new THREE.BoxGeometry(50,.25,5), new MeshLambertNodeMaterial({colorNode: color(0xffffff)}));
	mesh.position.y = -.5;
	mesh.position.z = 2.5;
	mesh.castShadow = true;
	AirPBY.add(mesh);
	// HTail
	mesh = new THREE.Mesh(new THREE.BoxGeometry(12.5,.25,3.25), new MeshLambertNodeMaterial({colorNode: color(0xffffff)}));
	mesh.position.y = -.5;
	mesh.position.z = 25;
	mesh.castShadow = true;
	AirPBY.add(mesh);
	// VTail
	mesh = new THREE.Mesh(new THREE.BoxGeometry(.25,6.25,3.25), new MeshLambertNodeMaterial({colorNode: color(0xff00ff)}));
	mesh.position.y = 2.5;
	mesh.position.z = 25;
	mesh.castShadow = true;
	AirPBY.add(mesh);
	AirPBY.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
}

/* Move Airplane -------------------------------------------------------------*/

function moveAirPln() {
	// Pitch -----------------------------------------------
	PPPDif = InpPPP;				// Change to Pitch Speed
	// Self-centering
	if (PPPDif > -0.001 && PPPDif < 0.001) {
		if (ACPtch == 0) PPPDif = 0;
		if (ACPtch < 5 && ACPtch > -5) PPPDif = -0.01 * ACPtch;
	}
	// Bank ------------------------------------------------
	ACBDif = InpACB;				// Change to Bank Speed
	// Self-centering
	if (ACBDif > -0.001 && ACBDif < 0.001) {
		if (ACBank == 0) ACBDif = 0;
		if (ACBank < 7.5) ACBDif = -0.01 * ACBank;
		if (ACBank > 352.5) ACBDif = 0.01 * (360 - ACBank);
	}
	// Yaw
	YawDif = InpYaw;
	// Turn Rate = tan(bank) * G/V = tan(bank) * 32.174 / 300 fps (aprox 200 mph)
	let ACBrad = ACBank * DegRad;
	let ACHSpd = Math.tan(ACBrad) * 32.174 / 300;
	if (ACHSpd > 0.2) ACHSpd = 0.2;
	if (ACHSpd < -0.2) ACHSpd = -0.2;
	ACHSpd = ACHSpd * Math.cos(ACPtch*DegRad);
	if (ACBank > 90 && ACBank < 270) ACHSpd = -ACHSpd;
	// Rotate
	// Make Bank, Pitch and Yaw Rotations to AirAxe and AirPBY
	AirPBY.rotation.z = -ACBDif*DegRad;
	AirPBY.rotation.x = PPPDif*DegRad;
	AirPBY.rotation.y = -YawDif*DegRad;
	// Transfer Combined Rotation to AirAxe
	AirPBY.getWorldQuaternion(quaternion);
	AirAxe.setRotationFromQuaternion(quaternion);
	// Zero Out AirPBY Rotations (so values not doubled)
	AirPBY.rotation.z = 0;
	AirPBY.rotation.x = 0;
	AirPBY.rotation.y = 0;
	// Load Resulting Values into Variables (for display)
	ACBank = Mod360(-AirAxe.rotation.z*RadDeg);
	ACPtch = AirAxe.rotation.x*RadDeg;
	// Update AirAxe Heading for Bank
	ACHead = Mod360(-AirAxe.rotation.y*RadDeg+ACHSpd);
	AirAxe.rotation.y = -ACHead*DegRad;
	// Compute Speed
	SpdMPH = SpdMPH + InpSpd;
//	if (SpdMPH < 50) SpdMPH = 50;
	if (SpdMPH > 1200) SpdMPH = 1200;
	InpSpd = 0;
	SpdDLT = SpdMPH * MPHMPS * DLTime;
	let ACPrad = ACPtch*DegRad;
	let ACHrad = ACHead*DegRad;
	MSpdYV = SpdDLT * Math.sin(ACPrad);
	let GS = SpdDLT * Math.cos(ACPrad);
	MSpdZV = GS * Math.cos(ACHrad);
	MSpdXV = GS * Math.sin(ACHrad);
	MPosYV = MPosYV + MSpdYV;
	if (MPosYV < 5) {				// if hit ground, zero out
		MPosYV = 5;
		ACBank = 0;
		ACPtch = 0;
		InpACB = 0;
		InpPPP = 0;
		AirAxe.rotation.z = 0;		// No Bank
		AirAxe.rotation.x = 0;		// No Pitch
	}
	MPosZV = MPosZV + MSpdZV;
	MPosXV = MPosXV + MSpdXV;
}

/* Jet Exhaust ==============================================================*/

// Init Jet Exhaust
function initJetExh() {
	let x,y,z;
	for (let i = 0; i < SmkPts; i++) {
	// create a particle with random position values, -250 -> 250
		x = Math.random() * 4 - 2;		// +/-5
		y = Math.random() * 4 - 2;		// 
		z = Math.random() * SmkLim;		//
		SmkPos.push(x,y,z);				// position
		SmkCol.push(240,240,240,SmkDns);	// color and density
	}
	// create the particle system
	geometry = new THREE.BufferGeometry();
	geometry.setAttribute('position', new THREE.Float32BufferAttribute(SmkPos, 3));
	geometry.setAttribute('color', new THREE.Float32BufferAttribute(SmkCol, 4));
	material = new THREE.PointsMaterial({size: 4, vertexColors: true, transparent: true});
	SmkPtr = new THREE.Points(geometry, material);
	SmkPtr.position.z = 30;				// behind the airplane
	// add it to the scene
	AirPBY.add(SmkPtr);
}

// Move Jet Exhaust
function moveJetExh() {
	let pos = SmkPtr.geometry.attributes.position.array;
	let col = SmkPtr.geometry.attributes.color.array;
	let p = 0;
	let q = 0;
	for (let i = 0; i < SmkPts; i++) {
		pos[p+2] = pos[p+2]+SmkSpd;		// Z distance
		if (pos[p+2] > SmkLim) {
			pos[p+2] = pos[p+2]-SmkLim;	// cut-off
			col[q+3] = SmkDns;			// density
		}
		col[q+3] = .8*col[q+3];
		p += 3;
		q += 4;
	}
	SmkPtr.geometry.attributes.position.needsUpdate = true;
	SmkPtr.geometry.attributes.color.needsUpdate = true;
}

/* Move Camera ==============================================================*/

function moveCamera() {
	// In external view, the camera is facing in and the armature is pointing out:
	// * x.rotation = -CamLat
	// * y.rotation = CamLon + 180
	camera.position.z = -CamDst;
	CamObj.rotation.x = Mod360(-CamLat)*DegRad;
	CamObj.rotation.y = Mod360(180-CamLon)*DegRad;
}

/* 4 Misc Subroutines =======================================================*/

/* Converts degrees to 360 */
function Mod360(deg) {
	if (deg < 0) deg = deg + 360;
	else if (deg == 360 || deg > 360) deg = deg - 360;
return deg;}

/* Outputs ==================================================================*/

// Change HUD Values
function chngHUDV() {
	AC_Head = ACHead;				// Aircraft Heading
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_Hite = MPosYV;				// Aircraft Altitude (feet)
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);
	AC_Sped = SpdMPH;				// Aircraft Speed (MPH)
	AC_SpedNode.nodeValue = AC_Sped.toFixed(0);
}

/* 5 Inputs ================================================================= */

//= Keyboard Input =============================================================

// Key Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Speed Up
	if (event.keyCode == K_SpdU) InpSpd = 1;
	// Speed Dn
	if (event.keyCode == K_SpdD) InpSpd = -1;
	// Bank Left
	if (event.keyCode == K_BnkL) InpACB = -BnkSpd;
	// Bank Right
	if (event.keyCode == K_BnkR) InpACB = BnkSpd;
	// Pitch Up
	if (event.keyCode == K_PitU) InpPPP = PitSpd;
	// Pitch Down
	if (event.keyCode == K_PitD) InpPPP = -PitSpd;
	// Center
	if (event.keyCode == K_Cntr) {
		InpACB = 0;
		InpPPP = 0;
		InpYaw = 0;
		ACBank = 0;
		ACPtch = 0;
		InpSpd = 0;
		AirAxe.rotation.z = 0;			// No Bank
		AirAxe.rotation.x = 0;			// No Pitch
	}
	// Yaw Left
	if (event.keyCode == K_YawL) InpYaw = -0.1;
	// Yaw Right
	if (event.keyCode == K_YawR) InpYaw = 0.1;
}

// Key Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Speed Up
	if (event.keyCode == K_SpdU) InpSpd = 0;
	// Speed Dn
	if (event.keyCode == K_SpdD) InpSpd = 0;
	// Bank Left
	if (event.keyCode == K_BnkL) InpACB = 0;
	// Bank Right
	if (event.keyCode == K_BnkR) InpACB = 0;
	// Pitch Up
	if (event.keyCode == K_PitU) InpPPP = 0;
	// Pitch Down
	if (event.keyCode == K_PitD) InpPPP = 0;
	// Yaw Left
	if (event.keyCode == K_YawL) InpYaw = 0;
	// Yaw Right
	if (event.keyCode == K_YawR) InpYaw = 0;
}

function onMouseDown(event) {
	event.preventDefault();
	PanFlg = 1;
	onPointerDownX = event.clientX;
	onPointerDownY = event.clientY;
	onPointerDownLon = CamLon;
	onPointerDownLat = CamLat;
}

function onMouseUp(event) {
	PanFlg = 0;
}

function onMouseMove(event) {
// Panning View
	if (PanFlg > 0) {
		CamLat = (onPointerDownY - event.clientY) * 0.2 + onPointerDownLat;
		CamLat = Math.max(-CamLtX, Math.min(CamLtX, CamLat));
		CamLon = (event.clientX - onPointerDownX) * 0.2 + onPointerDownLon;
		CamLon = Mod360(CamLon);
	}
}

function onMouseWheel(event) {
	CamDst = CamDst + event.deltaY * CamDif;
	CamDst = Math.max(CamMin, Math.min(CamMax, CamDst));
}

//= Touch Screen Input =========================================================

function onTouchStart(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		onPointerDownX = event.touches[0].clientX;
		onPointerDownY = event.touches[0].clientY;
		onPointerDownLon = CamLon;
		onPointerDownLat = CamLat;
	}
}

function onTouchMove(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		CamLon = (onPointerDownX - event.touches[0].clientX) * 0.2 + onPointerDownLon;
		CamLon = Mod360(CamLon);
		CamLat = (event.touches[0].clientY - onPointerDownY) * 0.2 + onPointerDownLat;
		CamLat = Math.max(-85, Math.min(85, CamLat));
	}
}

//= Button Input ===============================================================

// Toggle Pause
function togglePause() {
	if (PawsOn == 0) PawsOn = 1;
	else PawsOn = 0;
}

// Change Camera View
function toggleCamera() {
	// From External to Linked
	if (CamVOn == 0) {
		CtrObj.remove(CamObj);
		AirPBY.add(CamObj);			// Link camera to aircraft
		let OldVal = 0;
		OldVal = CmODst;
		CmODst = CamDst;			// Old Camera Distance
		CamDst = OldVal;			
		CamDif = CmBDif;			// In/out speed
		CamMax = CmBMax;			// Max distance
		CamMin = CmBMin;			// Max distance
		CamVOn = 1;	
	}
	// From Linked to External
	else if (CamVOn == 1) {
		AirPBY.remove(CamObj);
		CtrObj.add(CamObj);			// Link camera to map
		let OldVal = 0;
		OldVal = CmODst;
		CmODst = CamDst;			// Old Camera Distance
		CamDst = OldVal;
		OldVal = CmOLon;
		CmOLon = CamLon;			// Old Camera Heading
		CamLon = OldVal;					
		CamDif = CmADif;			// In/out speed
		CamMax = CmAMax;			// Max distance
		CamMin = CmAMin;			// Max distance
		CamVOn = 0;
	}
}

// Flight Controls

function toggleSpdU() {
	if (InpSpd == 0) InpSpd = 10;
	else InpSpd = 0;
}

function togglePitD() {
	if (InpPPP == 0) InpPPP = -PitSpd;
	else InpPPP = 0;
}

function toggleSpdD() {
	if (InpSpd == 0) InpSpd = -10;
	else InpSpd = 0;
}

function toggleBnkL() {
	if (InpACB == 0) InpACB = -BnkSpd;
	else InpACB = 0;
}

function toggleCntr() {
	InpACB = 0;
	InpPPP = 0;
	InpYaw = 0;
	ACBank = 0;
	ACPtch = 0;
	AirAxe.rotation.z = 0;			// No Bank
	AirAxe.rotation.x = 0;			// No Pitch
}

function toggleBnkR() {
	if (InpACB == 0) InpACB = BnkSpd;
	else InpACB = 0;
}

function togglePitU() {
	if (InpPPP == 0) InpPPP = PitSpd;
	else InpPPP = 0;
}

function toggleYawL() {
	if (InpYaw == 0) InpYaw = -0.1;
	else InpYaw = 0;
}

function toggleYawR() {
	if (InpYaw == 0) InpYaw = 0.1;
	else InpYaw = 0;
}

//= Window Resize Input ========================================================

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
