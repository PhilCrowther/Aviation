<!doctype html>
<html>

<!--
Copyright 2017-24, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 5 May 2024

This shows a flyable airplane in flight over an procedural land using nodes and WebGPU.
-->

<head>
<title>Demo Flight Land Nodes WebGPU</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/butn_map2b.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Speed....: <span id="Air_Spd"></span> mph</div>
		<div>Altitude.: <span id="Air_Alt"></span> ft</div>
		<div>Heading..: <span id="Air_Hdg"></span> deg</div>
	</div>
</div>

<button id="PAW" class="pauseButton">Paws</button>

<button id="CAM" class="cameraButton">View</button>

<button id="SLO" class="spddButton">-</button>
<button id="PTD" class="pitdButton">&uarr;</button>
<button id="FST" class="spduButton">+</button>
<button id="BKL" class="bnklButton">&larr;</button>
<button id="CTR" class="cntrButton">X</button>
<button id="BKR" class="bnkrButton">&rarr;</button>
<button id="YWL" class="yawlButton">[</button>
<button id="PTU" class="pituButton">&darr;</button>
<button id="YWR" class="yawrButton">]</button>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.163.0/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/",
			"three/nodes": "https://unpkg.com/three@0.163.0/examples/jsm/nodes/Nodes.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {
		color,
		texture,
		float,
		MeshBasicNodeMaterial,
		MeshLambertNodeMaterial,
		MeshStandardNodeMaterial
} from 'three/nodes';
import WebGPU from 'three/addons/capabilities/WebGPU.js';		// ### WebGPU
import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';	// ### WebGPU
import Stats from "three/addons/libs/stats.module.js";
import {Lensflare, LensflareElement} from "three/addons/objects/Lensflare.js";

//= START ======================================================================
// Note: Since three.js uses meters, computer Speed and Altitude in Meters
// But can display speed in MPH and altitude in feet 
// Altitude: 10,000 meters = 32,800 feet
// Grid 4 Square Size: 0.5 miles = 804.67 meters (basic building block)
// Grid 5 Square Size: 1.5 miles = 2.41 km (2X size of FSX textures)
// Grid 6 Square Size: 4.5 miles = 7.24 km (Visibility: 4.5 * 13.5 = 60.78 miles)
//- AIRPLANE: Start ------------------------------------------------------------
let USorSI = "US";				// Starting Units of Measurement (US or SI)
let BegSpd = 500;				// Aircraft Speed (miles per hour)
let BegPos = new THREE.Vector3(0,2000,0);	// Position (ft)
let InpVal = new THREE.Vector3(1,0.1,1);	// Rotation Change

//= CONSTANTS ==================================================================
//-	Conversions
var DegRad = Math.PI/180;		// Convert Degrees to Radians
var RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Mtr2Ft = 3.28084;			// Meters to Feet
let Ft2Mtr = 0.3048;			// Convert Feet to Meters (exact)
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//-	Time
let DLTime = 1/60;				// Frames per Second
//
if (USorSI = "US") {
	BegSpd = BegSpd*Mil2Km;
	BegPos.multiplyScalar(Ft2Mtr);
}

//= VARIABLES ==================================================================
//-	Background
let SkyLim = 100000;			// Max viewing distance (meters)
let FogCol = 0xbab4a6;			// Sky (for Fog only)
let SunCol = 0xffffff;			// Sun
//-	Light
let	SunLLD = new THREE.Vector3(23,312,1000);	// Lat,Lon,Dst for Sun Mesh and Lensflare
let SunInt = 3;					// Default intensity of light/sun
//-	Shadows
let SunDst = 10000;				// [feet]
let ShdBox = 200;				// Size of shadow box 
//-	Flags
let	PanFlg = 0;					// Camera Panning
let PawsOn = 0;					// Pause
let CamVOn = 0;					// Camera View
let LodFlg = 0;					// Done initializing
//-	Stats
let StsFlg = 1;					// Stats ((0 = off, 1 = on)
let stats = 0;
//- Controls
let onPointerDownX, onPointerDownY, onPointerDownLon, onPointerDownLat;

//= AIROBJ =====================================================================
let air_ = {
		// Airplane Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Vector3(),	// Object Rotation (degrees)
		AirObj: makMsh(),				// Airplane Object
		AirPBY: makMsh(),				// 	
		// Airplane PBY Changes
		RotDif: new THREE.Vector3(0,0,0),	// Change
		// Inputs
		InpRot: new THREE.Vector3(),		// Input Rotation
		InpSpd: 0,						// Input Speed
		// Airplane Speed
		SpdKPH: BegSpd,					// Speed in MPH
		SpdMPS: BegSpd/3.6,				// Speed (meters/sec)
		SpdMPF: (BegSpd/3.6)*DLTime,	// Speed (meters/frame)
		// Map Speed and Position
		MapSpd: new THREE.Vector3(0,0,0),	// Map Speed (meters)
		MapPos: new THREE.Vector3().copy(BegPos), // Map Position (meters)
		MapSPS: new THREE.Vector3(0,BegPos.y,0),  // MSX, MPY, MSZ (meters)
	}
// Adjustments
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY);
	air_.AirObj.rotation.z = Mod360(360-air_.AirRot.z) * DegRad;	// Bank
	air_.AirObj.rotation.x = Mod360(air_.AirRot.x) * DegRad;		// Pitch
	air_.AirObj.rotation.y = Mod360(-air_.AirRot.y) * DegRad;		// Heading
let quaternion = new THREE.Quaternion();

//= JET EXHAUST ================================================================
let SmkPtr = 0;
let SmkPts = 400;
let SmkPos = [];
let SmkCol = [];
let SmkDns = .3;				// Starting density
let SmkFad = .8;				// Fades by this much every frame
let SmkSpd = 10;
let SmkWid = .05;
let SmkLim = 200;				// Max distance

//= TEXTURES ===================================================================
//- SkyBox
let SBPath = "https://threejs.org/examples/textures/cube/skyboxsun25deg/";
//-	LensFlare
let LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let LF1Src = "https://threejs.org/examples/textures/lensflare/hexangle.png";
let LF0Txt, LF1Txt = 0;

// Canvas
let canvas = document.createElement("canvas");
	canvas.width = 1024;
	canvas.height = 1024;
let	context = canvas.getContext('2d');

// Dimensions
let dqSize = 1024;					// For Sections
let dqArea = dqSize*dqSize;
let dtSize = 512;					// Default
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;						// Total Textures

// Color Variables
let GrdMul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];

// Colors
let GrdDrt = "#1c160e";				// Color of underlying dirt (affects brightness)
let drtclr = [0x8e6d3d,0x47361e];		// Dirt
let pstclr = [0x00b000,0x005000];		// Pasture
let cvrclr = [0x75b24c,0x466b2d];		// Green
let whtclr = [0xfbf4e5,0xeabb63];		// Wheat
let bnsclr = [0xacd193,0x5d8e3d];		// Beans

//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
// [https://icolorpalette.com/color/dirt-brown

//= MATERIALS ================================================================

// Grid 0 Colors
// 1/4 section squares (1/2 mile X 1/2 mile)

// Image Data
let G0DPtr = [];
	G0DPtr[txtTot-1] = 0;

// Materials
let G0MPtr = [];
	G0MPtr[txtTot-1] = 0;

// Patterns of Grid 4 Materials
// Used to draw Grid 4 textures
// And to Create Grid 5 3X3 Textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G0Id00 = [4,3,5,4,3,0,5,2,1];
let G0Id01 = [3,0,4,1,2,4,5,3,5];
let G0Id02 = [5,1,3,4,5,0,2,4,3];
let G0Id03 = [2,4,1,3,5,3,5,0,4];
let G0Id04 = [5,1,5,0,3,4,2,4,3];
let G0Id05 = [3,0,5,3,4,5,1,2,4];
let G0Id06 = [2,0,3,5,3,1,4,4,5];
let G0Id07 = [1,5,4,3,5,0,2,4,3];
let G0Id08 = [2,3,0,5,3,1,4,5,4];
let G0Id09 = [0,2,5,3,4,3,5,1,4];	// 1 = airport
let G0Id10 = [4,3,5,4,5,2,1,3,0];
let G0Id11 = [4,5,3,1,0,4,3,5,2];
let G0Id12 = [3,1,2,4,5,3,5,0,4];
let G0Id13 = [0,5,3,1,4,2,4,3,5];
let G0Id14 = [1,4,2,5,3,0,4,5,3];
let G0Id15 = [4,1,5,0,3,4,3,5,2];
let G0Indx = [
		G0Id00,G0Id01,G0Id02,G0Id03,G0Id04,G0Id05,G0Id06,G0Id07,G0Id08,G0Id09,
		G0Id10,G0Id11,G0Id12,G0Id13,G0Id14,G0Id15
	];

/* = Grid 1 Data =============================================================*/
// 1.5 mile squares (= 2.4km = 2X2 FSDX texture)
// Composed of 3X3 Grid4 textures, arranged in pattern specified by G0Indx 
// Texture Data (Max of 81 Textures - repeated 9X on Map)
// Limited by Need to Scroll Grid 4 = 27X27 Grid 4 squares = 9X9 Grid 5 squares
// Data Arranged by Unique Squares
// Eash Square is Unique 3X3 Display of Grid 4 Squares

let Gr1Mul = 3;
let Gr1Siz = Math.floor(dtSize/Gr1Mul);

// Image Data (Source Data - Resized)
let G1SPtr = [];
	G1SPtr[G0Indx.length-1] = 0;

// Image Data
let G1DPtr = [];
	G1DPtr[G0Indx.length-1] = 0;

// Materials
let G1MPtr = [];
	G1MPtr[G1DPtr.length-1] = 0;

// Index to G1 Textures by Pattern
// Used to position Grid 4 squares
// And to Create Grid 5 3X3 Textures
let G1Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,		//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4, 9,13, 8,12, 7,		// 9 = airport
		 4, 7,15,12, 3,11, 9,13, 4,
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];

/* = Grid 2 Data =============================================================*/
// 
// Composed of 3X3 Grid5 Textures - Repeated 27X
// 4.5 mile squares (max visibility = 60.75 miles)
	
let Gr2Mul = 3;
let Gr2Siz = Math.floor(dtSize/Gr2Mul);

// Image Data (Source Data - Resized)
let G2SPtr = [0,0,0,0,0,0,0,0,0];

// Image Data
let G2DPtr = [0,0,0,0,0,0,0,0,0];

// Materials
let G2MPtr = [0,0,0,0,0,0,0,0,0];

//= GRIDS ======================================================================
// Layer 1 constains smaller higher definition squares
// Layer 2 contains larger lower definition squares (3X size of Layer 1 squares)

let GrdSiz = 804.67;				// Size of Smallest Grid Square (1/4 section = 1/2 mile)

//- All Grids -----------------------------------------------------------------
let grd_ = {
		SPS: new THREE.Vector3 (),	// MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,					// Squares in each of first 2 grids
		Siz: GrdSiz,				// Size of smallest square
		Stp: 3,						// Squares in each of first 2 grids
		Grx: [],					// Index of Grids (0-2)
		Idx: [G0Indx,G1Indx],		// Index to Patterns
		Mat: [G0MPtr,G1MPtr,G2MPtr], // Materials
	}
//- Grid 0 ---------------------------------------------------------------------
	grd_.Grx[0] = {
		Typ:	0,					// Type of Grid - Inner or Outer
		RCs:	grd_.RCs,			// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	GrdSiz,				// Size of square
		Stp:	grd_.Stp,			// Steps
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	0,					// N/A
		NSA:	0,					// N/A
		EWA:	0,					// N/A
		Mat:	0					// N/A
	}
//- Grid 1 ---------------------------------------------------------------------
	grd_.Grx[1] = {
		Typ:	1,					// Type of Grid - Inner or Outer
		RCs:	grd_.RCs,			// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	grd_.Grx[0].Siz*grd_.Grx[0].Stp,	// Size of square
		Stp:	grd_.Stp,			// Steps (### changed)
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	grd_.Grx[0].RCs/grd_.Grx[0].Stp,	// Cut-Out Area (27/3 = 9)
		NSA:	0,					// Shared North/South Adjustment (updated)
		EWA:	0,					// Shared East/West Adjustment (updated)
		Mat:	0					// Match Texture of Outer and Inner Blocks
	}
//- Grid 2 ---------------------------------------------------------------------
	grd_.Grx[2] = {
		Typ:	2,					// Type of Grid - Inner or Outer
		RCs:	grd_.RCs,			// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	grd_.Grx[1].Siz*grd_.Grx[1].Stp,	// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Shd:	1,					// Shadow enabled
		RCF:	grd_.Grx[1].RCs/grd_.Grx[1].Stp,	// Cut-Out Area
		NSA:	0,					// Shared North/South Adjustment (updated)
		EWA:	0,					// Shared East/West Adjustment (updated)
		Mat:	0					// Match Texture of Outer and Inner Blocks
	}

//= ROADS ======================================================================
// North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}
// East West
let Rod2 = {
		Typ:	2,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}

//= Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);

//= TREES ======================================================================
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e

//= CAMERA =====================================================================
let CamLtX = 90;				// Max lat
let CmADst = 1500*Ft2Mtr;		// Distance from Center
let	CamRot = new THREE.Vector3(-30,10,1500*Ft2Mtr);	// CamLat, CamLon, CamDst
let CmADif = 1;					// In/out speed
let CmAMax = CmADst * 3;		// Maximum Distance
let CmAMin = CmADst * 0.5;		// Minimum Distance
let CmBDst = 200*Ft2Mtr;		// Distance from Aircraft
let CmBDif = .25;				// In/out Speed
let CmBMax = CmBDst * 3;		// Maximum Distance
let CmBMin = CmBDst * 0.5;		// Minimum Distance
let CamDif = CmADif;			// Starting In/out speed
let CamMax = CmAMax;			// Starting distance
let CamMin = CmAMin;			// Starting distance
let CmODst = CmBDst;			// Old Camera Distance
let CmOLon = 0;					// Old Camera Heading

//= KEY BINDINGS ===============================================================
let K_SpdU = 45;				// Speed Up (insert)
let K_PitD = 38;				// Pitch down (up arrow)
let K_SpdD = 33;				// Speed Up (page up)
let	K_BnkL = 37;				// Bank Left (left arrow)
let K_Cntr = 35;				// Center (end)
let	K_BnkR = 39;				// Bank Right (right arrow)
let K_YawL = 46;				// Yaw Left (delete)
let K_PitU = 40;				// Pitch up (down arrow)
let K_YawR = 34;				// Yaw Right (page down)
let K_Paws = 80;				// Pause (p)

//= BASIC VALUES ===============================================================
	document.body.appendChild(container);
//- Display
let	scene = new THREE.Scene();
	scene.background = new THREE.Color(FogCol);
let renderer = new WebGPURenderer({antialias: true});	// ### WebGPU
    renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;
	renderer.shadowMap.type = THREE.BasicShadowMap;
	document.body.appendChild(renderer.domElement);
let	maxAnisotropy = 16;									// ### WebGPU
//- Lights
let ambLight = new THREE.AmbientLight(SunCol, 1.0);
	scene.add(ambLight);
let sunLight = new THREE.DirectionalLight(SunCol, SunInt);
	sunLight.castShadow = true;
	sunLight.shadow.mapSize.width = 4096;
	sunLight.shadow.mapSize.height = 4096;
	sunLight.shadow.camera.near = 0.001;	
	sunLight.shadow.camera.far = SunDst+ShdBox;
	sunLight.shadow.camera.left = -ShdBox;
	sunLight.shadow.camera.right = ShdBox;
	sunLight.shadow.camera.top = ShdBox;
	sunLight.shadow.camera.bottom = -ShdBox;
	sunLight.shadow.bias = - 0.0005;					// ### WebGPU
	sunLight.target.position.set(0,0,0);
	scene.add(sunLight);
//- Camera
let	camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, SkyLim);
	camera.rotation.order = "YXZ";
	camera.position.z = -CamRot.z;
	camera.rotation.y = 180*DegRad;	// Default = looking in
let	CamObj = new THREE.Object3D();	// Armature base - use to rotate camera
	CamObj.rotation.order = "YXZ";
	CamObj.add(camera);
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	renderer.domElement.addEventListener("mousedown", onMouseDown, false);
	renderer.domElement.addEventListener("mouseup", onMouseUp, false);
	renderer.domElement.addEventListener("mousemove", onMouseMove, false);
	renderer.domElement.addEventListener('mousewheel', onMouseWheel, {capture: false, passive: false});
	renderer.domElement.addEventListener("touchstart", onTouchStart, false);
	renderer.domElement.addEventListener("touchmove", onTouchMove, false);
	document.getElementById("PAW").addEventListener("click", togglePause, false);
	document.getElementById("CAM").addEventListener("click", toggleCamera, false);
	document.getElementById("FST").addEventListener("click", toggleSpdU, false);
	document.getElementById("PTD").addEventListener("click", togglePitD, false);
	document.getElementById("SLO").addEventListener("click", toggleSpdD, false);
	document.getElementById("BKL").addEventListener("click", toggleBnkL, false);
	document.getElementById("CTR").addEventListener("click", toggleCntr, false);
	document.getElementById("BKR").addEventListener("click", toggleBnkR, false);
	document.getElementById("PTU").addEventListener("click", togglePitU, false);
	document.getElementById("YWL").addEventListener("click", toggleYawL, false);
	document.getElementById("YWR").addEventListener("click", toggleYawR, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);

//= HTML OVERLAY TEXT ==========================================================
let Air_SpdElement = document.getElementById("Air_Spd");	// Airspeed
let Air_SpdNode = document.createTextNode("");
	Air_SpdElement.appendChild(Air_SpdNode);
let Air_AltElement = document.getElementById("Air_Alt");	// Altitude
let Air_AltNode = document.createTextNode("");
	Air_AltElement.appendChild(Air_AltNode);
let Air_HdgElement = document.getElementById("Air_Hdg");	// Heading
let Air_HdgNode = document.createTextNode("");
	Air_HdgElement.appendChild(Air_HdgNode);
let Air_Spd, Air_Alt,Air_Hdg;

//= OBJECTS ====================================================================
//- Camera
let CtrObj = new THREE.Object3D();
	CtrObj.rotation.order = "YXZ";
	CtrObj.add(CamObj);
	scene.add(CtrObj);
//- Aircraft
	scene.add(air_.AirObj);
	
//= MAIN PROGRAM ===============================================================
	if (WebGPU.isAvailable() === false) {
		document.body.appendChild(WebGPU.getErrorMessage());
		throw new Error('No WebGPU support');
	}
	loadAll();

//= 0 LOAD ALL =================================================================
function loadAll() {
	loadSkyBox();
}

//= 1 INITIALIZE ===============================================================
function initAll() {
	initSkyBox();						// SkyCube, Fog and Lensflare
	initGrdTxt();
	grd_.SPS.copy(air_.MapSPS);
	initGrdMap(grd_,scene);
	makeRoads();
	makeTrees();
	makeAirObj(air_);
	initJetExh();
	prntHUDval(air_);
	// Show stats
	if (StsFlg > 0) {					// show stats
		stats = new Stats();
		stats.setMode(0);				// FPS only
		stats.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(stats.dom);
	}
	LodFlg = 1;
}

//= 2 RENDER ===================================================================
function rendAll() {
	if (PawsOn == 0 && LodFlg > 0) {
		moveAirObj(air_);
		moveJetExh();
		grd_.SPS.copy(air_.MapSPS);
		moveGrdMap(grd_);				// Move Grid Map
		moveRoads();
		moveTrees();
		if (StsFlg > 0) stats.update();	// update stats
	}
	prntHUDval(air_);
	moveCamera();
	renderer.render(scene, camera);		// Render
}

//= SKY BOX ====================================================================

function loadSkyBox() {
	let fpath = SBPath;
	let envMap = new THREE.CubeTextureLoader(loadingManager)
		.setPath(fpath)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace;	// ### r152
	scene.background = envMap;
	// LensFlare
	LF0Txt = txtrLoader.load(LF0Src);
	LF1Txt = txtrLoader.load(LF1Src);
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// SunLight Position
let SunPos = new THREE.Vector3(SunLLD.x,Mod360(180-SunLLD.y),SunLLD.z);
	SunPos = rotLLD(SunPos);	// Set Position above Light
	sunLight.position.copy(SunPos).normalize();	
	// Lensflare
let	spotLight = new THREE.PointLight(0xffffff);
	scene.add(spotLight);
	spotLight.position.copy(SunPos);
//	let LF = new Lensflare();	// Not Work with WebGPU
//	LF.addElement(new LensflareElement(LF0Txt, 256, 0));
//	LF.addElement(new LensflareElement(LF1Txt, 32, 0.2));
//	LF.addElement(new LensflareElement(LF1Txt, 256, 0.9));
//	spotLight.add(LF);
}

//- Rotates Vector -------------------------------------------------------------
function rotLLD(LLD) {
	let lat = LLD.x*DegRad;
	let lon = LLD.y*DegRad;
	// Latitude
	LLD.y = LLD.z * Math.sin(lat);
	LLD.z = LLD.z * Math.cos(lat);
	// Longitude
	LLD.x = LLD.z * Math.sin(lon);
	LLD.z = LLD.z * Math.cos(lon);
	return LLD;
}

//= GEOMAT =====================================================================

function initGrdTxt() {
	initGr0Txt();
	initGr1Txt();
	initGr2Txt();
}

function initGr0Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G0DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G0DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);			// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);			// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(GrdMul,GrdMul);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;	
		G0MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G0DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr1Siz,Gr1Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G1SPtr[n] = context.getImageData(0,0,Gr1Siz,Gr1Siz);				//
	}
}

function initGr1Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr1Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G0Indx.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G0Indx[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
//				let ImgDat = G0DPtr[stIndx[idx]];
				let ImgDat = G1SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G1DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G1DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		G1MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G1DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr2Siz,Gr2Siz);
		G2SPtr[n] = context.getImageData(0,0,Gr2Siz,Gr2Siz);
	}
}

function initGr2Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr2Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G2SPtr[G1Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G2DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G2DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;		// ###
			DatTxt.needsUpdate = true;
			G2MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

/* Make Grid Map Textures ====================================================*/

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

//= GRID MAP ===================================================================

function initGrdMap(grd_, scene) {
	init1GrMap(grd_.Grx[0], grd_, scene);
	init1GrMap(grd_.Grx[1], grd_, scene);
	init1GrMap(grd_.Grx[2], grd_, scene);
}

function moveGrdMap(grd_) {
	move1GrMap(grd_.Grx[0], grd_);
	move1GrMap(grd_.Grx[1], grd_);
	move1GrMap(grd_.Grx[2], grd_);
}

//= Init Grid Map ==============================================================

function init1GrMap(grx_, grd_, scene) {
	// Load Variables
	grx_.RCi = grx_.RCs-1;				// Max Index Value
	grx_.MZV[grx_.RCi] = 0;				// Z-Values
	grx_.MXV[grx_.RCi] = 0;				// X-Values
	grx_.Nor = grx_.RCi;					// Max North Square (updated)
	grx_.Est = grx_.RCi;					// Max East Square (updated)
	grx_.Num = grx_.RCs * grx_.RCs;		// Size of array
	grx_.Ptr[grx_.Num-1] = 0;				// Mesh Pointers
	if (grx_.Typ) {
		grx_.NSA = (grx_.RCs-grx_.RCF)/2;	// (27-3=6)
		grx_.EWA = grx_.NSA;
	}
	// Compute Starting Z and X Values
	let zx = -0.5*(grx_.RCs)*grx_.Siz+0.5*grx_.Siz;
	for (let i = 0; i < grx_.RCs; i++) {
		grx_.MZV[i] = zx;
		grx_.MXV[i] = zx;
		zx = zx + grx_.Siz;
	}
	
	// Common Variables
	let n, si, d2, yd0, xd0;
	let geometry = new THREE.PlaneGeometry(grx_.Siz, grx_.Siz);
	
	// Default to Prevent Err (Lower Left to Upper Right)
	let material = new MeshLambertNodeMaterial({colorNode: color(0xc00000)});
	// Assign Textures and Save Square Pointers
	for (let i = 0; i < grx_.Num; i++) {
		let mesh = new THREE.Mesh(geometry,material);
		if (grx_.Shd) mesh.receiveShadow = true;
		grx_.Ptr[i] = mesh;
	}
	let Lv1Idx = grd_.Idx[0];	// G0Indx
	let Lv2Idx = grd_.Idx[1];	// G1Indx
	let MatPtr;
	//
	if (grx_.Typ == 0) {
		n = 0;
		MatPtr = grd_.Mat[0];	// G0MPtr
		// Use Combination of Grid 0 3x3 Index and Grid 1 Index to Determine Material for Each Square 
		for (let yd = 0; yd < 9; yd++) {	// For each 3X3 section
			for (let xd = 0; xd < 9; xd++) {
				yd0 = yd * 81;
				xd0 = xd * 3;
				let MatIdx = Lv1Idx[Lv2Idx[n]];	//G1Indx points to 3X3 type, G0Indx points to sequence
				si = 0;
				// Within single 3x3 Grid
				for (let yd2 = 0; yd2 < 3; yd2++) {
					for (let xd2 = 0; xd2 < 3; xd2++) {
						si = yd2*3+xd2;
						d2 = yd0 + xd0 + yd2*27 + xd2;
						material = MatPtr[MatIdx[si]];
						grx_.Ptr[d2] = new THREE.Mesh(geometry,material);
						if (grx_.Shd) grx_.Ptr[d2].receiveShadow = true;
						si++;
					}
				}
				n++;		
			}
		}	
	}
	
	if (grx_.Typ == 1) {
		// 81 textures are repeated 9X on the full map
		// Assign Textures
		n = 0;
		MatPtr = grd_.Mat[1];	// G1MPtr
		for (let yd = 0; yd < 9; yd++) {
			for (let xd = 0; xd < 9; xd++) {
				// From Upper Left
				material = MatPtr[Lv2Idx[n]];
				yd0 = yd*grx_.RCs;
				// Assign Textures and Save Square Pointers
				for (let ad = 0; ad < 3; ad++) {
					d2 = yd0 + xd + ad*9*grx_.RCs;
					for (let bd = 0; bd < 3; bd++) {
						grx_.Ptr[d2] = new THREE.Mesh(geometry,material);
						if (grx_.Shd) grx_.Ptr[d2].receiveShadow = true;
						d2 = d2 + 9;
					}
				}
				n++;
			}
		}
	}
	
	if (grx_.Typ == 2) {
		// 27 textures are repeated 27X on the full map
		n = 0;
		MatPtr = grd_.Mat[2];	// G2MPtr
		for (let yd = 0; yd < 3; yd++) {	// Source
			for (let xd = 0; xd < 3; xd++) {
				material = MatPtr[n];
				yd0 = yd*grx_.RCs;			// Within the lower left square
				// Assign Textures and Save Square Pointers
				for (let ad = 0; ad < 9; ad++) {
					d2 = yd0 + xd + ad*3*grx_.RCs;
					for (let bd = 0; bd < 9; bd++) { 
						grx_.Ptr[d2] = new THREE.Mesh(geometry,material);
						if (grx_.Shd) grx_.Ptr[d2].receiveShadow = true;
						d2 = d2 + 3;
					}
				}
				n++;
			}
		}
	}
	
	n = 0;
	// Set Starting Position of Squares
	for (let y = 0; y < grx_.RCs; y++) {		// Row
		for (let x = 0; x < grx_.RCs; x++) {	// Column
			grx_.Ptr[n].rotation.x = -90*DegRad;
			scene.add(grx_.Ptr[n]);
			grx_.Ptr[n].position.set(grx_.MXV[x],-grd_.SPS.y,-grx_.MZV[y]);
			n++;
		}
	}
}

//= Move Grid Map ==============================================================

function move1GrMap(grx_, grd_) {
	let grd1_ = grd_.Grx[1];
	let grd2_ = grd_.Grx[2];
	let j = 0;
	let v = 0; 
	let max = 0.5*grx_.RCs*grx_.Siz;
	let min = -max;
	// Update Z, X and Y-Values
	for (let i = 0; i < grx_.RCs; i++) {
		grx_.MZV[i] = grx_.MZV[i] - grd_.SPS.z;	// Rows
		grx_.MXV[i] = grx_.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = grx_.Nor;
		if (grx_.MZV[j] >= max) {
			v = min+(grx_.MZV[j]-max);
			for (let i = 0; i < grx_.Stp; i++) {
				grx_.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = grx_.RCi;
				v = v - grx_.Siz;
			}
			grx_.Nor = grx_.Nor - grx_.Stp;
			if (grx_.Nor < 0) grx_.Nor = grx_.Nor + grx_.RCs;
			if (grx_.Typ == 0) grd1_.NSA = grd1_.NSA - 1;
			if (grx_.Typ == 1) {
				grx_.NSA = grx_.NSA + grx_.Stp;
				grd2_.NSA = grd2_.NSA - 1;
			}
			if (grx_.Typ == 2) grd2_.NSA = grd2_.NSA + grx_.Stp;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = grx_.Nor + 1;
		if (j > grx_.RCi) j = 0;
		if (grx_.MZV[j] <= min) {
			v = max-(min-grx_.MZV[j]);
			for (let i = 0; i < grx_.Stp; i++) {
				grx_.MZV[j] = v;
				j++;
				if (j > grx_.RCi) j = 0;
				v = v + grx_.Siz;
			}
			grx_.Nor = grx_.Nor + grx_.Stp;
			if (grx_.Nor > grx_.RCi) grx_.Nor = grx_.Nor - grx_.RCs;
			if (grx_.Typ == 0) grd1_.NSA = grd1_.NSA + 1;
			if (grx_.Typ == 1) {
				grx_.NSA = grx_.NSA - grx_.Stp;
				grd2_.NSA = grd2_.NSA + 1;
			}
			if (grx_.Typ == 2) grd2_.NSA = grd2_.NSA - grx_.Stp;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = grx_.Est;
		if (grx_.MXV[j] >= max) {
			v = min+(grx_.MXV[j]-max);
			for (let i = 0; i < grx_.Stp; i++) {
				grx_.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = grx_.RCi;
				v = v - grx_.Siz;
			}
			grx_.Est = grx_.Est - grx_.Stp;
			if (grx_.Est < 0) grx_.Est = grx_.Est + grx_.RCs;
			if (grx_.Typ == 0) grd1_.EWA = grd1_.EWA - 1;
			if (grx_.Typ == 1) {
				grx_.EWA = grx_.EWA + grx_.Stp;
				grd2_.EWA = grd2_.EWA - 1;
			}
			if (grx_.Typ == 2) grd2_.EWA = grd2_.EWA + grx_.Stp;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = grx_.Est + 1;
		if (j > grx_.RCi) j = 0;	
		if (grx_.MXV[j] <= min) {
			v = max-(min-grx_.MXV[j]);
			for (let i = 0; i < grx_.Stp; i++) {			
				grx_.MXV[j] = v;
				j++;
				if (j > grx_.RCi) j = 0;
				v = v + grx_.Siz;
			}
			grx_.Est = grx_.Est + grx_.Stp;
			if (grx_.Est > grx_.RCi) grx_.Est = grx_.Est - grx_.RCs;
			if (grx_.Typ == 0) grd1_.EWA = grd1_.EWA + 1;
			if (grx_.Typ == 1) {
				grx_.EWA = grx_.EWA - grx_.Stp;
				grd2_.EWA = grd2_.EWA + 1;
			}
			if (grx_.Typ == 2) grd2_.EWA = grd2_.EWA - grx_.Stp;
		}
	}
	// Set Position
	let n = 0;
	for (let r = 0; r < grx_.RCs; r++) {	// Row
		for (let c = 0; c < grx_.RCs; c++) {	// Col
			grx_.Ptr[n].position.set(grx_.MXV[c],-grd_.SPS.y,-grx_.MZV[r]);
			grx_.Ptr[n].visible = true;	// Default for Outer Grid
			n++;
		}
	}
	// Outer Grids Only - Make Cut-Out Area Invisible
	if (grx_.Typ) {
		let r = grx_.Nor + 1 + grx_.NSA;			// Get Lower index
		if (r > grx_.RCi) r = r - grx_.RCs;
		let c = grx_.Est + 1 + grx_.EWA;			// Get Left Index
		if (c > grx_.RCi) c = c - grx_.RCs;
		for (let i = 0; i < grx_.RCF; i++) {
			n = r * grx_.RCs + c;
			if (n < 0) n = n + grx_.Num;
			if (n > grx_.Num) n = n - grx_.Num;
			let n2 = (r+1) * grx_.RCs - 1;
			if (n2 > grx_.Num) n2 = n2 - grx_.Num;
			if (n2 < 0) n2 = n2 + grx_.Num;
			for (let j = 0; j < grx_.RCF; j++) {
				grx_.Ptr[n].visible = false;
				n++;
				if (n > n2) n = n - grx_.RCs; 
				if (n < 0) n = n + grx_.Num;
				if (n > grx_.Num) n = n - grx_.Num;
			}
			r++;
			if (r > grx_.RCi) r = r - grx_.RCs;
		}
	}
}

//= ROADS ======================================================================

//- Make Roads -----------------------------------------------------------------

function makeRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

//- Move Roads -----------------------------------------------------------------

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function initRoad2(Rod) {

	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(20*Ft2Mtr, Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz, 20*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*.999+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - grd_.SPS.z;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*.999+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

//= TREES ======================================================================

//- Make Trees ------------------------------------------------------------------

function makeTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)		// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;	// ###
	txttre.needsUpdate = true;
	let mtltre = new MeshLambertNodeMaterial({colorNode: texture(txttre)});
	let mtltrn = new MeshLambertNodeMaterial({colorNode: color(0x161005)});
	let mtlshd = new MeshBasicNodeMaterial({colorNode: color(0x000000),transparent:true,opacity:0.5,depthWrite: false});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
		TreePZ[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
	}
}

//- Move Trees -----------------------------------------------------------------

function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*GrdSiz;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-air_.MapPos.x-GrdSiz/2;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		let z = air_.MapPos.z-TreePZ[n]-GrdSiz/2;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		let y = -grd_.SPS.y*.99+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

//= AIR OBJ ====================================================================

//- Make AirObj ----------------------------------------------------------------

function makeAirObj(air_) {
	// Front
	let mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 2.5, 15, 3, 1, "false"), new MeshStandardNodeMaterial({colorNode:color(0xff00ff)}));
	mesh.rotation.x = -Math.PI/2;
	mesh.position.z = -5;
	mesh.castShadow = true;
	air_.AirPBY.add(mesh);
	// Back
	mesh = new THREE.Mesh(new THREE.CylinderGeometry(.25, 2.5, 25, 3, 1, "false"), new MeshStandardNodeMaterial({colorNode:color(0xff00ff)}));
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.y = Math.PI;
	mesh.position.z = 15;
	mesh.castShadow = true;
	air_.AirPBY.add(mesh);
	// Wing
	mesh = new THREE.Mesh(new THREE.BoxGeometry(50,.25,5), new MeshStandardNodeMaterial({colorNode:color(0xffffff)}));
	mesh.position.y = -.5;
	mesh.position.z = 2.5;
	mesh.castShadow = true;
	air_.AirPBY.add(mesh);
	// HTail
	mesh = new THREE.Mesh(new THREE.BoxGeometry(12.5,.25,3.25), new MeshStandardNodeMaterial({colorNode:color(0xffffff)}));
	mesh.position.y = -.5;
	mesh.position.z = 25;
	mesh.castShadow = true;
	air_.AirPBY.add(mesh);
	// VTail
	mesh = new THREE.Mesh(new THREE.BoxGeometry(.25,6.25,3.25), new MeshStandardNodeMaterial({colorNode:color(0xff00ff)}));
	mesh.position.y = 2.5;
	mesh.position.z = 25;
	mesh.castShadow = true;
	air_.AirPBY.add(mesh);
	air_.AirPBY.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
}

//- Move AirObj ----------------------------------------------------------------
function moveAirObj(air_) {
	// Pitch -----------------------------------------------
	air_.RotDif.x = air_.InpRot.x;				// Change to Pitch Speed
	// Self-centering
	if (air_.RotDif.x > -0.001 && air_.RotDif.x < 0.001) {
		if (air_.AirRot.x == 0) air_.RotDif.x = 0;
		if (air_.AirRot.x < 5 && air_.AirRot.x > -5) air_.RotDif.x = -0.01 * air_.AirRot.x;
	}
	// Bank ------------------------------------------------
	air_.RotDif.z = air_.InpRot.z;				// Change to Bank Speed
	// Self-centering
	if (air_.RotDif.z > -0.001 && air_.RotDif.z < 0.001) {
		if (air_.AirRot.z == 0) air_.RotDif.z = 0;
		if (air_.AirRot.z < 7.5) air_.RotDif.z = -0.01 * air_.AirRot.z;
		if (air_.AirRot.z > 352.5) air_.RotDif.z = 0.01 * (360 - air_.AirRot.z);
	}
	// Yaw
	air_.RotDif.y = air_.InpRot.y;
	// Turn Rate = tan(bank) * G/V = tan(bank) * 32.174 / 300 fps (aprox 200 mph)
	let ACHSpd = 0;
	if (air_.RotDif.z > -InpVal.z && air_.RotDif.z < InpVal.z) {
		let ACBrad = air_.AirRot.z * DegRad;
		ACHSpd = Math.tan(ACBrad) * 32.174 / 300;
		if (ACHSpd > 0.2) ACHSpd = 0.2;
		if (ACHSpd < -0.2) ACHSpd = -0.2;
		ACHSpd = ACHSpd * Math.cos(air_.AirRot.x*DegRad);
	}
	if (air_.AirRot.z > 90 && air_.AirRot.z < 270) ACHSpd = -ACHSpd;
	// Rotate
	// Make Bank, Pitch and Yaw Rotations to air_.AirObj and air_.AirPBY
	air_.AirPBY.rotation.z = -air_.RotDif.z*DegRad;
	air_.AirPBY.rotation.x = air_.RotDif.x*DegRad;
	air_.AirPBY.rotation.y = -air_.RotDif.y*DegRad;
	// Transfer Combined Rotation to air_.AirObj
	air_.AirPBY.getWorldQuaternion(quaternion);
	air_.AirObj.setRotationFromQuaternion(quaternion);
	// Zero Out air_.AirPBY Rotations (so values not doubled)
	air_.AirPBY.rotation.z = 0;
	air_.AirPBY.rotation.x = 0;
	air_.AirPBY.rotation.y = 0;
	// Load Resulting Values into Variables (for display)
	air_.AirRot.z = Mod360(-air_.AirObj.rotation.z*RadDeg);
	air_.AirRot.x = air_.AirObj.rotation.x*RadDeg;
	// Update air_.AirObj Heading for Bank
	air_.AirRot.y = Mod360(-air_.AirObj.rotation.y*RadDeg+ACHSpd);
	air_.AirObj.rotation.y = -air_.AirRot.y*DegRad;
	// Compute Speed
	air_.SpdKPH = air_.SpdKPH + air_.InpSpd;		// KPH
	if (air_.SpdKPH < 50*Mil2Km) air_.SpdKPH = 50*Mil2Km;
	if (air_.SpdKPH > 1200*Mil2Km) air_.SpdKPH = 1200*Mil2Km;
	air_.InpSpd = 0;
	// SpdMPF
	air_.SpdMPS = air_.SpdKPH/3.6;	// Aircraft Speed (FPS)
	air_.SpdMPF = air_.SpdMPS*DLTime;		// Aircraft Speed (DLT)
	// Map Speed
	let ACPrad = air_.AirRot.x*DegRad;
	let ACHrad = air_.AirRot.y*DegRad;
	air_.MapSpd.y = air_.SpdMPF * Math.sin(ACPrad);
	let GS = air_.SpdMPF * Math.cos(ACPrad);
	air_.MapSpd.z = GS * Math.cos(ACHrad);
	air_.MapSpd.x = GS * Math.sin(ACHrad);
	// Position in Meters
	air_.MapPos.y = air_.MapPos.y + air_.MapSpd.y;
	air_.MapPos.z = air_.MapPos.z + air_.MapSpd.z;
	air_.MapPos.x = air_.MapPos.x + air_.MapSpd.x;
	// Results
	air_.MapSPS.x = air_.MapSpd.x;
	air_.MapSPS.y = air_.MapPos.y;
	air_.MapSPS.z = air_.MapSpd.z;
}

//= JET EXHAUST ===============================================================

//- Init Jet Exhaust ----------------------------------------------------------
function initJetExh() {
	let x,y,z;
	for (let i = 0; i < SmkPts; i++) {
	// create a particle with random position values, -250 -> 250
		x = Math.random() * 4 - 2;		// +/-5
		y = Math.random() * 4 - 2;		// 
		z = Math.random() * SmkLim;		//
		SmkPos.push(x,y,z);				// position
		SmkCol.push(240,240,240,SmkDns);	// color and density
	}
	// create the particle system
	let geometry = new THREE.BufferGeometry();
	geometry.setAttribute('position', new THREE.Float32BufferAttribute(SmkPos, 3));
	geometry.setAttribute('color', new THREE.Float32BufferAttribute(SmkCol, 4));
	let material = new THREE.PointsMaterial({size: 4, vertexColors: true, transparent: true});
	SmkPtr = new THREE.Points(geometry, material);
	SmkPtr.position.z = 30;				// behind the airplane
	// add it to the scene
	air_.AirPBY.add(SmkPtr);
}

//- Move Jet Exhaust -----------------------------------------------------------
function moveJetExh() {
	let pos = SmkPtr.geometry.attributes.position.array;
	let col = SmkPtr.geometry.attributes.color.array;
	let p = 0;
	let q = 0;
	for (let i = 0; i < SmkPts; i++) {
		pos[p+2] = pos[p+2]+SmkSpd;		// Z distance
		if (pos[p+2] > SmkLim) {
			pos[p+2] = pos[p+2]-SmkLim;	// cut-off
			col[q+3] = SmkDns;			// density
		}
		col[q+3] = SmkFad*col[q+3];
		p += 3;
		q += 4;
	}
	SmkPtr.geometry.attributes.position.needsUpdate = true;
	SmkPtr.geometry.attributes.color.needsUpdate = true;
}

//= MOVE CAMERA ================================================================

function moveCamera() {
	// In external view, the camera is facing in and the armature is pointing out:
	// * x.rotation = -CamLat
	// * y.rotation = CamLon + 180
	camera.position.z = -CamRot.z;
	CamObj.rotation.x = Mod360(-CamRot.x)*DegRad;
	CamObj.rotation.y = Mod360(180-CamRot.y)*DegRad;
}

//= 4 MISC SUBROUTINES =========================================================

//- Converts degrees to 360 ----------------------------------------------------
function Mod360(deg) {
	while (deg < 0) deg = deg+360;	// Make deg a positive number
	deg = deg % 360;				// Compute remainder of any number divided by 360
return deg;}

//- Make Mesh ------------------------------------------------------------------
function makMsh() {
	let geometry = new THREE.BoxGeometry(0.01,0.01,0.01); 
	let material = new MeshBasicNodeMaterial({transparent:true,opacity:0});
	let mesh = new THREE.Mesh(geometry, material);
return mesh;}

/* Outputs ==================================================================*/

// Print HUD Values
function prntHUDval(air_) {
	Air_Spd = air_.SpdKPH*Km2Mil;		// Aircraft Speed (MPH)
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Alt = air_.MapPos.y*Mtr2Ft;		// Aircraft Altitude (feet)
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);
	Air_Hdg = air_.AirRot.y;				// Aircraft Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
}

//= 5 INPUTS ===================================================================

//= Keyboard Input =============================================================

//- Key Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	if (event.keyCode == K_SpdU) air_.InpSpd = 1*Mil2Km;	// Speed Up
	if (event.keyCode == K_SpdD) air_.InpSpd = -1*Mil2Km;	// Speed Dn
	if (event.keyCode == K_BnkL) air_.InpRot.z = -InpVal.z;	// Bank Left
	if (event.keyCode == K_BnkR) air_.InpRot.z = InpVal.z;	// Bank Right
	if (event.keyCode == K_PitU) air_.InpRot.x = InpVal.x;	// Pitch Up
	if (event.keyCode == K_PitD) air_.InpRot.x = -InpVal.x;	// Pitch Down
	if (event.keyCode == K_Cntr) toggleCntr();				// Center
	if (event.keyCode == K_YawL) air_.InpRot.y = -InpVal.y;	// Yaw Left
	if (event.keyCode == K_YawR) air_.InpRot.y = InpVal.y;	// Yaw Right
	if (event.keyCode == K_Paws) togglePause();				// Pause
}

//- Key Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	if (event.keyCode == K_SpdU) air_.InpSpd = 0;			// Speed Up
	if (event.keyCode == K_SpdD) air_.InpSpd = 0;			// Speed Dn
	if (event.keyCode == K_BnkL) air_.InpRot.z = 0;			// Bank Left
	if (event.keyCode == K_BnkR) air_.InpRot.z = 0;			// Bank Right
	if (event.keyCode == K_PitU) air_.InpRot.x = 0;			// Pitch Up
	if (event.keyCode == K_PitD) air_.InpRot.x = 0;			// Pitch Down
	if (event.keyCode == K_YawL) air_.InpRot.y = 0;			// Yaw Left
	if (event.keyCode == K_YawR) air_.InpRot.y = 0;			// Yaw Right
}

//= Mouse Input ================================================================

function onMouseDown(event) {
	event.preventDefault();
	PanFlg = 1;
	onPointerDownX = event.clientX;
	onPointerDownY = event.clientY;
	onPointerDownLon = CamRot.y;
	onPointerDownLat = CamRot.x;
}

function onMouseUp(event) {
	PanFlg = 0;
}

function onMouseMove(event) {
//- Panning View
	if (PanFlg > 0) {
		CamRot.x = (onPointerDownY - event.clientY) * 0.2 + onPointerDownLat;
		CamRot.x = Math.max(-CamLtX, Math.min(CamLtX, CamRot.x));
		CamRot.y = (event.clientX - onPointerDownX) * 0.2 + onPointerDownLon;
		CamRot.y = Mod360(CamRot.y);
	}
}

function onMouseWheel(event) {
	CamRot.z = CamRot.z + event.deltaY * CamDif;
	CamRot.z = Math.max(CamMin, Math.min(CamMax, CamRot.z));
}

//= Touch Screen Input =========================================================

function onTouchStart(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		onPointerDownX = event.touches[0].clientX;
		onPointerDownY = event.touches[0].clientY;
		onPointerDownLon = CamRot.y;
		onPointerDownLat = CamRot.x;
	}
}

function onTouchMove(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		CamRot.y = (onPointerDownX - event.touches[0].clientX) * 0.2 + onPointerDownLon;
		CamRot.y = Mod360(CamRot.y);
		CamRot.x = (event.touches[0].clientY - onPointerDownY) * 0.2 + onPointerDownLat;
		CamRot.x = Math.max(-85, Math.min(85, CamRot.x));
	}
}

//= Buttons Input ==============================================================

//- Toggle Pause
function togglePause() {
	PawsOn = 1 - PawsOn;
}

//- Change Camera View
function toggleCamera() {
	// From External to Linked
	if (CamVOn == 0) {
		CtrObj.remove(CamObj);
		air_.AirPBY.add(CamObj);			// Link camera to aircraft
		let OldVal = 0;
		OldVal = CmODst;
		CmODst = CamRot.z;			// Old Camera Distance
		CamRot.z = OldVal;			
		CamDif = CmBDif;			// In/out speed
		CamMax = CmBMax;			// Max distance
		CamMin = CmBMin;			// Max distance
		CamVOn = 1;	
	}
	// From Linked to External
	else if (CamVOn == 1) {
		air_.AirPBY.remove(CamObj);
		CtrObj.add(CamObj);			// Link camera to map
		let OldVal = 0;
		OldVal = CmODst;
		CmODst = CamRot.z;			// Old Camera Distance
		CamRot.z = OldVal;
		OldVal = CmOLon;
		CmOLon = CamRot.y;			// Old Camera Heading
		CamRot.y = OldVal;					
		CamDif = CmADif;			// In/out speed
		CamMax = CmAMax;			// Max distance
		CamMin = CmAMin;			// Max distance
		CamVOn = 0;
	}
}

//- Flight Controls

function toggleSpdU() {
	if (air_.InpSpd == 0) air_.InpSpd = 10;
	else air_.InpSpd = 0;
}

function togglePitD() {
	if (air_.InpRot.x == 0) air_.InpRot.x = -InpVal.x;
	else air_.InpRot.x = 0;
}

function toggleSpdD() {
	if (air_.InpSpd == 0) air_.InpSpd = -10;
	else air_.InpSpd = 0;
}

function toggleBnkL() {
	if (air_.InpRot.z == 0) air_.InpRot.z = -InpVal.z;
	else air_.InpRot.z = 0;
}

function toggleCntr() {
	air_.InpRot.z = 0;
	air_.InpRot.x = 0;
	air_.InpRot.y = 0;
	air_.AirRot.z = 0;
	air_.AirRot.x = 0;
	air_.AirObj.rotation.z = 0;			// No Bank
	air_.AirObj.rotation.x = 0;			// No Pitch
}

function toggleBnkR() {
	if (air_.InpRot.z == 0) air_.InpRot.z = InpVal.z;
	else air_.InpRot.z = 0;
}

function togglePitU() {
	if (air_.InpRot.x == 0) air_.InpRot.x = InpVal.x;
	else air_.InpRot.x = 0;
}

function toggleYawL() {
	if (air_.InpRot.y == 0) air_.InpRot.y = -InpVal.y;
	else air_.InpRot.y = 0;
}

function toggleYawR() {
	if (air_.InpRot.y == 0) air_.InpRot.y = InpVal.y;
	else air_.InpRot.y = 0;
}

//= Window Resize Input ========================================================

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
