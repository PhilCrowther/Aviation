<!doctype html>
<html>

<!--
Copyright 2017-24, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 8 May 2024

A flight simulation of an animated airplane model over procedural land using
-->

<head>
<title>FlightSim Pup Land Nodes WebGPU</title>
<link rel="stylesheet" href="styles/body2.css">
</head>

<body oncontextmenu="return false;">

<canvas hidden id="canvas" width=1024 height=1024></canvas>

<div id="container">
	<div class="overlay1">
		<p>Flight Model Demo</p>
	</div>
	<div class="overlay2">
		<div>Throttle: <span id="AC_Powr"></span></div>
		<div>SpeedUPH: <span id="Spd_UPH"></span></div>	
		<div>Heading : <span id="AC_Head"></span></div>
		<div>Altitude: <span id="AC_Hite"></span></div>
		<div>CoefLift: <span id="Cf_Lift"></span></div>
	</div>
	<div class="overlay3">
		<p>
		<div><span id="On_Paws"></span></div>
		<div><span id="On_Info01"></span></div>
		<br>
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
		<div><span id="On_Info05"></span></div>
		<div><span id="On_Info06"></span></div>
		<div><span id="On_Info07"></span></div>
		<div><span id="On_Info08"></span></div>
		<div><span id="On_Info09"></span></div>
		</p>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.165.0/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/",
			"three/nodes": "https://unpkg.com/three@0.165.0/examples/jsm/nodes/Nodes.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {
		color,
		float,
		texture,
		MeshLambertNodeMaterial,
		MeshBasicNodeMaterial
} from 'three/nodes';
import WebGPU from 'three/addons/capabilities/WebGPU.js';
import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
import Stats from "three/addons/libs/stats.module.js";
import {Lensflare, LensflareElement} from "three/addons/objects/Lensflare.js";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
// Special Modules
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdMap3.js";
import {Flight,Mod360,PoM360,MaxVal,rotLLD,makMsh} from "https://PhilCrowther.github.io/Aviation/jsm/Flight3.js";

//= GENERAL ===================================================================
//- AIRPLANE: Start -----------------------------------------------------------
let USorSI = "US";					// Units of Measurement (US or SI)
let BegSpd = 100;					// Speed (mph)
let BegEWP = 0;						// EW Position (feet)
let BegAlt = 2000;					// Altitude (feet)
let BegNSP = 0;						// NS Position (feet)
let BegPwr = 0;						// Initial Power Percent
//- AIRPLANE: Flight -----------------------------------------------------------
let KeyVal = new THREE.Vector3(1,.05,1);	// Key Values (Yaw = turn rate in 15 deg bank)
let InpKey = new THREE.Vector3();	// Inputs - Keys
let	MosMul = new THREE.Vector3(1.0,1.0,1.0); // Adjustment to PYBmul (default = 1)
let PwrMul = 0.0001;				// Power % Input - Mouse Multiplier
let PwrDif = 0;						// Power % Input - Value
let InpBrk = 0;						// Brakes
//- Mouse Delays ...............................................................
//- (x = diverted, y = released, z = stored)
let PwrMsD = new THREE.Vector3(1-1/30,1/15,0); // Power
let CfLMsD = new THREE.Vector3(1-1/30,1/15,0); // CfL
let BnkMsD = new THREE.Vector3(1-1/30,1/15,0); // Bank
//- POINTER LOCK CONTROLS ------------------------------------------------------
let InpMos = new THREE.Vector2();	// Inputs - Mouse
let _changeEvent = {type: 'change'};
let _lockEvent = {type: 'lock'};
let _unlockEvent = {type: 'unlock'};

//= CONSTANTS ==================================================================
//	Time
let	DLTime = 1/60;					// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;			//
//	Conversions
var DegRad = Math.PI / 180;			// Convert Degrees to Radians
let Ft2Mtr = 0.3048;				// Convert Feet to Meters
let Mtr2Ft = 1/0.3048;
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//	Default Constants
let	GrvMPS = 9.80665; 				// Gravity (mps)
//	Starting Constants per frame
let GrvDLT = GrvMPS*DLTim2;
//	Starting Air Density				
let	AirDSL = 1.225;					// Density - Sea Level (kg/m3)
//- Convert Starting Values
if (USorSI = "US") {
	BegSpd = BegSpd*Mil2Km;
	BegEWP = BegEWP*Ft2Mtr;
	BegAlt = BegAlt*Ft2Mtr;
	BegEWP = BegNSP*Ft2Mtr;
}

/* = INPUT VALUES ============================================================*/
// Background
let SkyLim = 100000;				// Used for Camera and SkyCube
let SkyCol = 0xa9e5ff;				// Color of Sky and Fog
let FogCol = 0xa9e5ff;				// Color of Sky and Fog
let SunCol = 0xffffff;				// Sun
//	Light
let	SunLLD = new THREE.Vector3(23,312,1000);	// Lat,Lon,Dst for Sun Mesh and Lensflare
let SunInt = 3;						// Default intensity of light/sun
// Camera
let CamPit = 0;						// Ptch - Default
let CamPmx = 45;					// Ptch - Max (down)
let CamPmn = 300;					// Ptch - Min
let CamHed = 0;						// Head - Default
let CamHmx = 100;					// Head - Max
let CamHmn = 260;					// Head - Min
let CamVCD = 4.077;					// Pilot Head - Distance
let CamVCA = 56.5;					// Pilot Head - Angle	
// Flags
let PawsOn = 0;						// Pause
let InfoOn = 0;						// Info
let LodFlg = 0;
let SndFlg = 0;
let LFFlag = 1;						// Lensflare flag	
// Rolling Average of DLTime
let DLTnum = 10;					// Number of items in average		
let DLTarr = [0,0,0,0,0,0,0,0,0,0];	// Array of Values
let DLTidx = 0;						// Index
let DLTnow = 0;						// Current DLTime
// Stats
let StsFlg = 1;						// Stats ((0 = off, 1 = on)
let stats = 0;
// RotVec
let VectRX = 0;
let VectRY = 0;
let VectRZ = 0;
//- TEMP
let GrdZed = 0;
let MinAlt = 5;
let GrFlag = 0;

/* = FIXED VALUES ============================================================*/
/* = General -----------------------------------------------------------------*/
// Camera
let CamDst = 15;					// Distance from model (meters)

//= MY AIRPLANE ================================================================
//	Airplane Data
let	flight = 0;
let air_ = {
		// General Variables
		DLTime: DLTime,				// Seconds per frame (can vary)
		GrvMPS: GrvMPS,				// Gravity (ups)
		AirDSL: AirDSL,				// Air Density (varies with altitude)
		// Designators
		AirIDN: 1,					// Aircraft Type: 1 = Pup
		// Airplane Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Vector3(0,0,0),	// Rotation (in degrees)
		AirObj: makMsh(),			// Airplane Object 
		AirPBY: makMsh(),			// Changes in radians
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(0,0,0),	// Change
		// Airplane Speed
		SpdKPH: BegSpd,				// Speed in KPH
		SpdMPS: BegSpd/3.6,			// Speed - meters per second
		SpdMPF: (BegSpd/3.6)*DLTime,	// Speed - meters per frame	
		// Airplane Map Speed and Position
		MapSpd: new THREE.Vector3(),		// Map Speed
		MapPos: new THREE.Vector3(BegEWP,BegAlt,BegNSP),	// Map Position
		MapSPS: new THREE.Vector3(0,BegAlt,0),	// MSX, MPY, MSZ (meters)
		// Variables Obtained from Flight
		PwrPct: BegPwr,				// % of Primary Power (0 to 1) (Main and Flight)
		SupPct: 0,					// Percent of Supplemental Power (War Enmergency or Afterburner)
		CfLift: 0,					// Coefficient of Lift (user input) - determines lift
		CfFlap: 0,					// Coefficient of Lift due to flaps (user input)
		FlpPct: 0,					// Percent of Flaps
		LngPct: 0,					// Percent of Landing Gear
		BrkPct: 0,					// Percent of Air Brakes
		SplPct: 0,					// Percent of Spoiler
		AGBank: 0,					// Aileron Bank on Ground
		BrkVal: 0,					// Brakes
		GrdZed: 0,					// Ground level (default)
		GrdFlg: 0,					// Ground Flag (1 = on ground)
		ACPAdj: 0,					// Airplane pitch adjustment
		MovFlg: 0,					// If Sitting on a Moving Object
		// Values for the Selected Airplane Type (obtained from Flight)
		CfLMax: 0,					// Maximum Coefficient of Lift
		FlpCfL: 0,					// Max Flap Cfl (0.2*CfLMax)
		ACMass: 0,					// Airplane Mass
		Weight: 0,					// Used by autopilots
		PYBmul: new THREE.Vector3(0,0,0), // Airplane Pitch/Yaw/Bank Multiplier
		BnkMax: 0,					// Maximum bank rate
	}
// 
// Adjustments
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY);				// PBY includes air_.

//- Load Models and Animations -------------------------------------------------
//	File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/pup/";	// Used to load models and sounds
//	Animation Mixers - External Model
let ACFile = "pup_flyt_npa.glb";	// Name of aircraft model file (rotated blender file)
// Aircraft Animations
let anmfps = 24;					// Blender FPS
let aoarng = 20;					// AoA range (model)
// Mixers
var mxProp = 0;						// Propeller
var mxRudr = 0;						// Rudder
var mxElev = 0;						// Elevator
var mxAlTL = 0;						// AileronTL
var mxAlTR = 0;						// AileronTR
var mxAlBL = 0;						// AileronTL
var mxAlBR = 0;						// AileronTR
// All range from 0 to 360 with center at 180
var elvatr = 180;					// Elevator 	degrees = +/- 360
var rudder = 180;					// Rudder 		degrees = +/- 360
var aillft = 180;					// AileronL 	degrees = +/- 360
var ailrgt = 180;					// AileronR 	degrees = +/- 360
var rotaoa = 180;					// AoA 			degrees = +/- 15
var spnprp = 180;					// Taildrag 	degrees = 0 to 360
// Sounds
let acsnd1 = "pup.mp3";				// File (my engine)
let acvol1 = 0.1;					// Volume
let acsnd3 = "pup_gun.mp3";			// File (my guns)
let acvol3 = 0.5;					// Volume
let xpsnd1 = "fm2_prop.wav";		// File (xp prop)
let xpvol1 = 1.0;					// Volume
let RefDst = 25;					// Reference distance for Positional Sound

//= TEXTURES ===================================================================
//- SkyBox
let SBPath = "https://threejs.org/examples/textures/cube/skyboxsun25deg/";
//-	LensFlare
let LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let LF1Src = "https://threejs.org/examples/textures/lensflare/hexangle.png";
let LF0Txt, LF1Txt = 0;

/* = Textures Data ===========================================================*/
// All textures are 512X512
let dqSize = 1024;
let dqArea = dqSize*dqSize;
let dtSize = 512;
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;						// Total Textures

// Canvas
let canvas = document.getElementById("canvas");
let	context = canvas.getContext('2d');

/* = Grid 4 Data =============================================================*/
// 1/4 section squares (1/2 mile X 1/2 mile)
// Variables
let GrdMul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];

// Colors
let GrdDrt = "#1c160e";				// Color of underlying dirt (affects brightness)
let drtclr = [0x8e6d3d,0x47361e];		// Dirt
let pstclr = [0x00b000,0x005000];		// Pasture
let cvrclr = [0x75b24c,0x466b2d];		// Green
let whtclr = [0xfbf4e5,0xeabb63];		// Wheat
let bnsclr = [0xacd193,0x5d8e3d];		// Beans

//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
// [https://icolorpalette.com/color/dirt-brown

let count0;

//= MATERIALS ==================================================================

//= Grid 0 Data ================================================================
	
// Image Data
let G0DPtr = [];
	G0DPtr[txtTot-1] = 0;

// Materials
let G0MPtr = [];
	G0MPtr[txtTot-1] = 0;
	
// Patterns for Grid 5 3X3 Textures
// Also used to draw Grid 4 textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G0Id00 = [4,3,5,4,3,0,5,2,1];
let G0Id01 = [3,0,4,1,2,4,5,3,5];
let G0Id02 = [5,1,3,4,5,0,2,4,3];
let G0Id03 = [2,4,1,3,5,3,5,0,4];
let G0Id04 = [5,1,5,0,3,4,2,4,3];
let G0Id05 = [3,0,5,3,4,5,1,2,4];
let G0Id06 = [2,0,3,5,3,1,4,4,5];
let G0Id07 = [1,5,4,3,5,0,2,4,3];
let G0Id08 = [2,3,0,5,3,1,4,5,4];
let G0Id09 = [0,2,5,3,4,3,5,1,4];	// 1 = airport
let G0Id10 = [4,3,5,4,5,2,1,3,0];
let G0Id11 = [4,5,3,1,0,4,3,5,2];
let G0Id12 = [3,1,2,4,5,3,5,0,4];
let G0Id13 = [0,5,3,1,4,2,4,3,5];
let G0Id14 = [1,4,2,5,3,0,4,5,3];
let G0Id15 = [4,1,5,0,3,4,3,5,2];
let G0Indx = [
		G0Id00,G0Id01,G0Id02,G0Id03,G0Id04,G0Id05,G0Id06,G0Id07,G0Id08,G0Id09,
		G0Id10,G0Id11,G0Id12,G0Id13,G0Id14,G0Id15
	];

//= Grid 1 Data ================================================================

let Gr1Mul = 3;
let Gr1Siz = Math.floor(dtSize/Gr1Mul);

// Image Data (Source Data - Resized)
let G1SPtr = [];
	G1SPtr[G0Indx.length-1] = 0;

// Image Data
let G1DPtr = [];
	G1DPtr[G0Indx.length-1] = 0;

// Materials
let G1MPtr = [];
	G1MPtr[G1DPtr.length-1] = 0;

// Index to Display of G1 Textures by Type
// Used by G0 to position squares
// And by G1 to create textures
let G1Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,		//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4, 9,13, 8,12, 7,		// 9 = over
		 4, 7,15,12, 3,11, 9,13, 4,		// 3 = Airport
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];

//= Grid 2 Data ================================================================
	
let Gr2Mul = 3;
let Gr2Siz = Math.floor(dtSize/Gr2Mul);

// Image Data (Source Data - Resized)
let G2SPtr = [0,0,0,0,0,0,0,0,0];

// Image Data
let G2DPtr = [0,0,0,0,0,0,0,0,0];

// Materials
let G2MPtr = [0,0,0,0,0,0,0,0,0];

//= GRID MODULE ================================================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let GrdSiz = 804.67;				// Size of Smallest Grid Square (1/4 section = 1/2 mile)
let grids = 0;
let grd_ = {
		SPS: new THREE.Vector3 (),	// MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,					// Squares in each of first 2 grids
		Siz: GrdSiz,				// Size of smallest square
		Stp: 3,						// Squares in each of first 2 grids
		Grx: [],					// Index of Grids (0-2)
		Idx: [G0Indx,G1Indx],		// Index to Patterns
		Mat: [G0MPtr,G1MPtr,G2MPtr], // Materials
	}

/* = Roads ===================================================================*/
// North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}
// East West
let Rod2 = {
		Typ:	2,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}

// Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);

/* = Trees ===================================================================*/
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e

/* = Objects =================================================================*/
// Distances in Meters
let ObjNum = 2;						// number of objects
let ObjTyp = [0];					// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];					// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];					// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];					// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];					// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];					// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];					// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];					// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
// Hangars
	ObjTyp[ObjIdx] = 0;				// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 1000;			// [m]
	ObjMPY[ObjIdx] = 0.3048;		// [m] 1 ft
	ObjMPZ[ObjIdx] = 1524;			// [m] 5000 ft
	ObjIdx = ObjIdx + 1;
// Giaros Island
	ObjTyp[ObjIdx] = 1;				// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/textures/giaros.png";
	ObjMPX[ObjIdx] = -1609.344;		// [m] 1 mile
	ObjMPY[ObjIdx] = 2*Ft2Mtr;		// [m] 2 ft
	ObjMPZ[ObjIdx] = 8046.72;		// [m] 5 miles

/* = VARIABLES ===============================================================*/
// Objects
let mesh, geometry, material, fname;
let prprot = 0;						// Prop/Engine rotation
// Camera
let CamLat = 20;					// Starting in air
let CamLon = 0;
let CamLax = 80;					// Max/Min Lat in Pan View
let PanFlg = 0;
// Visibility
let VCFlag = 0;						// Default = external view
// View Keys
let U45flg = 0;						// Up 45 degrees
let D45flg = 0;						// Down 45 degrees
let	L45flg = 0;						// Left 45 degrees
let R45flg = 0;						// Right 45 degrees
let L90flg = 0;						// Left 90 degrees
let R90flg = 0;						// Right 90 degrees

//= DEFAULT KEY BINDINGS =======================================================
let K_BnkL = 37;	// Bank Left (left arrow)
let K_BnkR = 39;	// Bank Right (right arrow)
let K_PitU = 40;	// Pitch up (down arrow)
let K_PitD = 38;	// Pitch down (up arrow)
let K_Brak = 66;	// Brakes (b)
let K_Guns = 32;	// Guns (spacebar)
let K_Vizz = 86;	// Toggle visibility (v)
let K_VU45 = 36;	// View Up (alone or modifier)
let K_VD45 = 35;	// View Down (alone or modifier)
let K_VL45 = 33;	// Left 45 degrees
let K_VR45 = 45;	// Right 45 degrees
let K_VL90 = 34;	// Left 90 degrees
let K_VR90 = 46;	// Right 90 degrees
let K_Look = 16;	// Pan (shift)
let K_Soun = 83;	// Toggle sound (s)
let K_Info = 73;	// Info (i)
let K_Paws = 80;	// Pause (p)

//= STANDARD SETUP =============================================================
//- Display
let scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
let renderer = new WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);					// ### nodes
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
//let maxAnisotropy = renderer.capabilities.getMaxAnisotropy();	// ### Err
let	maxAnisotropy = 16;	// ### WebgGPU
//- Light
let ambLight = new THREE.AmbientLight(SunCol, 0.2);
	scene.add(ambLight);
let sunLight = new THREE.DirectionalLight(SunCol, SunInt);
	sunLight.castShadow = true;
	sunLight.shadow.mapSize.width = 4096;
	sunLight.shadow.mapSize.height = 4096;
	sunLight.shadow.camera.near = 0.001;
	sunLight.shadow.camera.far = 10000;
	sunLight.shadow.camera.left = -100;
	sunLight.shadow.camera.right = 100;
	sunLight.shadow.camera.top = 100;
	sunLight.shadow.camera.bottom = -100;
	sunLight.shadow.bias = - 0.0005;					// ### WebGPU
	sunLight.target.position.set(0,0,0);
	sunLight.position.set(0,1000,0);	// Default position
	scene.add(sunLight);
//- Sounds
let	listener = new THREE.AudioListener();
let sound1 = new THREE.PositionalAudio(listener);
let sound3 = new THREE.PositionalAudio(listener);
let sound4 = new THREE.PositionalAudio(listener);
let EngObj = new THREE.Object3D();			// Aircraft Engine
	EngObj.add(sound1);					// Engine
	EngObj.add(sound3);					// Guns
	EngObj.position.z = -5;
//- Camera
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.4, SkyLim);
	camera.rotation.order = "YXZ";
	camera.add(listener);
const CamObj = new THREE.Object3D();
	CamObj.add(camera);
	CamObj.add(EngObj);					// Engine Sounds
	scene.add(CamObj);
	CamObj.rotation.order = "YXZ";
//- Clock
var state = {
    clock: new THREE.Clock(),
    frame: 0,
    maxFrame: 90,
    fps: 60, // capping at 60 fps
    per: 0
};
// Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener('mousewheel', onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
// Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
const imagLoader = new THREE.ImageLoader(loadingManager);
const txtrLoader = new THREE.TextureLoader(loadingManager);
const gltfLoader = new GLTFLoader(loadingManager);
const audioLoader = new THREE.AudioLoader(loadingManager);
// Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;							//keep = 0
let isUserInteracting = false;			// Initial value

//= PPOINTER LOCK CONTROL ======================================================

class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement, plc_) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error('THREE.PointerLockControls: Unable to use Pointer Lock API');
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener('mousemove', onMouseMove);
			scope.domElement.ownerDocument.addEventListener('pointerlockchange', onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener('pointerlockerror', onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);
			scope.domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//- Setup ----------------------------------------------------------------------
let controls = new PointerLockControls(camera, renderer.domElement,air_);
let blocker = document.getElementById('blocker');
let instructions = document.getElementById('instructions');
	instructions.addEventListener('click', function () {controls.lock();});
	controls.addEventListener('lock', function () {
		instructions.style.display = 'none';
		blocker.style.display = 'none';
	});
	controls.addEventListener( 'unlock', function () {
		blocker.style.display = 'block';
		instructions.style.display = '';
	});

//= 3D OBJECTS AND LINKS =======================================================
// Aircraft Group
	scene.add(air_.AirObj);
let AirGrp = new THREE.Group();				// To hold ACMine and VCMine
	air_.AirPBY.add(AirGrp);
let ACMine = 0;							// My Aircraft (loaded)

//= HTML OVERLAY TEXT ==========================================================
let AC_PowrElement = document.getElementById("AC_Powr");
let AC_PowrNode = document.createTextNode("");
AC_PowrElement.appendChild(AC_PowrNode);
let Spd_UPHElement = document.getElementById("Spd_UPH");
let Spd_UPHNode = document.createTextNode("");
Spd_UPHElement.appendChild(Spd_UPHNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
AC_HeadElement.appendChild(AC_HeadNode);
let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
AC_HiteElement.appendChild(AC_HiteNode);
let Cf_LiftElement = document.getElementById("Cf_Lift");
let Cf_LiftNode = document.createTextNode("");
Cf_LiftElement.appendChild(Cf_LiftNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
On_PawsElement.appendChild(On_PawsNode);
let On_Info01Element = document.getElementById("On_Info01");
let On_Info01Node = document.createTextNode("");
On_Info01Element.appendChild(On_Info01Node);
let On_Info02Element = document.getElementById("On_Info02");
let On_Info02Node = document.createTextNode("");
On_Info02Element.appendChild(On_Info02Node);
let On_Info03Element = document.getElementById("On_Info03");
let On_Info03Node = document.createTextNode("");
On_Info03Element.appendChild(On_Info03Node);
let On_Info04Element = document.getElementById("On_Info04");
let On_Info04Node = document.createTextNode("");
On_Info04Element.appendChild(On_Info04Node);
let On_Info05Element = document.getElementById("On_Info05");
let On_Info05Node = document.createTextNode("");
On_Info05Element.appendChild(On_Info05Node);
let On_Info06Element = document.getElementById("On_Info06");
let On_Info06Node = document.createTextNode("");
On_Info06Element.appendChild(On_Info06Node);
let On_Info07Element = document.getElementById("On_Info07");
let On_Info07Node = document.createTextNode("");
On_Info07Element.appendChild(On_Info07Node);
let On_Info08Element = document.getElementById("On_Info08");
let On_Info08Node = document.createTextNode("");
On_Info08Element.appendChild(On_Info08Node);
let On_Info09Element = document.getElementById("On_Info09");
let On_Info09Node = document.createTextNode("");
On_Info09Element.appendChild(On_Info09Node);
//
let AC_Powr, Spd_UPH, AC_Head, AC_Hite, Cf_Lift;
let On_Paws, On_Info01, On_Info02, On_Info03, On_Info04, On_Info05, On_Info06, On_Info07, On_Info08;

/* = Main Programs ===========================================================*/

	loadAll();

/* 0 Load All ================================================================*/

function loadAll() {
	// Initialize Loading Screen
	WaitScreen();						// init loading screen
	loadObject();
	loadSkyBox();
	loadACMine();
}

/* Wait Screen ===============================================================*/

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let geometry = new THREE.PlaneGeometry(1,1);
	let texture = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let material = new THREE.MeshBasicMaterial({map: texture});
	loadingScreen.box = new THREE.Mesh(geometry, material);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

/* = Initialize ==============================================================*/

function initAll() {
	initSkyBox();						// load skybox
	flight = Flight(air_);				// position airplane using air_.GrdZed
	air_.PYBmul.x = air_.PYBmul.x*MosMul.x;	// Pitch Adjustment
	air_.PYBmul.z = air_.PYBmul.x*MosMul.z;	// Bank Adjustment
	initGrdTxt();
	grd_.SPS.y = air_.MapSPS.y;
	grids = new GrdMap(grd_,scene);		// Init Grid Map
	grids.update(grd_);					// Mode Grid Map
	initRoads();
//	makeTrees();
	initObject();						// Stationary Objects
	moveCamera();						// position camera
	noPause();							// Pause Off
	noInfo();							// Info Off
	// Show stats
	if (StsFlg > 0) {					// show stats
		stats = new Stats();
		stats.setMode(0);				// FPS only
		stats.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(stats.dom);
	}
	state.clock.start();
	LodFlg = 1;
}

/* Render ====================================================================*/

function rendAll() {
//	nodeFrame.update();					// Nodes
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		requestAnimationFrame(rendAll);
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;												// Stop the function here.
	}
//	requestAnimationFrame(rendAll);
	if (PawsOn == 0 && LodFlg > 0 && controls.isLocked === true) {
		DLTime = 1/60;					// ### Until we fix overspeed
		moveAirObj();					// Move aircaft
		grd_.SPS.copy(air_.MapSPS);		// Update Position
		grids.update(grd_);				// Mode Grid Map
		moveRoads();
//		moveTrees();		
		moveObject();					// Move objects
		moveCamera();
		moveSounds();
		prntHUDval();					// change HUD value
		if (StsFlg > 0) stats.update();	// update stats
	}
	renderer.render(scene, camera);
}

//= SKYBOX =====================================================================

function loadSkyBox() {
	let fpath = SBPath;
	let envMap = new THREE.CubeTextureLoader(loadingManager)
		.setPath(fpath)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace;	// ### r152
	scene.background = envMap;
	// LensFlare
	LF0Txt = txtrLoader.load(LF0Src);
	LF1Txt = txtrLoader.load(LF1Src);
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// SunLight Position
let SunPos = new THREE.Vector3(SunLLD.x,Mod360(180-SunLLD.y),SunLLD.z);
	SunPos = rotLLD(SunPos);	// Set Position above Light
	sunLight.position.copy(SunPos).normalize();
	// Lensflare
let	spotLight = new THREE.PointLight(0xffffff);
	scene.add(spotLight);
	spotLight.position.set(SunPos.x,SunPos.y,SunPos.z);
//	let LF = new Lensflare();
//	LF.addElement(new LensflareElement(LF0Txt, 256, 0));
//	LF.addElement(new LensflareElement(LF1Txt, 32, 0.2));
//	LF.addElement(new LensflareElement(LF1Txt, 256, 0.9));
//	spotLight.add(LF);
}

//= GRID MAP ===================================================================

//= Make Grid Map Textures =====================================================

function initGrdTxt() {
	initGr0Txt();
	initGr1Txt();
	initGr6Txt();
}

function initGr0Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G0DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G0DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);	// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);	// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(GrdMul,GrdMul);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		G0MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});		
		G0MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G0DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr1Siz,Gr1Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G1SPtr[n] = context.getImageData(0,0,Gr1Siz,Gr1Siz);				//
	}
}

function initGr1Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr1Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G0Indx.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G0Indx[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
//				let ImgDat = G0DPtr[stIndx[idx]];
				let ImgDat = G1SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G1DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G1DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		G1MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});
		G1MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G1DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr2Siz,Gr2Siz);
		G2SPtr[n] = context.getImageData(0,0,Gr2Siz,Gr2Siz);
	}
}

function initGr6Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr2Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G2SPtr[G1Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G2DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G2DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;		// ###
			DatTxt.needsUpdate = true;
//			G2MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});
			G2MPtr[n] = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

//= Make Textures ==============================================================

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

/* Roads ==================================================================*/

function initRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

function initRoad2(Rod) {

	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(20*Ft2Mtr, Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		let material = new THREE.MeshLambertMaterial({map: DatTxt});
		let material = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz, 20*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		let material = new THREE.MeshLambertMaterial({map: DatTxt});
		let material = new MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*.999+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

// Move Roads
function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - grd_.SPS.z;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*.999+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

//= TREES ======================================================================

//- Make Trees ------------------------------------------------------------------

function makeTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)		// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;	// ###
	txttre.needsUpdate = true;
	let mtltre = new MeshLambertNodeMaterial({colorNode: texture(txttre)});
	let mtltrn = new MeshLambertNodeMaterial({colorNode: color(0x161005)});
	let mtlshd = new MeshBasicNodeMaterial({colorNode: color(0x000000),transparent:true,opacity:0.5,depthWrite: false});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
		TreePZ[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
	}
	moveTrees();
}

//- Move Trees -----------------------------------------------------------------

function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*GrdSiz;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-air_.MapPos.x-GrdSiz/2;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		let z = air_.MapPos.z-TreePZ[n]-GrdSiz/2;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		let y = -grd_.SPS.y*.99+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

/* Load and Move Fixed Objects ===============================================*/
/* These objects include the airfield, islands and hangar */

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = txtrLoader.load(ObjTxt[i]);
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gltfLoader.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				let s = 32000 * Ft2Mtr;
				ObjPtr[i].scale.set(s,s,s);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*.99;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*.99;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

//= AIRPLANE =============================================================*/

// Load Airplane
function loadACMine() {
	fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {				// The OnLoad function
		gltf.scene.traverse(function (child) {	
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
//				child.geometry.computeVertexNormals();		// Better result?  Or remove smoothing?
			}
			if (child.name == "propeller") {
				child.castShadow = false;
				child.receiveShadow = false;
			}		
		});
		ACMine = gltf.scene;
		ACMine.rotation.order = "YXZ";
		// Convert from feet to meters
		ACMine.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		/* Animations --------------------------------------------------------------- */
		// Propeller
		let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
		mxProp = new THREE.AnimationMixer(ACMine);
		let actun = mxProp.clipAction(clip);
		actun.play();
		if (mxProp) mxProp.setTime(spnprp/anmfps);
		// Rudder
		mxRudr = new THREE.AnimationMixer(ACMine);
		clip = THREE.AnimationClip.findByName(gltf.animations, "rudderAction");
		actun = mxRudr.clipAction(clip);
		actun.play();
		if (mxRudr) mxRudr.setTime(rudder/anmfps);
		// Elevator
		clip = THREE.AnimationClip.findByName(gltf.animations, "elevatorAction");
		mxElev = new THREE.AnimationMixer(ACMine);
		actun = mxElev.clipAction(clip);
		actun.play();
		if (mxElev) mxElev.setTime(elvatr/anmfps);
		// AileronTL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTLAction");
		mxAlTL = new THREE.AnimationMixer(ACMine);
		actun = mxAlTL .clipAction(clip);
		actun.play();
		if (mxAlTL) mxAlTL.setTime(aillft/anmfps);
		// AileronTR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTRAction");
		mxAlTR = new THREE.AnimationMixer(ACMine);
		actun = mxAlTR.clipAction(clip);
		actun.play();
		if (mxAlTR) mxAlTR.setTime(ailrgt/anmfps);
		// AileronBL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBLAction");
		mxAlBL = new THREE.AnimationMixer(ACMine);
		actun = mxAlBL .clipAction(clip);
		actun.play();
		if (mxAlBL) mxAlBL.setTime(aillft/anmfps);
		// AileronBR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBRAction");
		mxAlBR = new THREE.AnimationMixer(ACMine);
		actun = mxAlBR.clipAction(clip);
		actun.play();
		if (mxAlBR) mxAlBR.setTime(ailrgt/anmfps);
		//
		AirGrp.add(ACMine);
		// Initialize
		ACMine.visible = true;
		loadSounds();
	});
}

/* Rotate Subroutines ========================================================*/

//= Move Airplane Model / Virtual Cockpit ======================================
function moveAirObj() {
	// Add Delay to Power
	let gal = PwrDif * PwrMsD.x;		// Current input delayed
	let lag = PwrMsD.z * PwrMsD.y;		// Released from Cumulator
	PwrMsD.z = PwrMsD.z + gal - lag;	// Change in Cumulator
	PwrDif = PwrDif - gal + lag;
	// Input Engine Power
	air_.PwrPct = air_.PwrPct + PwrDif;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	PwrDif = 0;							// Reset
	// Coefficient of Lift
	let CfLDif = (InpMos.y + InpKey.x) * air_.PYBmul.x ;	// Input Coefficient of Lift
	// Add Delay to Lift
	gal = CfLDif * CfLMsD.x;			// Current input delayed
	lag = CfLMsD.z * CfLMsD.y;			// Released from Cumulator
	CfLMsD.z = CfLMsD.z + gal - lag;	// Change in Cumulator
	CfLDif = CfLDif - gal + lag;
	air_.CfLift = air_.CfLift + CfLDif;	// New Coefficient of Lift	
	if (air_.CfLift > air_.CfLMax) air_.CfLift = air_.CfLMax;
	if (air_.CfLift < -air_.CfLMax) air_.CfLift = -air_.CfLMax;
//	anm_.stkpit = InpMos.y;				// Joystick pitch animation
	InpMos.y = 0;						// Reset
	// Coefficient of Lift - Flaps
//	air_.CfFlap = air_.FlpCfL * (180 - anm_.flppos) / 180; 	// [FLAP]
	// Bank
	// Add Delay to Change in Bank Rate due to Mouse
	let BnkDif = InpMos.x * air_.PYBmul.z;
	gal = BnkDif * BnkMsD.x;			// Current input delayed
	lag = BnkMsD.z * BnkMsD.y;			// Released from Cumulator
	BnkMsD.z = BnkMsD.z + gal - lag;	// Change in Cumulator
	BnkDif = BnkDif - gal + lag;
	air_.RotDif.z = air_.RotDif.z + BnkDif;	
	air_.RotDif.z = MaxVal(air_.RotDif.z,air_.BnkMax);	// Max values
	if (air_.RotDif.z == air_.BnkMax && BnkDif < 0) air_.RotDif.z = BnkDif;
	if (air_.RotDif.z == -air_.BnkMax && BnkDif > 0) air_.RotDif.z = BnkDif;
	air_.RotDif.z = air_.RotDif.z + InpKey.z; // Inputs are +/-
	air_.AGBank = air_.RotDif.z;
//	anm_.stkbnk = InpMos.x;				// Joystick bank animation
	InpMos.x = 0;						// Reset
	// Input Yaw
	if (air_.SpdKPH < 1) air_.RotDif.y = 0;	// No Yaw if Speed < 1;
	// Input Brakes
	air_.BrkVal = InpBrk;				// Brakes
	// Compute Rotation and Vectors --------------------------------------------
	Flight.update(air_);
	// Animate -----------------------------------------------------------------	
	// Propeller
	let prpspd =  4 * (air_.PwrPct - 0.6);					// Range = -2.4 to + 1.6
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359;							// A complete circle
	// Rudder
	rudder = 180 + air_.RotDif.y * 100;
	// Elevator
	elvatr = 180 - 10*air_.ACPAdj-25;							// estimated adjustment
	if (elvatr < 150) elvatr = 150;							// Range = 00 to 60
	else if (elvatr > 209) elvatr = 209;
	// Ailerons
	let ailbnk = air_.RotDif.z;
	if (GrFlag > 0) ailbnk = AGBank;
	// Left
	aillft = 180 + ailbnk * 30;
	if (aillft < 151) aillft = 151;							// Range = 00 to 60
	else if (aillft > 209) aillft = 209;
	// Right
	ailrgt = 180 - ailbnk * 30;
	if (ailrgt < 151) ailrgt = 151;							// Range = 00 to 60
	else if (ailrgt > 209) ailrgt = 209;
	/* Animations (Display) ------------------------------------------------- */
	// Propeller
	if (mxProp) mxProp.setTime(spnprp/anmfps);
	// Rudder
	if (mxRudr) mxRudr.setTime(rudder/anmfps);
	// Elevator
	if (mxElev) mxElev.setTime(elvatr/anmfps);
	// Ailerons
	// Left
	if (mxAlTL) mxAlTL.setTime(aillft/anmfps);
	if (mxAlBL) mxAlBL.setTime(aillft/anmfps);
	// Rite
	if (mxAlTR) mxAlTR.setTime(ailrgt/anmfps);
	if (mxAlBR) mxAlBR.setTime(ailrgt/anmfps);
	/* View Keys ----------------------------------------------------------- */
	if (PanFlg == 0) {										// Only if Not Panning
		// Default View
		CamLat = 0;
		CamLon = 0;
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg == 0)	{
			if (VCFlag == 0) CamLat = 20;
		}
		// Down 45
		else if (D45flg > 0) {
			CamLat = 0;
			// Look Back
			if (L90flg > 0 && L90flg > 0 && R90flg > 0) CamLon = 180;
			// Look Back Left 90 + 45
			else if (L90flg > 0) CamLon = 135;
			// Look Back Right 270 - 45
			else if (R90flg > 0) CamLon = 225;
			// Look Down
			else {
				CamLon = 0;
				CamLat = 45;
			}
		}
		// Up 45
		else if (U45flg > 0) {
			CamLat = 315;
			if (VCFlag == 0 && GrFlag > 0) CamLat = 0;
			// Look Up Left 45
			if (L45flg > 0) CamLon = 45;
			// Look Up Right 45
			else if (R45flg > 0) CamLon = 315;
			// Look Up Left 90
			else if (L90flg > 0) CamLon = 90;
			// Look Up Right 90
			else if (R90flg > 0) CamLon = 270;
			// Look Up
			else CamLon = 0;
		}
		// Level
		else {
			CamLat = 0;
			// Look Left 45
			if (L45flg > 0) CamLon = 45;
			// Look Right 45
			else if (R45flg > 0) CamLon = 315;
			// Look Left 90
			else if (L90flg > 0) CamLon = 90;
			// Look Right 90
			else if (R90flg > 0) CamLon = 270;
		}
	}
}

//= SOUNDS =====================================================================

// Load Sounds
function loadSounds() {	
	// My Engine ---------------------------------------------------------------
	fname = ACPath + "sounds/" + acsnd1;
	audioLoader.load(fname, function(buffer) {
		sound1.setBuffer(buffer);
		sound1.setRefDistance(RefDst);
		sound1.setLoop(true);
		sound1.setVolume(0);
	});
	// My Guns -----------------------------------------------------------------
	fname = ACPath + "sounds/" + acsnd3;
	audioLoader.load(fname, function(buffer) {
		sound3.setBuffer(buffer);
		sound3.setRefDistance(RefDst);
		sound3.setLoop(true);
		sound3.setVolume(0);
	});
}

// Change Sounds
function moveSounds() {
	// My Engine
	sound1.setVolume(acvol1 + air_.PwrPct * 0.05);				// Range = .1 to .2
	sound1.setPlaybackRate(1 + air_.PwrPct * 0.5);				// Range = 1 to 1.5
	// My Guns
	sound3.setVolume(acvol3);
	// XP Engine
	sound4.setVolume(xpvol1);
}

/* Rotate and Move Camera ====================================================*/
/* There are two types of external camera movement:
/* 1. Default Mode - the camera looks through the aircraft center to the direction of flight
/* 2. Panning Mode - the camera orbits around the aircraft
*/

// Rotate and Move Camera
function moveCamera() {
	//	Pivot Rotation (rotation order = YXZ)
	let x = Mod360(air_.AirRot.x) * DegRad;					// Pitch (air_.ACPAdj is not part of this)
	let y = Mod360(-air_.AirRot.y) * DegRad;				// Heading
	let z = Mod360(360-air_.AirRot.z) * DegRad;				// Bank
	CamObj.rotation.set(x, y, z);
	// Camera Position and Rotation (rotation order = YXZ)
	// Internal View
	if (VCFlag == 1) {
		// Rotation Limits
		if (isUserInteracting === true) {					// Mouse Pan Limits
			if (CamLat > CamPmx && CamLat < 180) CamLat = CamPmx;
			if (CamLat > 180 && CamLat < CamPmn) CamLat = CamPmn;
			if (CamLon > CamHmx && CamLon < 180) CamLon = CamHmx;
			if (CamLon > 180 && CamLon < CamHmn) CamLon = CamHmn;
		}
		// Camera Position
		x = Mod360(CamVCA - air_.ACPAdj) * DegRad;				// x-angle: air_.ACPAdj is purely vertical
		y = CamVCD * Math.sin(x);							// y-position
		z = CamVCD * Math.cos(x);							// z-position
		camera.position.set(0, y, z);
		// Camera Rotation
		x = Mod360(CamLat - air_.ACPAdj) * DegRad;				// x-angle
		y = Mod360(CamLon) * DegRad;						// y-angle
		camera.rotation.set(-x, y, 0);
	}
	// External View
	if (VCFlag == 0) {
		// For both Default and Panning Mode
		x = Mod360(CamLat) * DegRad;						// x-angle
		y = Mod360(CamLon) * DegRad;						// y-angle
		RotVec(CamDst, x, y);								// Returns xyz position
		if (VectRY < (GrdZed + MinAlt - air_.MapPos.y)) VectRY = GrdZed + MinAlt - air_.MapPos.y;	// Not below aircraft level
		camera.position.set(VectRX, VectRY, VectRZ);
		camera.rotation.set(-x, y, 0);
	}
}

/* - Rotate Vector -----------------------------------------------------------*/
// For given vector and XY radians
// Computes rotated XYZ point values
function RotVec(Dst,XRd,YRd) {
	// Pitch
	VectRY = Dst * Math.sin(XRd);
	VectRZ = Dst * Math.cos(XRd);
	// Heading
	VectRX = VectRZ * Math.sin(YRd);
	VectRZ = VectRZ * Math.cos(YRd);
}

/* Outputs ===================================================================*/

// Change HUD Values
function prntHUDval() {
	AC_Powr = air_.PwrPct;							// Throttle
	AC_PowrNode.nodeValue = AC_Powr.toFixed(2);
	Spd_UPH = air_.SpdKPH*Km2Mil;					// Speed
	Spd_UPHNode.nodeValue = Spd_UPH.toFixed(0);
	AC_Head = Mod360(air_.AirRot.y);				// Heading
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_Hite = air_.MapPos.y;						// Altitude
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);	
	Cf_Lift = air_.CfLift;								// Cf Lift
	Cf_LiftNode.nodeValue = Cf_Lift.toFixed(4);
}

// Paused On
function onPause(){
	On_PawsNode.nodeValue = "Paused";
}

// Paused Off
function noPause(){
	On_PawsNode.nodeValue = "Press P to Pause";
}

// Info On
function onInfo1(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "CONTROLS";
	On_Info03Node.nodeValue = "Use Mouse or Arrow Keys to change Pitch and Bank";
	On_Info04Node.nodeValue = "Use Mouse Buttons or Z/X Keys to change Yaw";
	On_Info05Node.nodeValue = "Use Mouse Wheel or -/= Keys to change Throttle";
	On_Info06Node.nodeValue = "Press G to retract/extend landing gear";
	On_Info07Node.nodeValue = "Press F to extend/retract flaps"
	On_Info08Node.nodeValue = "Press Spacebar to fire guns";
	On_Info09Node.nodeValue = "Press S to toggle sound";
}

// Info On
function onInfo2(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "VIEW KEYS";
	On_Info03Node.nodeValue = "Press V to toggle internal/external views";
	On_Info04Node.nodeValue = "Hold Shift and use Mouse to pan around aircraft";
	On_Info05Node.nodeValue = "Press END to look down into cockpit";
	On_Info06Node.nodeValue = "Press DELETE or PAGE DOWN to look left/right";
	On_Info07Node.nodeValue = "Press HOME and the above to look up";
	On_Info08Node.nodeValue = "Press END and DELETE or PAGE DOWN to look back";
	On_Info09Node.nodeValue = "Press all 3 keys to look back";
}

// Info Off
function noInfo(){
	On_Info01Node.nodeValue = "Press I for Info";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

/* Inputs ====================================================================*/
/* The PointerLockControls creates inputs for mouse movement.
/* This creates inputs for mouse buttons and keys.
*/

/* Mouse ---------------------------------------------------------------------*/

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		air_.RotDif.y = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		air_.RotDif.y = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		air_.RotDif.y = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		air_.RotDif.y = 0;
	}
}

//- Mousewheel -----------------------------------------------------------------
//  Throttle (Internal - No Pan) /View Distance (External - Pan)
function onDocumentMouseWheel(event) {
	event.preventDefault();
	PwrDif = - event.deltaY * PwrMul;	// Increment = 1%
}

/* Keyboard ------------------------------------------------------------------*/

// Keyboard - Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	if (event.keyCode == K_BnkL) InpKey.z = -KeyVal.z;	// Bank Left
	if (event.keyCode == K_BnkR) InpKey.z = KeyVal.z;	// Bank Right
	if (event.keyCode == K_PitU) InpKey.x = KeyVal.x;	// Pitch Up
	if (event.keyCode == K_PitD) InpKey.x = -KeyVal.x;	// Pitch Down
	if (event.keyCode == K_Brak) InpBrk = 0.01;			// Brakes
	if (event.keyCode == K_Guns) {						// Guns
		sound3.play();
		BulFlg = 1;
	}
	// View - 45 deg up
	if (event.keyCode == K_VU45) U45flg = 1;
	// View - 45 deg down
	if (event.keyCode == K_VD45) D45flg = 1;
	// View - 45 deg left
	if (event.keyCode == K_VL45) L45flg = 1;
	// View - 45 deg right
	if (event.keyCode == K_VR45) R45flg = 1;
	// View - 90 deg left
	if (event.keyCode == K_VL90) L90flg = 1;
	// View - 90 deg right
	if (event.keyCode == K_VR90) R90flg = 1;
	// Pan View
	if (event.keyCode == K_Look) PanFlg = 1;
	// Toggle Sound
	if (event.keyCode == K_Soun) {
		if (SndFlg < 1) {
			SndFlg = 1;
			sound1.play();
			sound4.play();
		}
		else {
			SndFlg = 0;
			sound1.stop();
			sound4.stop();
		}
	}
	// Toggle Pause
	if (event.keyCode == K_Paws) {
		if (PawsOn < 1) {
			PawsOn = 1;
			onPause();
		}
		else {
			PawsOn = 0;
			noPause();
		}
	}
	// Toggle Info
	if (event.keyCode == K_Info) {
		if (InfoOn == 0) {
			InfoOn = 1;
			onInfo1();
		}
		else if (InfoOn == 1) {
			InfoOn = 2;
			onInfo2();
		}
		else {
			InfoOn = 0;
			noInfo();
		}
	}
}

// Keyboard - Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	if (event.keyCode == K_BnkL) InpKey.z = 0;			// Bank Left
	if (event.keyCode == K_BnkR) InpKey.z = 0;			// Bank Right	
	if (event.keyCode == K_PitU) InpKey.x = 0;			// Pitch Up
	if (event.keyCode == K_PitD) InpKey.x = 0;			// Pitch Down
	if (event.keyCode == K_Brak) InpBrk = 0;			// Brakes
	if (event.keyCode == K_Guns) {						// Guns
		sound3.stop();
		BulFlg = 0;
	}
	// View - 45 deg up
	if (event.keyCode == K_VU45) U45flg = 0;
	// View - 45 deg down
	if (event.keyCode == K_VD45) D45flg = 0;
	// View - 45 deg left
	if (event.keyCode == K_VL45) L45flg = 0;
	// View - 45 deg right
	if (event.keyCode == K_VR45) R45flg = 0;
	// View - 90 deg left
	if (event.keyCode == K_VL90) L90flg = 0;
	// View - 90 deg right
	if (event.keyCode == K_VR90) R90flg = 0;
	// Pan View
	if (event.keyCode == K_Look) PanFlg = 0;
	CamLat = CamPit;
	CamLon = CamHed;
}

// Window Resize
function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>