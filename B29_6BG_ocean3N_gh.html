<!doctype html>
<html>

<!--
Copyright 2017-24, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 24 Apr 2024

FILE STRUCTURE:
3js [dir]
-- common [dir]
---- (contains subdirectories for my modules, models, scenery, skyboxes, etc.)
Aircraft [dir]
-- b29_6BG_ocean3N.html - this file

UNITS:
This version uses SI units, except for beginning values which are converted to SI units.
-->

<head>
<title>Aircraft Viewer - Nodes - B29</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/butn_b29n.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Speed....: <span id="Air_Spd"></span> mph</div>
		<div>Altitude.: <span id="Air_Alt"></span> ft</div>
		<div>Heading..: <span id="Air_Hdg"></span> deg</div>
	</div>
</div>

<button id="PAW" class="pauseButton">Paws</button>
<button id="SND" class="soundButton">Sond</button>
<button id="CAM" class="cameraButton">View</button>

<button id="SLO" class="spddButton">-</button>
<button id="PTD" class="pitdButton">&uarr;</button>
<button id="FST" class="spduButton">+</button>
<button id="BKL" class="bnklButton">&larr;</button>
<button id="CTR" class="cntrButton">X</button>
<button id="BKR" class="bnkrButton">&rarr;</button>
<button id="YWL" class="yawlButton">[</button>
<button id="PTU" class="pituButton">&darr;</button>
<button id="YWR" class="yawrButton">]</button>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.163.0/build/three.module.js", 
			"three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/",
			"three/nodes": "https://unpkg.com/three@0.163.0/examples/jsm/nodes/Nodes.js"
		}
	}
</script>

<script type="module">

// Basic Modules
import * as THREE from "three";
import Stats from "three/addons/libs/stats.module.js";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {Lensflare,LensflareElement} from "three/addons/objects/Lensflare.js";
// Special Modules
import {Mod360,PoM360,MaxVal,rotLLD,makMsh} from "https://PhilCrowther.github.io/Aviation/jsm/FlightW3.js";
import {Ocean} from "https://PhilCrowther.github.io/Aviation/jsm/Ocean3.js";
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdWtr3N.js";
import {
		color,
		texture,
		normalMap,
		float,
		vec2,
		attribute,
		positionLocal,
		MeshStandardNodeMaterial,
} from 'three/nodes';
import {nodeFrame} from 'three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js';	// ### Nodes

//= INPUTS ====================================================================
let USorSI = "US";					// Starting Units of Measurement (US or SI)
let PwrPct = 0.8;					// Initial Power
let BegSpd = 180;					// Speed (mph)
let BegPos = new THREE.Vector3(0,5000,0); // Position (ft)
//- AIRPLANE: Flight -----------------------------------------------------------
let KeyVal = new THREE.Vector3(0.5,0.25,0.5);	// Key Values
let InpKey = new THREE.Vector3();
let PwrMul = 0.0001;				// Power % Input - Mouse Multiplier
let PwrDif = 0;						// Power % Input - Value

//= CONSTANTS ==================================================================
//-	Conversions
var DegRad = Math.PI/180;			// Convert Degrees to Radians
var RadDeg = 180/Math.PI;			// Convert Radians to Degrees
let Mtr2Ft = 3.28084;				// Meters to Feet
let Ft2Mtr = 0.3048;				// Convert Feet to Meters (exact)
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//-	Time
let	DLTime = 1/60;					// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;			//
//-	Default Constants (US)
let	GrvMPS = 9.80665; // (mps)
//-	Starting Constants per frame
let GrvDLT = GrvMPS * DLTim2;
//-	Starting Air Density
let	AirDSL = 1.225;					// Density - Sea Level (kg/m3)
//- Convert Starting Values
if (USorSI = "US") {
	BegSpd = BegSpd*Mil2Km;
	BegPos.multiplyScalar(Ft2Mtr);
}

//= INPUT VALUES ==============================================================
//-	Background
let SkyLim = 100000;				// Used for Camera and SkyCube
let SkyCol = 0xbab4a6;				// Sky
let FogCol = 0xbab4a6;				// Sky (for Fog only)
let SunCol = 0xffffff;				// Sun
let WtrCol = 0x102080;				// Water
	WtrCol = 0x1060ff;				// Water // ### Nodes
//-	Light
let	SunLLD = new THREE.Vector3(23,312,1000);	// Lat,Lon,Dst for Sun Mesh and Lensflare
let SunInt = 2.5;						// Default intensity of light/sun
//-	Shadows
let LgtDst = 5000;					// [feet] for shadow
let LgtBox = 25;					// Size of shadow box 
//-	Sounds
let RefDst = 25;					// Reference distance for Positional Sound	
//-	Flags
let PawsOn = 0;						// Pause
let LodFlg = 0;
let SndFlg = 0;
let LFFlag = 1;						// Lensflare flag			
//-	Stats
let stats = 1;						// Stats ((0 = off, 1 = on)
//-	Altitude Adjustment
let AltAdj = 0.96;					// Raises objects above map as altitude increases
//-	Animations
let anmfps = 24;					// Blender FPS
let aoarng = 20;					// AoA range (model)

//= MY AIRCRAFT ==============================================================*/
//	Aircraft Data
let ACMine = 0;
let	flight = 0;
let air_ = {
		DLTime: DLTime,					// Seconds per frame (can vary)
		GrvMPS: GrvMPS,					// Gravity (mps)
		AirDSL: AirDSL,					// Air Density (varies with altitude)
		// Designators		
		AirIDN: 0,						// 0 = FM2
		// Airplane Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Vector3(),	// Object Rotation (degrees)
		AirObj: makMsh(),				// Airplane Object
		AirPBY: makMsh(),				// 	
		// Airplane PBY Changes
		RotDif: new THREE.Vector3(0,0,0),	// Change	
		// Airplane Speed
		SpdKPH: BegSpd,					// Speed kMH
		SpdMPS: BegSpd/3.6,				// Speed (meters/sec)
		SpdMPF: (BegSpd/3.6)*DLTime,	// Speed (meters/frame)
		// Airplane Map Speed and Position
		MapSpd: new THREE.Vector3(),	// Map Speed (meters)
		MapPos: new THREE.Vector3().copy(BegPos), // Map Position (meters)
		MapSPS: new THREE.Vector3(0,BegPos.y,0), // MSX, MPY, MSZ (meters)
		// Variables Obtained from Flight
		PwrPct: PwrPct,					// Percent of Primary Power (Main and Flight)
		SupPct: 0,						// Percent of Supplemental Power (War Enmergency or Afterburner)
		CfLift: 0,						// Coefficient of Lift (user input) - determines lift
		CfFlap: 0,						// Coefficient of Lift due to flaps (user input)
		FlpPct: 0,						// Percent of Flaps
		LngPct: 0,						// Percent of Landing Gear
		BrkPct: 0,						// Percent of Air Brakes
		SplPct: 0,						// Percent of Spoiler
		AGBank: 0,						// Aileron Bank on Ground/* Vectors */
		BrkVal: 0,						// Brakes
		GrdZed: 0,						// Ground level (default)
		GrdFlg: 0,						// Ground Flag (1 = on ground)
		ACPAdj: 0,						// Aircraft pitch adjustment
		MovFlg: 0,						// If Sitting on a Moving Object
		// Fixed Values Obtained from Flight
		ACMass: 0,						// Airplane Mass
		Weight: 0,						// Used by autopilots
		FlpCfL: 0,						// Max Flap Cfl (0.2*CfLMax)
		CfLMax: 0,						// Maximum Coefficient of Lift
		PYBmul: new THREE.Vector3(0,0,0), // Airplane Pitch//Yaw/Bank Multiplier
		BnkMax: 0,						// Maximum bank rate
		// Horizontal Turn Rate
		HrzTrn: 0						// Horizontal turn rate
	}
let quaternion = new THREE.Quaternion();
// Adjustments
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY);
let InpPwr = 0;							// Power

//- Load Models and Animations -------------------------------------------------
//-	File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/b29/";	// Used to load models and sounds
//-	Animation Mixers - My Aircraft
let ACFile = "b29_flyt_6bg_npa.glb";	// Name of aircraft model file (rotated blender file)
// Mixers
var mxPrp1 = 0;						// Prop1
var mxPrp2 = 0;						// Prop2
var mxPrp3 = 0;						// Prop3
var mxPrp4 = 0;						// Prop4
var mxRudr = 0;						// Rudder
var mxElev = 0;						// Elevator
var mxAilL = 0;						// AileronL
var mxAilR = 0;						// AileronR
// All range from 0 to 360 with center at 180
var spnprp = 180;					// Propellers 	degrees = 0 to 360
var rudder = 180;					// Rudder 		degrees = +/- 360
var elvatr = 180;					// Elevator 	degrees = +/- 360
var aillft = 180;					// AileronL 	degrees = +/- 360
var ailrgt = 180;					// AileronR 	degrees = +/- 360
//-	Sounds
let acsnd1 = "b29.wav";				// File
let acvol1 = 0.1;					// Volume

//= TEXTURES ===================================================================
//- SkyBox
let SBPath = "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/";
//-	LensFlare
let LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let LF1Src = "https://threejs.org/examples/textures/lensflare/hexangle.png";
let LF0Txt, LF1Txt = 0;
//- Ocean
let DifSrc = "https://PhilCrowther.github.io/Aviation/textures/ocean/transition1F.png";
let RufSrc = "https://PhilCrowther.github.io/Aviation/textures/ocean/transition5.png";
let	NrmSrc = "https://threejs.org/examples/textures/waternormals.jpg";	// Size = 1024x1024
//- Canvas (for splitting up textures)
let ImgSiz = 512;						// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let	context = canvas.getContext('2d');
	context.translate(0, ImgSiz);		// Flips vertical for three.js
	context.scale(1,-1);
//- Clouds
let CldSrc = "https://threejs.org/examples/textures/opengameart/smoke1.png";
let CldTxt;

//= GRID DATA ==================================================================
let GrdSiz = 3200;				// Smallest Grid Square (3200 meters = 2 miles)
let GrdRes = 512;
let GrdSeg = 256;				// Segments per Plane (256 = OK, 512 = too much)

//= OCEAN ======================================================================
let WndSpd = 20.0;
let WndHdg = 0.0;
let Choppy = 1.6;
let WavMax = 5;					// Maximum wave height (set height of outer waves)
//
let waves = 0;
let wav_ = {
		// Sources
		Res: GrdRes,			// Resolution - segments per square (default = 512)
		Siz: GrdSiz,			// Size of Smallest Square = default = 3200m = 2 miles
		WSp: WndSpd,			// Wind Speed
		WHd: WndHdg,			// Wind Heading
		Chp: Choppy,			// default = 1
		// Animated Maps
		Dsp: 0,					// The Displacement Map
		Nrm: 0,					// The Normal Map
		NMS: vec2(1.0,-1.0),	// Normal Map Scale (flip Y for left-handed maps)
	};
let wavSpd = 1;					// Animation speed - use in main program (lower is faster)
let wavTim = 0;

//= GRID MODULE ================================================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let grids = 0;
let grd_ = {
		MSP: new THREE.Vector3 (),	// MSX, MPY, MSZ (meters) (from Flight)
		RCs: 16,				// Squares in each of first 2 grids
		Siz: GrdSiz,			// Size of smallest square
		Stp: 4,					// Squares in each of first 2 grids
		Seg: GrdSeg,			// Segments for smallest square
		Grx: [],				// Index of Grids (0-2)
		Geo: [],				// Master Index of Basic Geometries
		Col: WtrCol,			// Color
		Dsp: 0,					// Grid 0 Displacement Map (from Ocean)
		Nrm: 0,					// Grid 0-1 Normal Map (from Ocean)
		NMS: vec2(),			// Grid 0-1 Normal Map Scale (from Ocean)
		Df0: [],				// Grid 0-1 Diffuse Maps
		Rf0: [],				// Grid 0-1 Roughness Maps
		Mt0: [],				// Grid 0 Materials
		Mt1: [],				// Grid 1 Materials
		Dif: 0,					// Grid 2 Diffuse Map
		Ruf: 0,					// Grid 2 Roughness Maps
		Gr2: 0,					// Grid 2 Normal Map
		Mat: [],				// Grid 2 Materials
		WMx: WavMax,			// Max wave height, used to lower outer squares
	};
//	Since textures must be loaded in the Main Program and since design of materials 
//	and goemetry can vary, some of the Grid initialization is handled in the Main Program
//  by the LoadGeoMat and InitGeoMat routines

//= CLOUDS =====================================================================
let cloudn = 20;				// Number
let cloudm = 5000;				// Max Distance (meters)
let cloudo = 0.015				// Max Opacity
let clouds = [];				// Mesh
let cloudt = [];				// Cloud texture - top
let cloudb = [];				// Cloud texture - bottom
let cloudx = [
		cloudm*19/20,cloudm*17/20,cloudm*15/20,cloudm*13/20, cloudm*11/20,
		cloudm*9/20,cloudm*7/20,cloudm*5/20,cloudm*3/20, cloudm*1/20,
		-cloudm*1/20,-cloudm*3/20,-cloudm*5/20,-cloudm*7/20,-cloudm*9/20,
		-cloudm*11/20,-cloudm*13/20,-cloudm*15/20,-cloudm*17/20,-cloudm*19/20,
			];
let cloudy = [
		air_.MapSPS.y+250,air_.MapSPS.y+225,air_.MapSPS.y+200,air_.MapSPS.y+175,air_.MapSPS.y+150,
		air_.MapSPS.y-100,air_.MapSPS.y-25,air_.MapSPS.y-50,air_.MapSPS.y-75,air_.MapSPS.y-100,
		air_.MapSPS.y-75,air_.MapSPS.y-50,air_.MapSPS.y-25,air_.MapSPS.y+25,air_.MapSPS.y+75,
		air_.MapSPS.y+150,air_.MapSPS.y+175,air_.MapSPS.y+200,air_.MapSPS.y+225,air_.MapSPS.y+250,
			];
let cloudz = [
		cloudm*18/20,-cloudm*8/20,
		cloudm*12/20,-cloudm*2/20,
		cloudm*6/20,-cloudm*16/20,
		cloudm*0/20,-cloudm*10/20,
		cloudm*14/20,-cloudm*4/20,
		cloudm*8/20,-cloudm*18/20,
		cloudm*2/20,-cloudm*12/20,
		cloudm*16/20,-cloudm*6/20,	
		cloudm*10/20,-cloudm*0/20,
		cloudm*4/20,-cloudm*14/20,
			];

//= CAMERA =====================================================================
//-	Data for External View
let	CamExt = new THREE.Vector3(-10,240,150*Ft2Mtr); // Initial Lat Lon Dst
let CamRMX = new THREE.Vector2(80,0);	// Max/Min Lat Lon
//
let cam_ = {
		Sel: 0,						// View Selector (0 = external, 1 = linked to Airplane, 2 = Cockpit)
		Pan: 0,						// Pan Flag (1 = panning)
		Obj: makMsh(),				// Camera attached to this
		XYD: new THREE.Vector3(),	// cam_.Obj Lat, Lon, Dst
		RMx: new THREE.Vector2(),	// cam_.Obj Max/Min Lat Lon
		LMx: new THREE.Vector3(1.5*CamExt.z,0.5*CamExt.z,0.05),	// cam_.Obj Max/Min Length and Speed
		Flg: 0,						// View Flag (0 = external, 1 = Cockpit)
		Ctr: makMsh(),				// External link for cam_.Obj
	}
//- Adjustments
	cam_.Obj.rotation.order = "YXZ";
	cam_.Obj.rotation.y = Mod360(cam_.XYD.y)*DegRad;
//- Mouse Inputs
let onPointerDownX, onPointerDownY;
let onPointerDownLon, onPointerDownLat;

//= DEFAULT KEY BINDINGS =======================================================
let K_BnkL = 37;	// Bank Left (left arrow)
let K_BnkR = 39;	// Bank Right (right arrow)
let K_PitU = 40;	// Pitch up (down arrow)
let K_PitD = 38;	// Pitch down (up arrow)
let K_YawL = 90;	// Yaw Left (z)
let K_YawR = 88;	// Yaw Right (x)
let K_Vizz = 86;	// VC on/off (v)
let K_Soun = 83;	// Toggle Sound (s)
let K_Paws = 80;	// Pause (p)

//= STANDARD SETUP =============================================================
	document.body.appendChild(container);	// ### new
//- Display
let scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
let renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
let	maxAnisotropy = renderer.capabilities.getMaxAnisotropy();		// ### [A]
//- Light
let ambLight = new THREE.AmbientLight(SunCol, 0.25);
	scene.add(ambLight);
let sunLight = new THREE.DirectionalLight(SunCol, SunInt);
	sunLight.castShadow = true;
	sunLight.target.position.set(0,0,0);
	sunLight.shadow.bias = -0.00005;					// Default = 0 - causes lines;
	sunLight.shadow.mapSize.width = 8192;
	sunLight.shadow.mapSize.height = 8192;
	sunLight.shadow.camera.near = 0.001;
	sunLight.shadow.camera.far = LgtDst+LgtBox;
	sunLight.shadow.camera.left = -LgtBox;
	sunLight.shadow.camera.right = LgtBox;
	sunLight.shadow.camera.top = LgtBox;
	sunLight.shadow.camera.bottom = -LgtBox;
	scene.add(sunLight);
//- Sounds
let	listener = new THREE.AudioListener();
let sound1 = new THREE.PositionalAudio(listener);
let sound2 = new THREE.PositionalAudio(listener);
let sound3 = new THREE.PositionalAudio(listener);
let sound4 = new THREE.PositionalAudio(listener);
let EngObj = new THREE.Object3D();						// Aircraft Engine
	EngObj.add(sound1);									// Engine
	EngObj.add(sound2);									// Guns
	EngObj.add(sound3);									// Prop
	EngObj.position.z = -5;
	air_.AirObj.add(EngObj);
//- Camera
let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, SkyLim);
	camera.rotation.order = "YXZ";
	camera.add(listener);
	cam_.Obj.add(camera);
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	renderer.domElement.addEventListener("mousedown", onMouseDown, false);
	renderer.domElement.addEventListener("mouseup", onMouseUp, false);
	renderer.domElement.addEventListener("mousemove", onMouseMove, false);
	renderer.domElement.addEventListener('mousewheel', onMouseWheel, {capture: false, passive: false});
	renderer.domElement.addEventListener("touchstart", onTouchStart, false);
	renderer.domElement.addEventListener("touchmove", onTouchMove, false);
	document.getElementById("PAW").addEventListener("click", togglePause, false);
	document.getElementById("SND").addEventListener("click", toggleSound, false);
	document.getElementById("CAM").addEventListener("click", toggleCamera, false);
	document.getElementById("FST").addEventListener("click", toggleSpdU, false);
	document.getElementById("PTD").addEventListener("click", togglePitD, false);
	document.getElementById("SLO").addEventListener("click", toggleSpdD, false);
	document.getElementById("BKL").addEventListener("click", toggleBnkL, false);
	document.getElementById("CTR").addEventListener("click", toggleCntr, false);
	document.getElementById("BKR").addEventListener("click", toggleBnkR, false);
	document.getElementById("PTU").addEventListener("click", togglePitU, false);
	document.getElementById("YWL").addEventListener("click", toggleYawL, false);
	document.getElementById("YWR").addEventListener("click", toggleYawR, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
let audioLoader = new THREE.AudioLoader(loadingManager);
//- Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;		//keep = 0

//= 3D OBJECTS AND LINKS =======================================================
	scene.add(air_.AirObj);				// Airplane
	scene.add(cam_.Ctr);				// Camera

//= HTML OVERLAY TEXT ==========================================================
let Air_SpdElement = document.getElementById("Air_Spd");	// Airspeed
let Air_SpdNode = document.createTextNode("");
	Air_SpdElement.appendChild(Air_SpdNode);
let Air_AltElement = document.getElementById("Air_Alt");	// Altitude
let Air_AltNode = document.createTextNode("");
	Air_AltElement.appendChild(Air_AltNode);
let Air_HdgElement = document.getElementById("Air_Hdg");	// Heading
let Air_HdgNode = document.createTextNode("");
	Air_HdgElement.appendChild(Air_HdgNode);
let Air_Spd, Air_Alt,Air_Hdg;

//= Main Programs ==============================================================
	loadAll();
	
//=	0 Load All =================================================================
function loadAll() {
	// Load Values Used to initialize my Aircraft and Objects		
	WaitScreen();						// load loading screen
	loadSkyBox();
	loadGeoMat(grd_);
	loadACmine();
	loadClouds();
}

//= Wait Screen ================================================================
function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let geometry = new THREE.PlaneGeometry(1,1);
	let texture = txtrLoader.load("https://PhilCrowther.github.io/Aviation/images/prop.jpg");
	let material = new THREE.MeshBasicMaterial({map: texture});
	loadingScreen.box = new THREE.Mesh(geometry, material);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 Initialize ===============================================================
function initAll() {
	air_.MapSPS.y = air_.MapPos.y;			// Altitude (meters)
	initSkyBox();
	waves = new Ocean(renderer,wav_);	// Init Ocean
	grd_.Dsp = wav_.Dsp;
	grd_.Nrm = wav_.Nrm;
	grd_.NMS = wav_.NMS;
	grd_.MSP.y = air_.MapSPS.y;			// Init altitude (meters)
	grids = new GrdMap(grd_,scene);
	initClouds();
	// Other
	initCamera();						// position camera
	prntHUDval();						// print HUD values
	// Show stats
	if (stats) {						// show stats
		stats = new Stats();
		stats.setMode(0);				// FPS only
		stats.domElement.style.cssText = "position:absolute;top:95%;left:90%;";
		container.appendChild(stats.dom);
	}
	LodFlg = 1;
}

//= 2 Render ===================================================================

function rendAll() {
	// This block runs while resources are loading.
	nodeFrame.update();					// ### Nodes
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;										// Stop the function here.
	}
	if (PawsOn == 0 && LodFlg > 0) {
		// Update time
		nowTim = clock.getElapsedTime();
		difTim = nowTim-oldTim;
		wavTim = difTim*wavSpd || 0.0;
		oldTim = nowTim;
		// Move Objects
		moveACmine();					// Move aircaft
		// Move Grids
		waves.render(wavTim);			// Render Ocean
		grd_.MSP.copy(air_.MapSPS);
		grids.update(grd_);				// Grids
		moveClouds();
		// Other
		moveCamera();
		moveSounds(air_);
		prntHUDval();					// print HUD values
		if (stats) stats.update();		// update stats
	}
	renderer.render(scene, camera);
}

//= SKY BOX ====================================================================

function loadSkyBox() {
	let fpath = SBPath;
	let envMap = new THREE.CubeTextureLoader(loadingManager)
		.setPath(fpath)
		.load(["px2.jpg", "nx2.jpg", "py.jpg", "ny2.jpg", "pz2.jpg", "nz2.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace;	// ### r152
	scene.background = envMap;
	// LensFlare
	LF0Txt = txtrLoader.load(LF0Src);
	LF1Txt = txtrLoader.load(LF1Src);
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// SunLight Position
let SunPos = new THREE.Vector3(SunLLD.x,Mod360(180-SunLLD.y),SunLLD.z);
	SunPos = rotLLD(SunPos);	// Set Position above Light
	sunLight.position.copy(SunPos).normalize();	
	// Lensflare
let	spotLight = new THREE.PointLight(0xffffff);
	scene.add(spotLight);
	spotLight.position.copy(SunPos);
	let LF = new Lensflare();
	LF.addElement(new LensflareElement(LF0Txt, 256, 0));
	LF.addElement(new LensflareElement(LF1Txt, 32, 0.2));
	LF.addElement(new LensflareElement(LF1Txt, 256, 0.9));
	spotLight.add(LF);
}

//= GEOMAT =====================================================================
// Can't be exported since uses html context to split images

function loadGeoMat(grd_) {
	// Load Diffuse Texture
	if (DifSrc) {
		// Grid0 and Grid1 - Static Color Texture - Divided into 4 Parts
		imagLoader.load(DifSrc, function(image) {	// Load, Split and Save Textures
			context.drawImage(image,0,0,ImgSiz,ImgSiz);
			let idx = 0;
			let siz = ImgSiz/4;
			for (let z = 0; z < 4; z++) {
				for (let x = 0; x < 4; x++) {
					let ImgDat = context.getImageData(siz*x, siz*z, siz, siz);
					let texture = new THREE.DataTexture(ImgDat.data, siz, siz);
					texture.format = THREE.RGBAFormat;
					texture.magFilter = THREE.LinearFilter;
					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.generateMipmaps = true;
					texture.needsUpdate = true;
					grd_.Df0[idx] = texture;
					idx++;				
				}
			}
		});
		// Grid2 - Static Color Map Texture
		txtrLoader.load(DifSrc, function(texture) {	// Load and Save entire Texture
			texture.format = THREE.RGBAFormat;
			texture.magFilter = THREE.LinearFilter;
			texture.minFilter = THREE.LinearMipMapLinearFilter;
			texture.generateMipmaps = true;
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.offset.set(0,0);
			texture.needsUpdate = true;
			grd_.Dif = texture;
		});
	}
	// Load Roughness Texture
	if (RufSrc) {
		// Grid0 and Grid1 - Static Color Texture - Divided into 4 Parts
		imagLoader.load(RufSrc, function(image) {	// Load, Split and Save Textures
			context.drawImage(image,0,0,ImgSiz,ImgSiz);
			let idx = 0;
			let siz = ImgSiz/4;
			for (let z = 0; z < 4; z++) {
				for (let x = 0; x < 4; x++) {
					let ImgDat = context.getImageData(siz*x, siz*z, siz, siz);
					let texture = new THREE.DataTexture(ImgDat.data, siz, siz);
					texture.format = THREE.RGBAFormat;
					texture.magFilter = THREE.LinearFilter;
					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.generateMipmaps = true;
					texture.needsUpdate = true;
					grd_.Rf0[idx] = texture;
					idx++;				
				}
			}
		});
		// Grid2 - Static Color Map Texture
		txtrLoader.load(RufSrc, function(texture) {	// Load and Save entire Texture
			texture.format = THREE.RGBAFormat;
			texture.magFilter = THREE.LinearFilter;
			texture.minFilter = THREE.LinearMipMapLinearFilter;
			texture.generateMipmaps = true;
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.offset.set(0,0);
			texture.needsUpdate = true;
			grd_.Ruf = texture;
		});
	}
	// Grid2 - Static Normal Map
	txtrLoader.load(NrmSrc, function(texture) {
		texture.format = THREE.RGBAFormat;
		texture.magFilter = THREE.LinearFilter;
		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.generateMipmaps = true;
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.offset.set(0,0);
		texture.repeat.set(grd_.Stp*grd_.Stp/2,grd_.Stp*grd_.Stp/2);
		texture.needsUpdate = true;
		grd_.Gr2 = texture;
	});
}

//= MY AIRCRAFT ================================================================

function loadACmine() {
	loadACMineX();
}

//-	Load Airplane Model --------------------------------------------------------
function loadACMineX() {
	let fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {	// The OnLoad function
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.material.envMap = scene.background;
				child.castShadow = true;
				child.receiveShadow = true;
			}
		});
		ACMine = gltf.scene;
		ACMine.rotation.order = "YXZ";
		ACMine.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		//- Animations ------------------------------------------------------------
		// Prop1
		let clip =  THREE.AnimationClip.findByName(gltf.animations, "prop1Action");
		mxPrp1 = new THREE.AnimationMixer(ACMine);
		let actun = mxPrp1.clipAction(clip);
		actun.play();
		if (mxPrp1) mxPrp1.setTime(spnprp/anmfps);
		// Prop2
		clip =  THREE.AnimationClip.findByName(gltf.animations, "prop2Action");
		mxPrp2 = new THREE.AnimationMixer(ACMine);
		actun = mxPrp2.clipAction(clip);
		actun.play();
		if (mxPrp2) mxPrp2.setTime(spnprp/anmfps);
		// Prop3
		clip =  THREE.AnimationClip.findByName(gltf.animations, "prop3Action");
		mxPrp3 = new THREE.AnimationMixer(ACMine);
		actun = mxPrp3.clipAction(clip);
		actun.play();
		if (mxPrp3) mxPrp3.setTime(spnprp/anmfps);
		// Prop4
		clip =  THREE.AnimationClip.findByName(gltf.animations, "prop4Action");
		mxPrp4 = new THREE.AnimationMixer(ACMine);
		actun = mxPrp4.clipAction(clip);
		actun.play();
		if (mxPrp4) mxPrp4.setTime(spnprp/anmfps);
		// Rudder
		mxRudr = new THREE.AnimationMixer(ACMine);
		clip =  THREE.AnimationClip.findByName(gltf.animations, "rudderAction");
		actun = mxRudr.clipAction(clip);
		actun.play();
		if (mxRudr) mxRudr.setTime(rudder/anmfps);
		// Elevator
		clip =  THREE.AnimationClip.findByName(gltf.animations, "elevatorAction");
		mxElev = new THREE.AnimationMixer(ACMine);
		actun = mxElev.clipAction(clip);
		actun.play();
		if (mxElev) mxElev.setTime(elvatr/anmfps);
		// AileronL
		clip =  THREE.AnimationClip.findByName(gltf.animations, "aileronLAction");
		mxAilL = new THREE.AnimationMixer(ACMine);
		actun = mxAilL .clipAction(clip);
		actun.play();
		if (mxAilL) mxAilL.setTime(aillft/anmfps);
		// AileronR
		clip =  THREE.AnimationClip.findByName(gltf.animations, "aileronRAction");
		mxAilR = new THREE.AnimationMixer(ACMine);
		actun = mxAilR.clipAction(clip);
		actun.play();
		if (mxAilR) mxAilR.setTime(ailrgt/anmfps);
		//
		air_.AirObj.add(ACMine);
		ACMine.castShadow = true;
		ACMine.receiveShadow = true;
	});
}

//- Move Airplane Model / Virtual Cockpit --------------------------------------
function moveACmine() {
	// Pitch -----------------------------------------------
//	air_.RotDif.x = InpKey.x;		// Change to Pitch Speed
	air_.RotDif.x = 0;					// OVERRIDE
	// Self-centering
	if (air_.RotDif.x > -0.001 && air_.RotDif.x < 0.001) {
		if (air_.AirRot.x == 0) air_.RotDif.x = 0;
		if (air_.AirRot.x < 5 && air_.AirRot.x > -5) air_.RotDif.x = -0.01 * air_.AirRot.x;
	}
	// Bank ------------------------------------------------
	air_.RotDif.z = InpKey.z;		// Change to Bank Speed
	// Self-centering
	if (air_.RotDif.z > -0.001 && air_.RotDif.z < 0.001) {
		if (air_.AirRot.z == 0) air_.RotDif.z = 0;
		if (air_.AirRot.z < 7.5) air_.RotDif.z = -0.01 * air_.AirRot.z;
		if (air_.AirRot.z > 352.5) air_.RotDif.z = 0.01 * (360 - air_.AirRot.z);
	}
	// Yaw
	air_.RotDif.y = InpKey.y;
	// Turn Rate
	// Formula: tan(bank) * G/V = tan(bank) * 32.174 / 300 fps (aprox 200 mph)
	let ACBrad = air_.AirRot.z * DegRad;
	air_.HrzTrn = Math.tan(ACBrad) * 32.174 / 300;
	if (air_.HrzTrn > 0.2) air_.HrzTrn = 0.2;
	if (air_.HrzTrn < -0.2) air_.HrzTrn = -0.2;
	air_.HrzTrn = air_.HrzTrn * Math.cos(air_.AirRot.x*DegRad);
	if (air_.AirRot.z > 90 && air_.AirRot.z < 270) air_.HrzTrn = -air_.HrzTrn;
	// Make Bank, Pitch and Yaw Rotations to air_.AirObj
	air_.AirPBY.rotation.set(-air_.RotDif.x*DegRad,-air_.RotDif.y*DegRad,-air_.RotDif.z*DegRad);
	air_.AirPBY.getWorldQuaternion(quaternion);
	air_.AirObj.setRotationFromQuaternion(quaternion);	// Save result in air_.AirObj
	air_.AirPBY.rotation.set(0,0,0); // Zero Out air_.AirPBY Rotations (so values not doubled)
	air_.AirObj.rotation.x = 0; // ### OVERRIDE for Static Display
	// Update air_.AirObj Heading for Bank
	air_.AirRot.y = Mod360(-air_.AirObj.rotation.y*RadDeg+air_.HrzTrn);
	air_.AirObj.rotation.y = -air_.AirRot.y*DegRad;
	// Load Resulting Values into Variables (for display)
	air_.AirRot.x = air_.AirObj.rotation.x*RadDeg;
	air_.AirRot.z = Mod360(-air_.AirObj.rotation.z*RadDeg); // Mod360 required 
	// SpeedDLT
	air_.SpdMPS = air_.SpdKPH * 5280 / 3600;	// Aircraft Speed (FPS)
	air_.SpdMPF = air_.SpdMPS * DLTime;		// Aircraft Speed (DLT)
	// Speed
	let ACPrad = air_.AirRot.x*DegRad;
//	let PSpdYV = air_.SpdMPF*Math.abs(Math.sin(ACPrad));
	let PSpdYV = 0; // ### OVERRIDE for Static Display
	let PSpdZV = air_.SpdMPF*Math.abs(Math.cos(ACPrad));
	let ACH = air_.AirRot.y*DegRad; // Map Speed
	air_.MapSpd.set(PSpdZV*Math.sin(ACH),PSpdYV,PSpdZV*Math.cos(ACH));
	if (USorSI == "US") air_.MapSpd.multiplyScalar(Ft2Mtr);	// speed in meters
	air_.MapPos.set(air_.MapPos.x+air_.MapSpd.x,air_.MapPos.y+air_.MapSpd.y,air_.MapPos.z+air_.MapSpd.z); // Map Position (meters)
	air_.MapSPS.set(air_.MapSpd.x,air_.MapPos.y,air_.MapSpd.z);	// data for grids in meters
	/* Animations ----------------------------------------------------------- */
	// Propellers
	let prpspd =  4 * (PwrPct - 0.6);		// Range = -2.4 to + 1.6
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359;			// A complete circle
	if (mxPrp1) mxPrp1.setTime(spnprp/anmfps);
	if (mxPrp2) mxPrp2.setTime(spnprp/anmfps);
	if (mxPrp3) mxPrp3.setTime(spnprp/anmfps);
	if (mxPrp4) mxPrp4.setTime(spnprp/anmfps);
	// Rudder
	rudder = PoM360(air_.AirRot.z) * 0.02;
	rudder = 180 + rudder * 30;
	// Elevator
//	elvatr = 180 - (ACLftD * 10 - TrmAdj) * 5;
	if (elvatr < 150) elvatr = 150;			// Range = 00 to 60
	else if (elvatr > 209) elvatr = 209;
	if (mxElev) mxElev.setTime(elvatr/anmfps);
	// Ailerons
	if (mxAilL) mxAilL.setTime(aillft/anmfps);
	if (mxAilR) mxAilR.setTime(ailrgt/anmfps);	
}

//= SOUNDS =====================================================================

// Load Sounds
function loadSounds() {	
	//- My Engines -------------------------------------------------------------
	let fname = ACPath + "/fx/" + acsnd1;
	audioLoader.load(fname, function(buffer) {
		sound1.setBuffer(buffer);
		sound1.setRefDistance(RefDst);
		sound1.setLoop(true);
		sound1.setVolume(0);
	});
}

// Change Sounds
function moveSounds(air_) {
	// My Engine
	sound1.setVolume(acvol1 + air_.PwrPct * 0.05);	// Range = .1 to .2
	sound1.setPlaybackRate(1 + air_.PwrPct * 0.5);	// Range = 1 to 1.5
}

//= CLOUDS =====================================================================

function loadClouds() {
	CldTxt = txtrLoader.load(CldSrc);
}

function initClouds() {
	let sprite,posx,posy,posz,dist,indx,scale;
	for (var n = 0; n < cloudn; n++) {	// for each cloud
		clouds[n] = new THREE.Group;
		cloudt[n] = new THREE.SpriteMaterial({	// light above
			color: 0xd0d0d0,	// lighter color
			map: CldTxt,
			transparent:true,
			depthWrite:false
		});
		cloudb[n] = new THREE.SpriteMaterial({	// dark below
			color: 0x808080,	// darker color
			map: CldTxt,
			transparent:true,
			depthWrite:false
		});	
		for (var r = 0; r < 360; r ++) {	// for each sprite
			sprite = new THREE.Sprite(cloudt[n]);
			dist = Math.random()*180+40;	// basic size (40 prevents crowding in center)
			posx = dist*Math.sin(r*DegRad)*1.75;	// creates oval shape
			posz = dist*Math.cos(r*DegRad);
			dist = Math.sqrt(posx*posx+posz*posz);	// distance
			indx = (1000-dist)/1000;	// ratio 1 to 0			
			posy = (Math.random()-0.5)*25*indx;	// lens shape
			if (posy < -.9) sprite.material = cloudb[n]; // dark
			sprite.position.set(posx,posy,posz);
			sprite.scale.set(150, 90*indx, 90); // sprites smaller at edge
			clouds[n].add(sprite);	// add sprite to cloud
		}
		scale = 2*Math.random()+1;	// Range = 1 to 2
		clouds[n].scale.set(scale,scale,scale)
		clouds[n].position.set(cloudx[n],cloudy[n],cloudz[n]);
		scene.add(clouds[n]);
	}
}

function moveClouds() {
	let dist;	// xz distance
	for (var n = 0; n < cloudn; n++) {
		// Compute new relative position: air_.MapSPS = xspd,ypos,zspd
		cloudx[n] = cloudx[n]-air_.MapSPS.x;
		let heighty = cloudy[n]-air_.MapSPS.y;
		cloudz[n] = cloudz[n]+air_.MapSPS.z;
		// Reset position if out of bounds
		if (cloudx[n] > cloudm) cloudx[n] = -cloudm;
		if (cloudx[n] < -cloudm) cloudx[n] = cloudm;
		if (cloudz[n] > cloudm) cloudz[n] = -cloudm;
		if (cloudz[n] < -cloudm) cloudz[n] = cloudm;
		// Set 
		clouds[n].position.set(cloudx[n],heighty,cloudz[n]);
		// Fade out based on distance
		dist = Math.sqrt(cloudx[n]*cloudx[n]+cloudz[n]*cloudz[n]);
		cloudt[n].opacity = cloudo*(1.5*cloudm-dist)/(1.5*cloudm);
		cloudb[n].opacity = cloudo*(1.5*cloudm-dist)/(1.5*cloudm);
	}
}

//= CAMERA =====================================================================

function initCamera() {
	if (cam_.Sel == 0) {	// External View
		cam_.Ctr.add(cam_.Obj);			// Camera attached to cam_.Ctr
		camera.rotation.y = 180*DegRad;	// Looking in
		cam_.XYD.copy(CamExt);			// cam_.XYD rotation
		cam_.RMx.copy(CamRMX);			// Max/Min Lat Lon
		cam_.Flg = 0;
	}
	if (cam_.Sel == 1) {	// External View - Linked to Plane
		air_.AirObj.add(cam_.Obj);			// Camera attached to aircraft
		camera.rotation.y = 180*DegRad;	// Looking in
		cam_.XYD.copy(CamExt);			// cam_.XYD rotation
		cam_.RMx.copy(CamRMX);			// Max/Min Lat Lon
		cam_.Flg = 0;
	}
	moveCamera();
}

function moveCamera() {
	// Compute New cam_XYD
	cam_.XYD.x = Math.max(-cam_.RMx.x, Math.min(cam_.RMx.x, cam_.XYD.x));
	cam_.XYD.y = Mod360(cam_.XYD.y);
	camera.position.z = -cam_.XYD.z;	// length of armature
	cam_.Obj.rotation.x = Mod360(-cam_.XYD.x)*DegRad;
	cam_.Obj.rotation.y = Mod360(180-cam_.XYD.y)*DegRad;
	cam_.Ctr.rotation.y = Mod360(-air_.AirRot.y)*DegRad;	// Rotate with airplane
}

//= OUTPUTS ===================================================================

// Change HUD Values
function prntHUDval() {
	Air_Spd = air_.SpdKPH*Km2Mil;			// Aircraft Speed (MPH)
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Alt = air_.MapPos.y*Mtr2Ft;		// Aircraft Altitude (feet)
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);
	Air_Hdg = air_.AirRot.y;				// Aircraft Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
}

//= INPUTS =====================================================================

//= Mouse Input ================================================================

function onMouseDown(event) {
	event.preventDefault();
	cam_.Pan = 1;
	onPointerDownX = event.clientX;
	onPointerDownY = event.clientY;
	onPointerDownLon = cam_.XYD.y;
	onPointerDownLat = cam_.XYD.x;
}

function onMouseUp(event) {
	cam_.Pan = 0;
}

function onMouseMove(event) {
// Panning View
	if (cam_.Pan) {
		cam_.XYD.x = (onPointerDownY - event.clientY) * 0.2 + onPointerDownLat;
		cam_.XYD.x = Math.max(-cam_.RMx.x, Math.min(cam_.RMx.x, cam_.XYD.x));
		cam_.XYD.y = (event.clientX - onPointerDownX) * 0.2 + onPointerDownLon;
		cam_.XYD.y = Mod360(cam_.XYD.y);
		if (cam_.Flg) {	// Limit Lon (Internal View Only)
			if (cam_.XYD.y > 180 && cam_.XYD.y < (360-cam_.RMx.y)) cam_.XYD.y = (360-cam_.RMx.y);
			if (cam_.XYD.y < 180 && cam_.XYD.y > cam_.RMx.y) cam_.XYD.y = cam_.RMx.y;
		}
	}
}

function onMouseWheel(event) {
	if (cam_.Flg) {	// Internal View
		air_.PwrPct = air_.PwrPct - event.deltaY * 0.0001;	// Move Throttle: Increment = 1%
		if (air_.PwrPct > 1) air_.PwrPct = 1;
		if (air_.PwrPct < 0) air_.PwrPct = 0;
	}
	else {	// External View
		cam_.XYD.z = cam_.XYD.z + event.deltaY * cam_.LMx.z;
		if (cam_.XYD.z < cam_.LMx.y) cam_.XYD.z = cam_.LMx.y;
		if (cam_.XYD.z > cam_.LMx.x) cam_.XYD.z = cam_.LMx.x;
	}
}

//= Keyboard Input =============================================================

// Key Down
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Bank Left
	if (event.keyCode == K_BnkL) InpKey.z = -KeyVal.z;
	// Bank Right
	if (event.keyCode == K_BnkR) InpKey.z = KeyVal.z;
	// Pitch Up
	if (event.keyCode == K_PitU) InpKey.x = KeyVal.x;
	// Pitch Down
	if (event.keyCode == K_PitD) InpKey.x = -KeyVal.x;
	// Yaw Left
	if (event.keyCode == K_YawL) InpKey.y = -0.1;
	// Yaw Right
	if (event.keyCode == K_YawR) InpKey.y = 0.1;
	// Sound
	if (event.keyCode == K_Soun) toggleSound();
	// View
	if (event.keyCode == K_Vizz) toggleCamera();
	// Pause
	if (event.keyCode == K_Paws) togglePause();	
}

// Key Up
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Bank Left
	if (event.keyCode == K_BnkL) InpKey.z = 0;
	// Bank Right
	if (event.keyCode == K_BnkR) InpKey.z = 0;
	// Pitch Up
	if (event.keyCode == K_PitU) InpKey.x = 0;
	// Pitch Down
	if (event.keyCode == K_PitD) InpKey.x = 0;
	// Yaw Left
	if (event.keyCode == K_YawL) InpKey.y = 0;
	// Yaw Right
	if (event.keyCode == K_YawR) InpKey.y = 0;
}

//= Touch Screen Input =========================================================

function onTouchStart(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		onPointerDownX = event.touches[0].clientX;
		onPointerDownY = event.touches[0].clientY;
		onPointerDownLon = cam_.XYD.y;
		onPointerDownLat = cam_.XYD.x;
	}
}

function onTouchMove(event) {
	// Single Touch
	if (event.touches.length == 1) {
		event.preventDefault();
		cam_.XYD.x = (event.touches[0].clientY - onPointerDownY) * 0.2 + onPointerDownLat;
		cam_.XYD.x = Math.max(-cam_.RMx.x, Math.min(cam_.RMx.x, cam_.XYD.x));
		cam_.XYD.y = (onPointerDownX - event.touches[0].clientX) * 0.2 + onPointerDownLon;
		cam_.XYD.y = Mod360(cam_.XYD.y);
		if (cam_.Flg) {
			if (cam_.XYD.y > 180 && cam_.XYD.y < (360-cam_.RMx.y)) cam_.XYD.y = (360-cam_.RMx.y);
			if (cam_.XYD.y < 180 && cam_.XYD.y > cam_.RMx.y) cam_.XYD.y = cam_.RMx.y;
		}
	}
}

//= Button Input ===============================================================

//- Toggle Pause
function togglePause() {
	PawsOn = 1 - PawsOn;
}

// Toggle Sound
function toggleSound() {
	if (SndFlg == 0) {
		SndFlg = 1;
		sound1.play();
	}
	else {
		SndFlg = 0;
		sound1.stop();
	}
}

// Change Camera View (2-Way)
function toggleCamera() {
	// From Level to Linked
	if (cam_.Sel == 0) {
		CamExt.copy(cam_.XYD);	// Save new XYD
	}
	// From Linked to Level
	if (cam_.Sel == 1) {
		CamExt.copy(cam_.XYD);	// Save new XYD
	}
	// Advance to New View
	cam_.Sel = cam_.Sel+1;
	if (cam_.Sel == 2) cam_.Sel = 0;
	initCamera();
}

// Flight Controls

function toggleSpdU() {
	InpPwr = 0.001;
}

function togglePitD() {
	if (InpKey.x) InpKey.x = 0;
	else InpKey.x = InpKey.x = -KeyVal.x;
}

function toggleSpdD() {
	InpPwr = -0.001;
}

function toggleBnkL() {
	if (InpKey.z) InpKey.z = 0;
	else InpKey.z = -KeyVal.z;
}

function toggleCntr() {
	InpKey.x = 0;
	InpKey.z = 0;
	InpKey.y = 0;
}

function toggleBnkR() {
	if (InpKey.z) InpKey.z = 0;
	else InpKey.z = KeyVal.z;
}

function toggleYawL() {
	if (InpKey.y) InpKey.y = 0;
	else InpKey.y = -0.1;
}

function togglePitU() {
	if (InpKey.x) InpKey.x = 0;
	else InpKey.x = KeyVal.x;
}

function toggleYawR() {
	if (InpKey.y) InpKey.y = 0;
	else InpKey.y = 0.1;
}

// Window Resize
function onWindowResize() {
	camera.aspect = window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

//= CHANGES ====================================================================
// 230511 - This version
// 240218 - Removed internal function references to common variable

</script>
</body>
</html>