<!doctype html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 1 Jun 2025

A demo of a flight simulation of an animated airplane model over farmland using WebGPU and NodeMaterials.
-->

<head>
<title>fsim Pup land gpu r177</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Throttle: <span id="Air_Pwr"></span></div>
		<div>AirSpeed: <span id="Air_Spd"></span> mph</div>
		<div>Altitude: <span id="Air_Alt"></span> ft</div>
		<div>Heading : <span id="Air_Hdg"></span> deg</div>
		<div>CoefLift: <span id="Air_CfL"></span></div>
	</div>
	<div class="overlay2">
		<div><span id="On_Paws"></span></div>
		<div><span id="Air_AtP"></span></div>
		<div><span id="On_Inf0"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Inf1"></span></div>
		<div><span id="On_Inf2"></span></div>
		<div><span id="On_Inf3"></span></div>
		<div><span id="On_Inf4"></span></div>
		<div><span id="On_Inf5"></span></div>
		<div><span id="On_Inf6"></span></div>
		<div><span id="On_Inf7"></span></div>
		<div><span id="On_Inf8"></span></div>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script src="https://PhilCrowther.github.io/Aviation/models/pup/data/data.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.webgpu.js",
			"three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.webgpu.js",
			"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.tsl.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/",
			"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.8/dist/main.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {color,float,texture} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement} from "three/addons/objects/LensflareMesh.js";
import Stats from "stats-gl";
// Custom Modules
import {Flight,Mod360,PoM360,MaxVal} from "https://PhilCrowther.github.io/Aviation/jsm/Flight.js";
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdMap.js"; // r171

//= INPUTS =====================//==============================================
//- AIRPLANE: Start -----------------------------------------------------------
let BegLoc = 0;					// Starting Location (0 = Base; 1 = Air)
let CamSel = 0;					// Camera Seletion (0 = External; 1 = Internal)
let BegTmp = 288.15;			// K = 59F
//- AIRPLANE: Flight -----------------------------------------------------------
let PYBmul = new THREE.Vector3(0.004,1.0,0.001); // Basic airplane values
let	MosMul = new THREE.Vector3(1.0,1.0,1.0); // Adjustment to PYBmul (default = 1)
let PwrMul = 0.0005;			// Power % Input - Mouse Multiplier
let PwrDif = 0;					// Power % Input - Value
let Throtl = 0;					// Throttle Setting (0 to 1)
let InpBrk = 0;					// Brakes
//- Mouse Delays ...............................................................
//- (x = diverted, y = released, z = stored)
let LagPwr = new THREE.Vector3(1-1/30,1/15,0);	// Power
let LagCfL = new THREE.Vector3(1-1/30,1/15,0);	// CfL
let LagAtP = new THREE.Vector2(0.967,0.099);	// CfL - Autopilot
let LagBnk = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- POINTER LOCK CONTROLS ------------------------------------------------------
let InpMos = new THREE.Vector2(); // Inputs - Mouse
let _changeEvent = {type: "change"};
let _lockEvent = {type: "lock"};
let _unlockEvent = {type: "unlock"};
//- Key Vaulues (XZ = Autopilot Pitch/Bank; Y = Yaw Mouse Button or Key) .......
let KeyVal = new THREE.Vector3(1,.05,0.25);	// Key Values (Yaw = turn rate in 15 deg bank)

//= CONSTANTS ==================//==============================================
//	Time
let	DLTime = 1/60;				// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;		//
//	Conversions
let DegRad = Math.PI/180;		// Convert Degrees to Radians
let RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Ft2Mtr = 0.3048;			// Convert Feet to Meters
let Mtr2Ft = 1/0.3048;
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//	Default Constants
let	GrvMPS = 9.80665; 			// Gravity (mps)
//	Starting Constants per frame
let GrvDLT = GrvMPS*DLTim2;

//= INPUT VALUES ===============//==============================================
//- Display
let PawsOn = 0;					// Pause
let InfoOn = 0;					// Info
let SndFlg = 0;
let StatOn = 1;					// Stats ((0 = off, 1 = on)
let LnFFlg = 1;					// Lensflare
//	Program Flags
let LodFlg = 0;					// Set at end of initialization
let LodSnd = 0;					// Set when sound initialized
//	Altitude Adjustment
let AltAdj = 0.99;				// Raises objects above map as altitude increases

//= SUN VALUES =================//==============================================
let SunCol = 0xffffff;			// Sun
let SunInt = 3;					// Default intensity of light/sun
//- Rotation and Position (fixed)
let SunDst = 50;				// Distance (for shadows)
let SunLat = 23;				// Direction - Vert (+/- 90)
let SunLon = 312;				// Direction - Horz (0->360)
//- New
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);
//	Shadows
let ShdBox = 6;					// Size of shadow box
let ShdBLR = 6.5;
let ShdBTB = 4;
let ShdDst = 1500;				// Shadow Distance (meters)

//= STANDARD SETUP =============//==============================================
//- Scene
let scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
//- Light
let ambLight = new THREE.AmbientLight(SunCol,0.2);
	scene.add(ambLight);
//- SunLight
let sunLight = new THREE.DirectionalLight(SunCol,SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = SunDst*0.75;
	sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -ShdBLR;
	sunLight.shadow.camera.right = ShdBLR;
	sunLight.shadow.camera.top = ShdBTB;
	sunLight.shadow.camera.bottom = -ShdBTB;
	sunLight.shadow.bias = -0.00001; // WebGPU (0 flashing; -0.0001 no wheels)
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
let camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//- Renderer
let renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
let maxAnisotropy = renderer.getMaxAnisotropy();
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
//- Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= SKY ========================//==============================================
let FogCol = 0xbab4a6;			// Sky (for Fog only)
//- SkyBox
let SBxSrc = "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/";
//-	LensFlare
let LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let LF1Src = "https://threejs.org/examples/textures/lensflare/lensflare3.png";
let LF0Txt, LF1Txt = 0;

//= GEOMAT =====================//==============================================
//= Textures Data ==============//==============================================
//- All textures are 512X512
let dqSize = 1024;
let dqArea = dqSize*dqSize;
let dtSize = 512;
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;					// Total Textures
//- Canvas
let ImgSiz = 1024;				// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext("2d",{willReadFrequently: true});
//= Grid 4 Data ================//==============================================
//- 1/4 section squares (1/2 mile X 1/2 mile)
//- Variables
let GrdMul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];
//- Colors
let GrdDrt = "#1c160e";			// Color of underlying dirt (affects brightness)
let drtclr = [0x8e6d3d,0x47361e]; // Dirt
let pstclr = [0x00b000,0x005000]; // Pasture
let cvrclr = [0x75b24c,0x466b2d]; // Green
let whtclr = [0xfbf4e5,0xeabb63]; // Wheat
let bnsclr = [0xacd193,0x5d8e3d]; // Beans
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//	[https://icolorpalette.com/color/dirt-brown
let count0;
//= MATERIALS ==================//==============================================
//= Grid 0 Data ================//==============================================
//- Image Data
let G0DPtr = [];
	G0DPtr[txtTot-1] = 0;
//- Materials
let G0MPtr = [];
	G0MPtr[txtTot-1] = 0;
// Patterns for Grid 5 3X3 Textures
// Also used to draw Grid 4 textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G0Id00 = [4,3,5,4,3,0,5,2,1];
let G0Id01 = [3,0,4,1,2,4,5,3,5];
let G0Id02 = [5,1,3,4,5,0,2,4,3];
let G0Id03 = [2,4,1,3,5,3,5,0,4];
let G0Id04 = [5,1,5,0,3,4,2,4,3];
let G0Id05 = [3,0,5,3,4,5,1,2,4];
let G0Id06 = [2,0,3,5,3,1,4,4,5];
let G0Id07 = [1,5,4,3,5,0,2,4,3];
let G0Id08 = [2,3,0,5,3,1,4,5,4];
let G0Id09 = [0,2,5,3,4,3,5,1,4];
let G0Id10 = [4,3,5,4,5,2,1,3,0];
let G0Id11 = [4,5,3,0,1,4,3,5,2];
let G0Id12 = [3,1,2,4,5,3,5,0,4];
let G0Id13 = [0,5,3,1,4,2,4,3,5];
let G0Id14 = [1,4,2,5,3,0,4,5,3];
let G0Id15 = [4,1,5,0,3,4,3,5,2];
let G0Indx = [
		G0Id00,G0Id01,G0Id02,G0Id03,G0Id04,G0Id05,G0Id06,G0Id07,G0Id08,G0Id09,
		G0Id10,G0Id11,G0Id12,G0Id13,G0Id14,G0Id15
	];
//= Grid 1 Data ================//==============================================
let Gr1Mul = 3;
let Gr1Siz = Math.floor(dtSize/Gr1Mul);
// Image Data (Source Data - Resized)
let G1SPtr = [];
	G1SPtr[G0Indx.length-1] = 0;
// Image Data
let G1DPtr = [];
	G1DPtr[G0Indx.length-1] = 0;
// Materials
let G1MPtr = [];
	G1MPtr[G1DPtr.length-1] = 0;
// Index to Display of G1 Textures by Type
// Used by G0 to position squares
// And by G1 to create textures
let G1Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,	//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4,11,13, 8,12, 7,	// 11 = Over Airport
		 4, 7,15,12, 3,11, 9,13, 4,
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];
//= Grid 2 Data ================//==============================================
let Gr2Mul = 3;
let Gr2Siz = Math.floor(dtSize/Gr2Mul);
// Image Data (Source Data - Resized)
let G2SPtr = [0,0,0,0,0,0,0,0,0];
// Image Data
let G2DPtr = [0,0,0,0,0,0,0,0,0];
// Materials
let G2MPtr = [0,0,0,0,0,0,0,0,0];

//= GRID MODULE ================//==============================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let GrdSiz = 804.67;			// Size of Smallest Grid Square (1/4 section = 1/2 mile)
let grids = 0;
let grd_ = {
		SPS: new THREE.Vector3 (), // MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,				// Squares in each of first 2 grids
		Siz: GrdSiz,			// Size of smallest square
		Stp: 3,					// Squares in each of first 2 grids
		Grx: [],				// Index of Grids (0-2)
		Idx: [G0Indx,G1Indx],	// Index to Patterns
		Mat: [G0MPtr,G1MPtr,G2MPtr], // Materials
	}
/* = Roads =====================//============================================*/
//- North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,		// Size of square
		Stp:	1,				// Squares to flip
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		Txt:	0,				// Texture Address
		Shd:	1				// Shadow enabled
	}
//- East West
let Rod2 = {
		Typ:	2,
		RCs:	21,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,		// Size of square
		Stp:	1,				// Squares to flip
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		Txt:	0,				// Texture Address
		Shd:	1				// Shadow enabled
	}
//- Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//-	Tones of Dirt Brown Color | #836539 Monochromatic Color
//-	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);
//= Trees ======================================================================
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//= Objects ====================//==============================================
//- Distances in Meters
let ObjNum = 2;					// number of objects
let ObjTyp = [0];				// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];				// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];				// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];				// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];				// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];				// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];				// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];				// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
//- Hangars
	ObjTyp[ObjIdx] = 0;			// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 200;		// [m]
	ObjMPY[ObjIdx] = 0.3048;	// [m] 1 ft
	ObjMPZ[ObjIdx] = 250;		// [m]
	ObjIdx = ObjIdx + 1;
//- Giaros Island
	ObjTyp[ObjIdx] = 1;			// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/textures/giaros.png";
	ObjMPX[ObjIdx] = -1609.344;	// [m] 1 mile
	ObjMPY[ObjIdx] = 2*Ft2Mtr;	// [m] 2 ft
	ObjMPZ[ObjIdx] = 8046.72;	// [m] 5 miles

//= MY AIRPLANE ================//==============================================
//	Airplane Data
let	flight = 0;
let air_ = {
		// General Variables
		DLTime: DLTime,			// Seconds per frame (can vary)
		GrvMPS: GrvMPS,			// Gravity (ups)
		AirDSL: 0,				// Air Density (varies with altitude)
		// Designators
		AirDat: data_,			// Aircraft Type: 1 = Pup
		// Airplane Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Vector3(0,0,0),	// Rotation (in degrees)
		AirObj: new THREE.Object3D,		// Airplane Object 
		AirPBY: new THREE.Object3D,		// Changes in radians
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(0,0,0),	// Change
		// Airplane Speed
		SpdKPH: 0,				// Speed in KPH
		SpdMPS: 0,				// Speed - meters per second
		SpdMPF: 0,				// Speed - meters per frame	
		// Airplane Map Speed and Position
		MapSpd: new THREE.Vector3(), // Map Speed (meters)
		MapPos: new THREE.Vector3(), // Map Position (meters)
		MapSPS: new THREE.Vector3(), // MSX, MPY, MSZ (meters)
		// Variables Obtained from Flight
		PwrPct: 0,				// % of Primary Power (0 to 1) (Main and Flight)
		SupPct: 0,				// Percent of Supplemental Power (War Enmergency or Afterburner)
		CfLift: 0,				// Coefficient of Lift (user input) - determines lift
		CfFlap: 0,				// Coefficient of Lift due to flaps (user input)
		FlpPct: 0,				// Percent of Flaps
		LngPct: 0,				// Percent of Landing Gear
		BrkPct: 0,				// Percent of Air Brakes
		SplPct: 0,				// Percent of Spoiler
		AGBank: 0,				// Aileron Bank on Ground
		BrkVal: 0,				// Brakes
		GrdZed: 0,				// Ground level (default)
		GrdFlg: 0,				// Ground Flag (1 = on ground)
		ACPAdj: 0,				// Airplane pitch adjustment
		// Values for the Selected Airplane Type (obtained from Flight)
		CfLMax: 0,				// Maximum Coefficient of Lift
		FlpCfL: 0,				// Max Flap Cfl (0.2*CfLMax)
		ACMass: 0,				// Airplane Mass
		Weight: 0,				// Used by autopilots
		PYBmul: new THREE.Vector3().copy(PYBmul), // Airplane Pitch/Yaw/Bank Multiplier
		BnkMax: 0,				// Maximum bank rate
		// AutoPilot - Additional Variables
		AutoOn: 0,				// Autopilot Flag
		InpKey: new THREE.Vector3(), // Inputs - Keys (replace InpKey)
		OldRot: new THREE.Vector3(), // Old Rotation (z = radians)
		CfLDif: 0,				// Change in CfL
		MaxBnk: 0,				// Max Bank (display only)
		HdgDif: 0,				// Horizontal Turn Rate (display only)
		// Air Density and IAS Comps
		BegTmp: BegTmp,			// Beginning Sea Level Temperature (K)
		BegPrs: 1013.25,		// Beginning Sea Level Air Pressure (mB) - not used
		SpdIAS: 0,				// Indicated Airspeed
		// Ship Pitch and Bank
		MovFlg: 0,				// If Sitting on Moving Ship
		ShpPit: 0,
		ShpBnk: 0,
	}
// 
//- Adjustments
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY); // PBY includes air_.
	scene.add(air_.AirObj);
let AirGrp = new THREE.Group();	// To hold ACMine and VCMine
	air_.AirPBY.add(AirGrp);
let ACMine = 0;					// My Aircraft (loaded)
//- Load Models and Animations -------------------------------------------------
//-	File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/pup/";	// Used to load models and sounds
//-	Animation Mixers - External Model
let ACFile = "pup_flyt_npa.glb"; // Name of aircraft model file (rotated blender file)
//- Aircraft Animations
let anmfps = 24;				// Blender FPS
let aoarng = 20;				// AoA range (model)
//	Animation Mixers - External Model
let mxProp = 0;					// Propeller
let mxRudr = 0;					// Rudder
let mxElev = 0;					// Elevator
let mxAlTL = 0;					// AileronTL
let mxAlTR = 0;					// AileronTR
let mxAlBL = 0;					// AileronTL
let mxAlBR = 0;					// AileronTR
//- All range from 0 to 360 with center at 180
let elvatr = 180;				// Elevator 	degrees = +/- 360
let rudder = 180;				// Rudder 		degrees = +/- 360
let aillft = 180;				// AileronL 	degrees = +/- 360
let ailrgt = 180;				// AileronR 	degrees = +/- 360
let rotaoa = 180;				// AoA 			degrees = +/- 15
let spnprp = 180;				// Taildrag 	degrees = 0 to 360

//= GUNS =======================================================================
let GunFlg = 0;

//=	SOUNDS =====================//==============================================
//- My Engine
let EngSrc = "pup.mp3";			// File (my engine)
let EngVol = 0.1;				// Volume
let EngSnd = 0;
let EngMsh = new THREE.Object3D;
//- My Guns
let GunSrc = "pup_gun.mp3";		// File (my guns)
let GunVol = 0.5;				// Volume
let GunSnd = 0;
let GunMsh = new THREE.Object3D;

//= POINTER LOCK CONTROL =======================================================
class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement, plc_) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.addEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener("pointerlockerror", onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//- Setup ----------------------------------------------------------------------
let controls = new PointerLockControls(camera, renderer.domElement,air_);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener("unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

//= DEFAULT KEY BINDINGS =======//==============================================
let K_PwLU =  87;				// Power Up (w) - keyboard left
let K_PwLD =  81;				// Power Down (q) - keyboard left
let K_PwRU = 187;				// Power Up (=) - keyboard right
let K_PwRD = 189;				// Power Down (-) - keyboard right
let K_BnkL = 37;				// Bank Left (left arrow) - autopilot only
let K_BnkR = 39;				// Bank Right (right arrow) - autopilot only
let K_PitU = 40;				// Pitch up (down arrow) - autopilot only
let K_PitD = 38;				// Pitch down (up arrow) - autopilot only
let K_YwLL =  90;				// Yaw Left (z) - keyboard left
let K_YwLR =  88;				// Yaw Left (x) - keyboard left
let K_YwRL = 188;				// Yaw Left (,) - keyboard right
let K_YwRR = 190;				// Yaw Left (.) - keyboard right
let K_Brak = 66;				// Brakes (b)
let K_Guns = 32;				// Guns (spacebar)
//	Views
let K_Look = 16;				// Pan (shift)
let K_VU45 = 36;				// View Up (alone or modifier)
let K_VD45 = 35;				// View Down (alone or modifier)
let K_VL45 = 33;				// Left 45 degrees
let K_VR45 = 45;				// Right 45 degrees
let K_VL90 = 34;				// Left 90 degrees
let K_VR90 = 46;				// Right 90 degrees
//	Toggle
let K_Soun = 83;				// Toggle sound (s)
let K_Paws = 80;				// Pause (p)
let K_Auto = 65;				// Autopilot (a)
let K_Info = 73;				// Info (i)

//=	VIEW KEYS ==================//==============================================
let U45flg = 0;					// Up 45 degrees
let D45flg = 0;					// Down 45 degrees
let	L45flg = 0;					// Left 45 degrees
let R45flg = 0;					// Right 45 degrees
let L90flg = 0;					// Left 90 degrees
let R90flg = 0;					// Right 90 degrees

//= CAMERA =====================//==============================================
//- Create Cockpit Attach Point
let	CamPVC = new THREE.Object3D;
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirPBY.add(CamPVC); 	// Attach CamPVC to AirPBY (### not AirObj)
//- Camera Inputs (External Camera linked to air_.AirPBY; 1 Internal Camera Linked to cam_.PVC)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];			// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CmIFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
//- Shared Variables
let cam_ = {
		CamSel: CamSel,			// View Selector (0 = External, 1 = Internal)
		CamNum: CamNum,
		OrbFlg: 0,				// Orbit Flag (1 = Orbiting)
		// Camera
		CamLLD: new THREE.Vector3().copy(CamLLD[CamSel]),	// cam_.MshRot Lat, Lon, Dst
		CamAdj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		CamMMD: new THREE.Vector3().copy(CamMMD[CamSel]),	// In/Out - min,max,spd
		// Rotator
		MshRot: new THREE.Object3D,			// Camera Rotator
		CamMMR: new THREE.Vector3().copy(CamMMR[CamSel]),	// Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		Parent: CamPar[CamSel],	// Center of Rotation	
		CamFlg: CmIFlg[CamSel],	// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		CamLnk: CamLnk[CamSel],
		MshObj: new THREE.Object3D,
		MshDeg: new THREE.Object3D
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.MshRot.rotation.order = "YXZ";
	cam_.MshObj.rotation.order = "YXZ";
	cam_.MshDeg.rotation.order = "YXZ";
	cam_.Parent.add(cam_.MshRot);		// Attach Rotator
	cam_.MshObj.add(cam_.MshDeg);
//- Adjust Camera x.rotation
let CmAdjX = 0;					// Airborne Pitch Adjustment
let CmGrdF = 0;					// Camera Ground Flag (1 = On Ground)
let CmMulX = 15;				// Pitch Adjustment Multiplier
let CmLagX = 0;					// Transition Offset

//= HTML OVERLAY TEXT ==========//==============================================
let Air_PwrElement = document.getElementById("Air_Pwr");
let Air_PwrNode = document.createTextNode("");
	Air_PwrElement.appendChild(Air_PwrNode);
let Air_SpdElement = document.getElementById("Air_Spd");
let Air_SpdNode = document.createTextNode("");
	Air_SpdElement.appendChild(Air_SpdNode);
let Air_HdgElement = document.getElementById("Air_Hdg");
let Air_HdgNode = document.createTextNode("");
	Air_HdgElement.appendChild(Air_HdgNode);
let Air_AltElement = document.getElementById("Air_Alt");
let Air_AltNode = document.createTextNode("");
	Air_AltElement.appendChild(Air_AltNode);
let Air_CfLElement = document.getElementById("Air_CfL");
let Air_CfLNode = document.createTextNode("");
	Air_CfLElement.appendChild(Air_CfLNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
	On_PawsElement.appendChild(On_PawsNode);
let Air_AtPElement = document.getElementById("Air_AtP");	// Autopilot
let Air_AtPNode = document.createTextNode("");
	Air_AtPElement.appendChild(Air_AtPNode);
let On_Inf0Element = document.getElementById("On_Inf0");
let On_Inf0Node = document.createTextNode("");
	On_Inf0Element.appendChild(On_Inf0Node);
let On_Inf1Element = document.getElementById("On_Inf1");
let On_Inf1Node = document.createTextNode("");
	On_Inf1Element.appendChild(On_Inf1Node);
let On_Inf2Element = document.getElementById("On_Inf2");
let On_Inf2Node = document.createTextNode("");
	On_Inf2Element.appendChild(On_Inf2Node);
let On_Inf3Element = document.getElementById("On_Inf3");
let On_Inf3Node = document.createTextNode("");
	On_Inf3Element.appendChild(On_Inf3Node);
let On_Inf4Element = document.getElementById("On_Inf4");
let On_Inf4Node = document.createTextNode("");
	On_Inf4Element.appendChild(On_Inf4Node);
let On_Inf5Element = document.getElementById("On_Inf5");
let On_Inf5Node = document.createTextNode("");
	On_Inf5Element.appendChild(On_Inf5Node);
let On_Inf6Element = document.getElementById("On_Inf6");
let On_Inf6Node = document.createTextNode("");
	On_Inf6Element.appendChild(On_Inf6Node);
let On_Inf7Element = document.getElementById("On_Inf7");
let On_Inf7Node = document.createTextNode("");
	On_Inf7Element.appendChild(On_Inf7Node);
let On_Inf8Element = document.getElementById("On_Inf8");
let On_Inf8Node = document.createTextNode("");
	On_Inf8Element.appendChild(On_Inf8Node);
//
let Air_Pwr, Air_Spd, Air_Hdg, Air_Alt, Air_CfL;
let On_Paws, On_Inf0, On_Inf1, On_Inf2, On_Inf3, On_Inf4, On_Inf5, On_Inf6, On_Inf7, On_Inf8;

//= MAIN PROGRAMS ==============================================================

	loadAll();

//=	0 LOAD ALL =================================================================

function loadAll() {
	// Initialize Loading Screen
	WaitScreen();						// init loading screen
	loadSkyBox();
	loadObject();
	loadACMine();
}

//= WAIT SCREEN ================================================================

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 INITIALIZE ================//==============================================

function initAll() {
	initSkyBox();				// load skybox
	// Objects
	initAirObj();
	initGrdTxt();
	grd_.SPS.y = air_.MapSPS.y;
	grids = new GrdMap(grd_,scene);	// Init Grid Map
	grids.update(grd_);			// Mode Grid Map
	initRoads();
	makeTrees();
	initObject();				// Stationary Objects
	// Other
	initCamera(camera,cam_);	// position camera
	PawsText();
	AutoText();
	InfoText();
	// Show stats
	if (StatOn) {				// show stats
		StatOn = new Stats({
			precision: 3,
			horizontal: false
		});
		StatOn.init(renderer);
		StatOn.domElement.style.cssText = "position:absolute;top:75%;left:95%;";
		container.appendChild(StatOn.dom);
	}
	LodFlg = 1;
}

//= 2 RENDER ===================//==============================================

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;					// Stop the function here.
	}
	if (controls.isLocked === true && !LodSnd) loadSounds();
	if (!PawsOn && LodFlg && controls.isLocked === true) {
		moveCamera(camera,cam_);
		// Move Objects
		moveAirObj();			// Move aircaft
		// Move Grids
		grd_.SPS.copy(air_.MapSPS);	// Update Position
		grids.update(grd_);		// Mode Grid Map
		moveRoads();
		moveTrees();		
		moveObject();			// Move objects
		// Other
		moveSounds();
		prntHUDval();			// change HUD value
		if (StatOn) StatOn.update(); // update stats
	}
	if (controls.isLocked === false && LodSnd) {
		stopSounds();
		SndFlg = GunFlg = 0;
	}
	renderer.renderAsync(scene, camera); // ### WebGPU requires Async
	renderer.resolveTimestampsAsync(THREE.TimestampQuery.RENDER); // r173
}

//= SKYBOX =====================//==============================================

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	// LensFlare
	if (LnFFlg) {				// SunFlare	
		LF0Txt = txtrLoader.load(LF0Src);
		LF1Txt = txtrLoader.load(LF1Src);
	}
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);	
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(LF0Txt,256,0));
			LF.addElement(new LensflareElement(LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

//= GRID MAP ===================================================================

//= Make Grid Map Textures =====================================================

function initGrdTxt() {
	initGr0Txt();
	initGr1Txt();
	initGr6Txt();
}

function initGr0Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G0DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G0DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);	// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);	// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(GrdMul,GrdMul);
		DatTxt.anisotropy = maxAnisotropy;
		DatTxt.needsUpdate = true;		
		G0MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G0DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr1Siz,Gr1Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G1SPtr[n] = context.getImageData(0,0,Gr1Siz,Gr1Siz);				//
	}
}

function initGr1Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr1Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G0Indx.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G0Indx[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
				let ImgDat = G1SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G1DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G1DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;
		DatTxt.needsUpdate = true;
		G1MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G1DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr2Siz,Gr2Siz);
		G2SPtr[n] = context.getImageData(0,0,Gr2Siz,Gr2Siz);
	}
}

function initGr6Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr2Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G2SPtr[G1Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G2DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G2DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;
			DatTxt.needsUpdate = true;
			G2MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

//= Make Textures ==============================================================

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

/* Roads ==================================================================*/

function initRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

function initRoad2(Rod) {
	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(25*Ft2Mtr,Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz,25*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].renderOrder = 1;
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*AltAdj+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

// Move Roads
function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - grd_.SPS.z;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*AltAdj+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

//= TREES ======================================================================

//- Make Trees ------------------------------------------------------------------

function makeTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)		// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;	// ###
	txttre.needsUpdate = true;
	let mtltre = new THREE.MeshLambertNodeMaterial({colorNode: texture(txttre)});
	let mtltrn = new THREE.MeshLambertNodeMaterial({colorNode: color(0x161005)});
	let mtlshd = new THREE.MeshBasicNodeMaterial({colorNode: color(0x000000),transparent:true,opacity:0.5,depthWrite: false});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
		TreePZ[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
	}
	moveTrees();
}

//- Move Trees -----------------------------------------------------------------

function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*GrdSiz;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-air_.MapPos.x-GrdSiz/2;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		let z = air_.MapPos.z-TreePZ[n]-GrdSiz/2;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		let y = -grd_.SPS.y*AltAdj+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

/* Load and Move Fixed Objects ===============================================*/
/* These objects include the airfield, islands and hangar */

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = txtrLoader.load(ObjTxt[i]);
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gltfLoader.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(32000*Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

//= AIRPLANE ===================================================================

// Load Airplane
function loadACMine() {
	let fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {				// The OnLoad function
		gltf.scene.traverse(function (child) {	
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
//				child.geometry.computeVertexNormals();		// Better result?  Or remove smoothing?
			}
			if (child.name == "propeller") {
				child.castShadow = false;
				child.receiveShadow = false;
				child.renderOrder = 1;
			}		
		});
		ACMine = gltf.scene;
		ACMine.rotation.order = "YXZ";
		// Convert from feet to meters
		ACMine.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		/* Animations --------------------------------------------------------------- */
		// Propeller
		let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
		mxProp = new THREE.AnimationMixer(ACMine);
		let actun = mxProp.clipAction(clip);
		actun.play();
		if (mxProp) mxProp.setTime(spnprp/anmfps);
		// Rudder
		mxRudr = new THREE.AnimationMixer(ACMine);
		clip = THREE.AnimationClip.findByName(gltf.animations, "rudderAction");
		actun = mxRudr.clipAction(clip);
		actun.play();
		if (mxRudr) mxRudr.setTime(rudder/anmfps);
		// Elevator
		clip = THREE.AnimationClip.findByName(gltf.animations, "elevatorAction");
		mxElev = new THREE.AnimationMixer(ACMine);
		actun = mxElev.clipAction(clip);
		actun.play();
		if (mxElev) mxElev.setTime(elvatr/anmfps);
		// AileronTL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTLAction");
		mxAlTL = new THREE.AnimationMixer(ACMine);
		actun = mxAlTL .clipAction(clip);
		actun.play();
		if (mxAlTL) mxAlTL.setTime(aillft/anmfps);
		// AileronTR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTRAction");
		mxAlTR = new THREE.AnimationMixer(ACMine);
		actun = mxAlTR.clipAction(clip);
		actun.play();
		if (mxAlTR) mxAlTR.setTime(ailrgt/anmfps);
		// AileronBL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBLAction");
		mxAlBL = new THREE.AnimationMixer(ACMine);
		actun = mxAlBL .clipAction(clip);
		actun.play();
		if (mxAlBL) mxAlBL.setTime(aillft/anmfps);
		// AileronBR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBRAction");
		mxAlBR = new THREE.AnimationMixer(ACMine);
		actun = mxAlBR.clipAction(clip);
		actun.play();
		if (mxAlBR) mxAlBR.setTime(ailrgt/anmfps);
		//
		AirGrp.add(ACMine);
		// Initialize
		ACMine.visible = true;
	});
}

//= Init Airplane ==============//==============================================
// This section initializes starting location and variables before passing to Flight Module
function initAirObj() {
	//	Starting Location
	if (BegLoc == 0) { 			// Base
		air_.MapPos.y = air_.GrdZed;
		air_.GrdFlg = 1;
	}
	if (BegLoc == 1) { 			// Air
		PwrDif = 1000;			// This forces PwrPct to max
		air_.SpdKPH = 161;		// Speed (kph = 100 mph)
		air_.MapSPS.y = air_.MapPos.y = 200;
	}
	// Speed
	if (air_.SpdKPH) {
		air_.SpdMPS = air_.SpdKPH/3.6; // Speed - meters per second
		air_.SpdMPF = (air_.SpdKPH/3.6)*DLTime; // Speed - meters per frame
	}
	// Altitude
	if (air_.MapPos.y == 0) air_.GrdFlg = 1; // Altitude
	grd_.SPS.copy(air_.MapSPS); // Use to initialize objects
	// Flight
	flight = new Flight(air_);	// position airplane using air_.GrdZed
	air_.PYBmul.x = air_.PYBmul.x*MosMul.x;	// Pitch Adjustment
	air_.PYBmul.z = air_.PYBmul.x*MosMul.z;	// Bank Adjustment
	// If on Ground, Reaadjust
	grd_.SPS.y = air_.MapSPS.y; // Use to initialize objects (if on ground)
}

//= Move Airplane Model ========//==============================================
// This section processes Input before passing to Flight Module
// And manages Views and Animations
function moveAirObj() {
	// Compute Inputs ----------------------------------------------------------
	// Power Percent ...........................................................
	// Add Delay
	let gal = PwrDif * LagPwr.x; // Current input delayed
	let lag = LagPwr.z * LagPwr.y; // Released from Cumulator
	LagPwr.z = LagPwr.z + gal - lag; // Change in Cumulator
	PwrDif = PwrDif - gal + lag;
	// Input Engine Power
	air_.PwrPct = air_.PwrPct + PwrDif;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	PwrDif = 0;					// Reset
	// Coefficient of Lift .....................................................
	if (air_.AutoOn) {			// Autopilot
		air_.CfLDif = air_.InpKey.x;
		// Add Delay to Lift
		gal = air_.CfLDif * LagAtP.x; // Current input delayed
		lag = LagCfL.z * LagAtP.y; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	else {
		air_.CfLDif = (InpMos.y)*air_.PYBmul.x;	// Input Coefficient of Lift
		// Add Delay to Lift
		gal = air_.CfLDif * LagCfL.x; // Current input delayed
		lag = LagCfL.z * LagCfL.y; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	air_.CfLDif = air_.CfLDif - gal + lag;
	air_.CfLift = air_.CfLift + air_.CfLDif; // New Coefficient of Lift
	// Limits
	if (air_.CfLift > air_.CfLMax) air_.CfLift = air_.CfLMax;
	if (air_.CfLift < -air_.CfLMax) air_.CfLift = -air_.CfLMax;
	//anm_.stkpit = InpMos.y;	// Joystick pitch animation (NA)
	InpMos.y = 0;				// Reset
	// Coefficient of Lift - Flaps (NA)	
	//air_.CfFlap = air_.FlpCfL*(180-anm_.flppos)/180; // CfL - Flaps
	// Bank ....................................................................
	if (air_.AutoOn) {
		air_.RotDif.z = air_.InpKey.z;
		air_.OldRot.z = air_.OldRot.z + air_.RotDif.z*DegRad;
	}
	else {
		// Add Delay to Change in Bank Rate due to Mouse
		let BnkDif = InpMos.x * air_.PYBmul.z;
		gal = BnkDif * LagBnk.x;			// Current input delayed
		lag = LagBnk.z * LagBnk.y;			// Released from Cumulator
		LagBnk.z = LagBnk.z + gal - lag;	// Change in Cumulator
		BnkDif = BnkDif - gal + lag;
		air_.RotDif.z = air_.RotDif.z + BnkDif;	
		air_.RotDif.z = MaxVal(air_.RotDif.z,air_.BnkMax); // Max values
		if (air_.RotDif.z == air_.BnkMax && BnkDif < 0) air_.RotDif.z = BnkDif;
		if (air_.RotDif.z == -air_.BnkMax && BnkDif > 0) air_.RotDif.z = BnkDif;
		air_.RotDif.z = air_.RotDif.z; // Inputs are +/-
		air_.AGBank = air_.RotDif.z;
//		anm_.stkbnk = InpMos.x;	// Joystick bank animation
		InpMos.x = 0;			// Reset
	}
	// Input Yaw ...............................................................
	if (air_.SpdKPH < 1) air_.RotDif.y = 0;	// No Yaw if Speed < 1;
	// Input Brakes ............................................................
	air_.BrkVal = InpBrk;		// Brakes
	// Compute Rotation and Vectors --------------------------------------------
	flight.update();
	// View Keys ---------------------------------------------------------------
	if (!cam_.OrbFlg) {			// Only If Not Panning		
		// If No Keys Pressed, Set Default View
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg < 1)	{
			if (cam_.IntFlg) cam_.CamLLD.x = 0; // Internal view
			else cam_.CamLLD.x = -12.5; // External view
			cam_.CamLLD.y = 0;
		}
		// Down 45
		else if (D45flg) {
			cam_.CamLLD.x = 0;
			// Look Back
			if ((L90flg) && (L90flg) && (R90flg)) cam_.CamLLD.y = 180;
			// Look Back Left 90 + 45
			else if (L90flg) cam_.CamLLD.y = 135;
			// Look Back Right 270 - 45
			else if (R90flg) cam_.CamLLD.y = 225;
			// Look Down
			else {
				cam_.CamLLD.y = 0;
				cam_.CamLLD.x = 45;
			}
		}
		// Up 45
		else if (U45flg) {
			cam_.CamLLD.x = 315;
			if (!cam_.IntFlg && (air_.GrdFlg)) cam_.CamLLD.x = 0;
			// Look Up Left 45
			if (L45flg) cam_.CamLLD.y = 45;
			// Look Up Right 45
			else if (R45flg) cam_.CamLLD.y = 315;
			// Look Up Left 90
			else if (L90flg) cam_.CamLLD.y = 90;
			// Look Up Right 90
			else if (R90flg) cam_.CamLLD.y = 270;
			// Look Up
			else cam_.CamLLD.y = 0;
		}
		// Level
		else {
			cam_.CamLLD.x = 0;
			// Look Left 45
			if (L45flg) cam_.CamLLD.y = 45;
			// Look Right 45
			else if (R45flg) cam_.CamLLD.y = 315;
			// Look Left 90
			else if (L90flg) cam_.CamLLD.y = 90;
			// Look Right 90
			else if (R90flg) cam_.CamLLD.y = 270;
		}
	}
	// Animate -----------------------------------------------------------------	
	// Propeller
	let prpspd =  4 * (air_.PwrPct - 0.6);					// Range = -2.4 to + 1.6
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359;							// A complete circle
	// Rudder
	rudder = 180 + air_.RotDif.y * 100;
	// Elevator
	elvatr = 180 - 10*air_.ACPAdj-25;							// estimated adjustment
	if (elvatr < 150) elvatr = 150;							// Range = 00 to 60
	else if (elvatr > 209) elvatr = 209;
	// Ailerons
	let ailbnk = air_.RotDif.z;
	if (air_.GrFlag) ailbnk = AGBank;
	// Left
	aillft = 180 + ailbnk * 30;
	if (aillft < 151) aillft = 151;							// Range = 00 to 60
	else if (aillft > 209) aillft = 209;
	// Right
	ailrgt = 180 - ailbnk * 30;
	if (ailrgt < 151) ailrgt = 151;							// Range = 00 to 60
	else if (ailrgt > 209) ailrgt = 209;
	/* Animations (Display) ------------------------------------------------- */
	// Propeller
	if (mxProp) mxProp.setTime(spnprp/anmfps);
	// Rudder
	if (mxRudr) mxRudr.setTime(rudder/anmfps);
	// Elevator
	if (mxElev) mxElev.setTime(elvatr/anmfps);
	// Ailerons
	// Left
	if (mxAlTL) mxAlTL.setTime(aillft/anmfps);
	if (mxAlBL) mxAlBL.setTime(aillft/anmfps);
	// Rite
	if (mxAlTR) mxAlTR.setTime(ailrgt/anmfps);
	if (mxAlBR) mxAlBR.setTime(ailrgt/anmfps);
}

//= SOUNDS =====================//==============================================

//- Load and Initialize Sounds -------------------------------------------------
function loadSounds() {
	// Load Sounds .............................................................
	let audioLoader = new THREE.AudioLoader();
	let RefDst = 25;			// Reference distance for Positional Audio
	// My Engine
	let fname = ACPath + "sounds/" + EngSrc;
	audioLoader.load(fname, function(buffer) {
		EngSnd.setBuffer(buffer);
		EngSnd.setRefDistance(RefDst);
		EngSnd.setLoop(true);
		EngSnd.setVolume(0);
	});
	// My Guns
	fname = ACPath + "sounds/" + GunSrc;
	audioLoader.load(fname, function(buffer) {
		GunSnd.setBuffer(buffer);
		GunSnd.setRefDistance(RefDst);
		GunSnd.setLoop(true);
		GunSnd.setVolume(0);
	});
	// Init Sounds .............................................................
	let	listener = new THREE.AudioListener();
	camera.add(listener);
	//- My Engine and Prop
	EngSnd = new THREE.PositionalAudio(listener);
	EngMsh.add(EngSnd);			// Engine
	EngMsh.position.z = -5;
	air_.AirObj.add(EngMsh);
	GunSnd = new THREE.PositionalAudio(listener);
	GunMsh.add(GunSnd);			// Guns
	GunMsh.position.z = -5;
	air_.AirObj.add(GunMsh);
	//- Set Flag
	LodSnd = 1;
}

//- Change Sounds --------------------------------------------------------------
function moveSounds() {
	// My Engine
	EngSnd.setVolume(EngVol + air_.PwrPct * 0.05); // Range = .1 to .2
	EngSnd.setPlaybackRate(1 + air_.PwrPct * 0.5); // Range = 1 to 1.5
	// My Guns
	GunSnd.setVolume(GunVol);
}

//- Play Sounds ----------------------------------------------------------------
function playSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (!EngSnd.isPlaying) EngSnd.play();
	if (GunFlg && !GunSnd.isPlaying) GunSnd.play();
}

//- Stop Sounds ----------------------------------------------------------------
function stopSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (EngSnd.isPlaying) EngSnd.stop();
	if (GunSnd.isPlaying) GunSnd.stop();
}

//= CAMERA =====================//==============================================

//- Init Camera ----------------//----------------------------------------------
function initCamera(camera,cam_) {
	camera.position.z = -cam_.CamLLD.z;
	camera.rotation.y = cam_.CamAdj*DegRad;
	cam_.MshRot.add(camera);	// Attach to rotator
	// Common Changes
	cam_.CamLLD.copy(CamLLD[cam_.CamSel]);	// Restore Saved Values
	cam_.CamMMD.copy(CamMMD[cam_.CamSel]);	// In/Out - min, max, spd
	cam_.CamAdj = CamAdj[cam_.CamSel];		// Load Adjustment
	camera.rotation.y = cam_.CamAdj*DegRad;	// 180 = Looking in
	cam_.CamMMR.copy(CamMMR[cam_.CamSel]);	// Rotation min, max, spd
	cam_.Parent = CamPar[cam_.CamSel]		// Load New Parent
	cam_.Parent.add(cam_.MshRot);			// Attach Rotators
	cam_.IntFlg = CmIFlg[cam_.CamSel];		// 1 = cockpit
	cam_.CamLnk = CamLnk[cam_.CamSel];		// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);

}

//- Move Camera ----------------//----------------------------------------------
function moveCamera(camera,cam_) {
	// Move Camera In/Out
	camera.position.z = -cam_.CamLLD.z;
	// PointerLockControls
	if (cam_.OrbFlg) {
		cam_.CamLLD.x = cam_.CamLLD.x - InpMos.y * cam_.CamMMR.z; // Camera Position (Lat)
		cam_.CamLLD.x = MaxVal(cam_.CamLLD.x,cam_.CamMMR.x);
		cam_.CamLLD.y = Mod360(cam_.CamLLD.y + InpMos.x * cam_.CamMMR.z); // Camera Position (Lon)
		// Internal View
		if (cam_.IntFlg) {		// Range: 250 to 360/0 to 110
			if (cam_.CamLLD.y > 180 && cam_.CamLLD.y < (360-cam_.CamMMR.y)) cam_.CamLLD.y = (360-cam_.CamMMR.y);
			if (cam_.CamLLD.y < 180 && cam_.CamLLD.y > cam_.CamMMR.y) cam_.CamLLD.y = cam_.CamMMR.y;
		}
		// External View
		else {
			if (air_.GrdFlg && cam_.CamLLD.x > -12.5) cam_.CamLLD.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// Adjust Camera Rotators
	// In internal view, the camera is facing out - view matches rotation
	if (cam_.IntFlg) {
		cam_.MshRot.rotation.x = Mod360(cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(-cam_.CamLLD.y)*DegRad;
	}
	// In external view, the camera is facing in and the armature is pointing out:
	if (!cam_.IntFlg) {
		if (!cam_.OrbFlg && air_.GrdFlg) { // Air to Ground
			if (!CmGrdF) {		// if just landed
				CmLagX = CmAdjX; // All landings are smooth
//				if (CmLagX > 0.5) CmLagX = 0.5; // Make extreme landings more jarring
				CmGrdF = 1;
			}
			CmAdjX = CmLagX;	// From Landing Value to 0
		}	
		if (!cam_.OrbFlg && !air_.GrdFlg) { // Ground to Air
			if (CmGrdF) {		// if just took off
				CmLagX = CmMulX*air_.RotDif.x;
				CmGrdF = 0;
			}
			CmAdjX = (CmMulX*air_.RotDif.x)-CmLagX; // From 0 to Take-Off Value
		}
		if (CmLagX) {			// Reduce Lag
			CmLagX = 0.99*CmLagX; // Reduction in Adj/AdjOff
			if (Math.abs(CmLagX) < 0.1) CmLagX = 0;
		}
		camera.rotation.x = CmAdjX*DegRad; // + = up/airplane down
		cam_.MshRot.rotation.x = Mod360(-cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(180-cam_.CamLLD.y)*DegRad;
	}
}

//= OUTPUTS ====================//==============================================

//-	Print HUD Values -----------------------------------------------------------
function prntHUDval() {
//	Air_Pwr = air_.PwrPct;		// Throttle
	Air_Pwr = Throtl;			// Throttle Setting
	Air_PwrNode.nodeValue = Air_Pwr.toFixed(2);
	Air_Spd = air_.SpdKPH*Km2Mil; // Speed
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Alt = air_.MapPos.y*Mtr2Ft;	// Altitude
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);
	Air_Hdg = air_.AirRot.y;	// Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
	Air_CfL = air_.CfLift;		// Cf Lift
	Air_CfLNode.nodeValue = Air_CfL.toFixed(4);
}

//-	Pause Text -----------------------------------------------------------------
function PawsText(){
	if (PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//-	Autopilot Text -------------------------------------------------------------
function AutoText(){
	if (air_.AutoOn) Air_AtPNode.nodeValue = "Autopilot On";
	else {Air_AtPNode.nodeValue = "AutoP: Press A";}
}

//- Info Text ------------------------------------------------------------------
function InfoText() {
	if (!InfoOn) onInfo0();
	else if (InfoOn == 1) onInfo1();
	else if (InfoOn == 2) onInfo2();
}

//	Info Off
function onInfo0(){
	On_Inf0Node.nodeValue = "Info : Press I";
	On_Inf1Node.nodeValue = "";
	On_Inf2Node.nodeValue = "";
	On_Inf3Node.nodeValue = "";
	On_Inf4Node.nodeValue = "";
	On_Inf5Node.nodeValue = "";
	On_Inf6Node.nodeValue = "";
	On_Inf7Node.nodeValue = "";
	On_Inf8Node.nodeValue = "";
}

//	Info On - Page1
function onInfo1(){
	On_Inf0Node.nodeValue = "";
	On_Inf1Node.nodeValue = "CONTROLS";
	On_Inf2Node.nodeValue = "Use Mouse to change Pitch and Bank";
	On_Inf3Node.nodeValue = "AutoPilot: Use Arrow Keys to change Pitch and Bank";
	On_Inf4Node.nodeValue = "Use Mouse Buttons or Z/X Keys to change Yaw";
	On_Inf5Node.nodeValue = "Use Mouse Wheel or -/= Keys to change Throttle";
	On_Inf6Node.nodeValue = "Press S to toggle sound";
	On_Inf7Node.nodeValue = "Spacebar fires guns";
	On_Inf8Node.nodeValue = "";
}

//	Info On - Page2
function onInfo2(){
	On_Info0Node.nodeValue = "";
	On_Inf1Node.nodeValue = "VIEW KEYS";
	On_Inf2Node.nodeValue = "Hold Shift and use Mouse to pan around aircraft";
	On_Inf3Node.nodeValue = "Press DELETE or PAGE DOWN to look left/right";
	On_Inf4Node.nodeValue = "Press HOME and the above to look up";
	On_Inf5Node.nodeValue = "Press END and DELETE or PAGE DOWN to look back";
	On_Inf6Node.nodeValue = "Press all 3 keys to look back";
	On_Inf7Node.nodeValue = "";
	On_Inf8Node.nodeValue = "";
}

//= INPUTS =====================================================================
// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//- MOUSE ----------------------------------------------------------------------

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		air_.RotDif.y = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		air_.RotDif.y = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		air_.RotDif.y = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		air_.RotDif.y = 0;
	}
}

//- Mousewheel -----------------------------------------------------------------
function onDocumentMouseWheel(event) {
	event.preventDefault();
	PwrDif = - event.deltaY * PwrMul;	// Increment = 1%
	Throtl = Throtl + PwrDif;
	if (Throtl > 1) {
		Throtl = 1;
		PwrDif = 0;
	}
	if (Throtl < 0) {
		Throtl = 0;
		PwrDif = 0;
	}
	if (Throtl < .25) PwrDif = 0;	// Engine Cut-Off for Pup
}

//- KEYBOARD -------------------------------------------------------------------

//- Keyboard (Down) ------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_PwLU) PwrDif = 0.1;			// Power Up - keyboard left
	if (event.keyCode == K_PwLD) PwrDif = -0.1;			// Power Down - keyboard left
	if (event.keyCode == K_PwRU) PwrDif = 0.1;			// Power Up - keyboard right
	if (event.keyCode == K_PwRD) PwrDif = -0.1;			// Power Down - keyboard right
	if (event.keyCode == K_BnkL) air_.InpKey.z = -KeyVal.z;	// Bank Left - autopilot only
	if (event.keyCode == K_BnkR) air_.InpKey.z = KeyVal.z;	// Bank Right - autopilot only
	if (event.keyCode == K_PitU) air_.InpKey.x = KeyVal.x;	// Pitch Up - autopilot only
	if (event.keyCode == K_PitD) air_.InpKey.x = -KeyVal.x;	// Pitch Down - autopilot only
	if (event.keyCode == K_YwLL) air_.RotDif.y = -KeyVal.z; // YawL - keyboard left
	if (event.keyCode == K_YwLR) air_.RotDif.y = KeyVal.z;  // YawR - keyboard left
	if (event.keyCode == K_YwRL) air_.RotDif.y = -KeyVal.z; // YawL - keyboard right
	if (event.keyCode == K_YwRR) air_.RotDif.y = KeyVal.z;  // YawR - keyboard right
	if (event.keyCode == K_Brak) InpBrk = 0.01;			// Brakes
	// Views
	if (event.keyCode == K_VU45) D45flg = 1;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 1;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 1;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 1;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 1;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 1;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.OrbFlg = 1;		// Orbit
	// Guns
	if (event.keyCode == K_Guns) { // Guns
		if (!PawsOn) {
			if (SndFlg && !GunSnd.isPlaying) GunSnd.play();
		};
		GunFlg = 1;
	}
	// Toggle
	if (event.keyCode == K_Paws) toglPaws();			// Toggle Pause
	if (event.keyCode == K_Auto) toglAuto();			// Toggle AutoPilot
	if (event.keyCode == K_Info) toglInfo();			// Toggle Information
	if (event.keyCode == K_Soun) toglSoun();			// Toggle Sound
}

//-	Keyboard (Up) --------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_PwLU) PwrDif = 0;			// Power Up - keyboard left
	if (event.keyCode == K_PwLD) PwrDif = 0;			// Power Down - keyboard left
	if (event.keyCode == K_PwRU) PwrDif = 0;			// Power Up - keyboard right
	if (event.keyCode == K_PwRD) PwrDif = 0;			// Power Down - keyboard right
	if (event.keyCode == K_BnkL) air_.InpKey.z = 0;		// Bank Left - autopilot only
	if (event.keyCode == K_BnkR) air_.InpKey.z = 0;		// Bank Right - autopilot only
	if (event.keyCode == K_PitU) air_.InpKey.x = 0;		// Pitch Up - autopilot only
	if (event.keyCode == K_PitD) air_.InpKey.x = 0;		// Pitch Down - autopilot only
	if (event.keyCode == K_YwLL) air_.RotDif.y = 0;		// YawL - keyboard left
	if (event.keyCode == K_YwLR) air_.RotDif.y = 0;		// YawR - keyboard left
	if (event.keyCode == K_YwRL) air_.RotDif.y = 0;		// YawL - keyboard right
	if (event.keyCode == K_YwRR) air_.RotDif.y = 0;		// YawR - keyboard right
	if (event.keyCode == K_Brak) InpBrk = 0;			// Brakes
	// Views
	if (event.keyCode == K_VU45) D45flg = 0;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 0;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 0;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 0;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 0;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 0;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.OrbFlg = 0;		// Orbit
	if (event.keyCode == K_Guns) GunSnd.stop();			// Guns
}

//- Subroutines ----------------------------------------------------------------

//. Toggle Pause ...............................................................
function toglPaws() {
	PawsOn = 1 - PawsOn;
	if (PawsOn && SndFlg) {		//On to Off
		stopSounds();
	}
	if (!PawsOn && SndFlg) {	// Off to On
		playSounds();
	}
	PawsText();
}

//. Toggle AutoPilot ...........................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................................................................
function toglInfo() {
	InfoOn++
	if (InfoOn == 3) InfoOn = 0;
	InfoText();
}

//. Toggle Sound ...............................................................
function toglSoun() {
	if (!PawsOn) {
		SndFlg = 1 - SndFlg;
		if (SndFlg) {			// Off to On
			playSounds();
		}
		else {					// On to Off
			stopSounds();
		}
	}
}

//= WINDOW RESIZE ==============//==============================================
function onWindowResize() {
	CamAsp = window.innerWidth/window.innerHeight;
	camera.aspect = CamAsp;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>