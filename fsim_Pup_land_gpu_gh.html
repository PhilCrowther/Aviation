<!doctype html>
<html>

<!--
Copyright 2017-24, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 13 Sep 2024

A flight simulation of an animated airplane model over procedural land using
-->

<head>
<title>FSim: Pup Land GPU r168</title>
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Throttle: <span id="Air_Pwr"></span></div>
		<div>AirSpeed: <span id="Air_Spd"></span> mph</div>
		<div>Altitude: <span id="Air_Alt"></span> ft</div>
		<div>Heading : <span id="Air_Hdg"></span> deg</div>
		<div>CoefLift: <span id="Air_CfL"></span></div>
	</div>
	<div class="overlay2">
		<div><span id="On_Paws"></span></div>
		<div><span id="Air_AtP"></span></div>
		<div><span id="On_Info01"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
		<div><span id="On_Info05"></span></div>
		<div><span id="On_Info06"></span></div>
		<div><span id="On_Info07"></span></div>
		<div><span id="On_Info08"></span></div>
		<div><span id="On_Info09"></span></div>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script src="https://PhilCrowther.github.io/Aviation/models/pup/data/data.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.168.0/build/three.webgpu.js",
			"three/tsl": "https://unpkg.com/three@0.168.0/build/three.webgpu.js",
			"three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/",
			"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.8/dist/main.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {color,float,texture,MeshLambertNodeMaterial,MeshBasicNodeMaterial,SpriteNodeMaterial} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import Stats from "stats-gl";
// Special Modules
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdMap3a.js";
import {Flight,Mod360,PoM360,MaxVal,rotLLD,makMsh} from "https://PhilCrowther.github.io/Aviation/jsm/Flight4.js";

//= INPUTS =====================================================================
//- CAMERA ---------------------------------------------------------------------
let CamSel = 0;						// Camera Seletion (0 = External; 1 = Internal)
//- AIRPLANE: Start -----------------------------------------------------------
let USorSI = "US";					// Units of Measurement (US or SI)
let BegPwr = 0;						// Initial Power Percent
let BegSpd = 100;					// Speed (mph)
let BegPos = new THREE.Vector3(0,2000,0); // Position (ft)
//- AIRPLANE: Flight -----------------------------------------------------------
let PYBmul = new THREE.Vector3(0.004,1.0,0.001); // Basic airplane values
let	MosMul = new THREE.Vector3(1.0,1.0,1.0); // Adjustment to PYBmul (default = 1)
let PwrMul = 0.0001;				// Power % Input - Mouse Multiplier
let PwrDif = 0;						// Power % Input - Value
let InpBrk = 0;						// Brakes
//- Mouse Delays ...............................................................
//- (x = diverted, y = released, z = stored)
let PwrMsD = new THREE.Vector3(1-1/30,1/15,0);	// Power
let CfLMsD = new THREE.Vector3(1-1/30,1/15,0);	// CfL
let CfLApD = new THREE.Vector2(0.967,0.099);	// CfL - Autopilot
let BnkMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- POINTER LOCK CONTROLS ------------------------------------------------------
let InpMos = new THREE.Vector2();	// Inputs - Mouse
let _changeEvent = {type: 'change'};
let _lockEvent = {type: 'lock'};
let _unlockEvent = {type: 'unlock'};
//- Key Vaulues (XZ = Autopilot Pitch/Bank; Y = Yaw Mouse Button or Key) .......
let KeyVal = new THREE.Vector3(1,.05,1);	// Key Values (Yaw = turn rate in 15 deg bank)
//- Flags ----------------------------------------------------------------------
let PawsOn = 0;						// Pause
let InfoOn = 0;						// Info
let LodFlg = 0;
let SndFlg = 0;
let StatOn = 1;						// Stats ((0 = off, 1 = on)

//= CONSTANTS ==================================================================
//	Time
let	DLTime = 1/60;					// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;			//
//	Conversions
var DegRad = Math.PI/180;			// Convert Degrees to Radians
let RadDeg = 180/Math.PI;	// Convert Radians to Degrees
let Ft2Mtr = 0.3048;				// Convert Feet to Meters
let Mtr2Ft = 1/0.3048;
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//	Default Constants
let	GrvMPS = 9.80665; 				// Gravity (mps)
//	Starting Constants per frame
let GrvDLT = GrvMPS*DLTim2;
//	Starting Air Density				
let	AirDSL = 1.225;					// Density - Sea Level (kg/m3)
//- Convert Starting Values
if (USorSI = "US") {
	BegSpd = BegSpd*Mil2Km;
	BegPos.multiplyScalar(Ft2Mtr);
}
let BegTmp = 288.15;				// K = 59F

//= SUN VALUES =================================================================
let SunCol = 0xffffff;				// Sun
let SunInt = 3;						// Default intensity of light/sun
//- Rotation and Position (fixed)
let SunLat = 23;					// Direction - Vert (+/- 90)
let SunLon = 312;					// Direction - Horz (0->360)
let SunDst = 10000;					// Distance (for shadows and lensflare)
//- New
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);
//	Shadows
let ShdBox = 25;					// Size of shadow box
let ShdDst = 5000;					// [feet] for shadow

//= STANDARD SETUP =============================================================
//- Display
let scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
let renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);					// ### nodes
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
//let maxAnisotropy = renderer.capabilities.getMaxAnisotropy();	// ### Err
let	maxAnisotropy = 16;	// ### WebgGPU
//- Light
let ambLight = new THREE.AmbientLight(SunCol,0.2);
	scene.add(ambLight);
let sunLight = new THREE.DirectionalLight(SunCol,SunInt);
	sunLight.position.copy(SunPos);			// ### SunDst
	sunLight.castShadow = true;
	sunLight.shadow.camera.left = -ShdBox;
	sunLight.shadow.camera.right = ShdBox;
	sunLight.shadow.camera.top = ShdBox;
	sunLight.shadow.camera.bottom = -ShdBox;
	sunLight.shadow.camera.near = SunDst-ShdBox; // ### SunDst	
	sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox; // ### SunDst
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.bias = - 0.0005;		// ### WebGPU
	scene.add(sunLight);
//- Sounds
let	listener = new THREE.AudioListener();
let sound1 = new THREE.PositionalAudio(listener);
let sound3 = new THREE.PositionalAudio(listener);
let sound4 = new THREE.PositionalAudio(listener);
let EngObj = new THREE.Object3D();	// Aircraft Engine
	EngObj.add(sound1);				// Engine
	EngObj.add(sound3);				// Guns
	EngObj.position.z = -5;
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
let camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener('mousewheel', onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
let audioLoader = new THREE.AudioLoader(loadingManager);
//- Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= SKYBOX =====================================================================
let SBxSrc = "https://threejs.org/examples/textures/cube/skyboxsun25deg/";

//= FOG ========================================================================
let FogCol = 0xbab4a6;				// Sky (for Fog only)

//=	SUNFLARE ===================================================================
let SnFFlg = 1;						// 1 = SunFlare On
//- Textures
let SnFhex = "https://PhilCrowther.github.io/Aviation/textures/fx/hex.png";
//- Sprites
let SnFsrc = [SnFhex,SnFhex];		// Spreit Texture Source
let SnFsiz = [300,800];				// Sprite Size
	SnFsiz = [300,1500];			// Sprite Size
let SnFopa = [0.1,0.025];			// Sprite Opacity
	SnFopa = [0.25,0.025];			// Sprite Opacity
let SnFmlt = [0.3,-0.4];			// Offset Multiplier (1 = centered on Sun)
let SnFdst = SunDst;				// Distance (default = 10000)
//- Parameters
let SnF_ = {
		//- Sprites
		num: 2,						// Number of Sprites
		spr: [],					// Sprite Address
		mlt: SnFmlt,				// Offset Multiplier
		//- Rotators
		msh: [],					// Rotators
		par: 0,						// Parent (Camera Clone) [OrbCon Only]
		//- Heading Offset
		cam: new THREE.Vector3(),	// Camera Direction
		sun: new THREE.Vector2(SunLat,SunLon),	// Sun Position (fixed)
		off: new THREE.Vector2(),	// Sun Offset (lat/lon) [shared]
		asp: 0,						// Camera Aspect
	}

//= GEOMAT =====================================================================
//= Textures Data ==============================================================
//- All textures are 512X512
let dqSize = 1024;
let dqArea = dqSize*dqSize;
let dtSize = 512;
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;						// Total Textures
//- Canvas
let ImgSiz = 1024;					// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext('2d',{willReadFrequently: true});
//= Grid 4 Data ================================================================
//- 1/4 section squares (1/2 mile X 1/2 mile)
//- Variables
let GrdMul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];
//- Colors
let GrdDrt = "#1c160e";				// Color of underlying dirt (affects brightness)
let drtclr = [0x8e6d3d,0x47361e];	// Dirt
let pstclr = [0x00b000,0x005000];	// Pasture
let cvrclr = [0x75b24c,0x466b2d];	// Green
let whtclr = [0xfbf4e5,0xeabb63];	// Wheat
let bnsclr = [0xacd193,0x5d8e3d];	// Beans
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//	[https://icolorpalette.com/color/dirt-brown
let count0;
//= MATERIALS ==================================================================
//= Grid 0 Data ================================================================
//- Image Data
let G0DPtr = [];
	G0DPtr[txtTot-1] = 0;
//- Materials
let G0MPtr = [];
	G0MPtr[txtTot-1] = 0;
// Patterns for Grid 5 3X3 Textures
// Also used to draw Grid 4 textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G0Id00 = [4,3,5,4,3,0,5,2,1];
let G0Id01 = [3,0,4,1,2,4,5,3,5];
let G0Id02 = [5,1,3,4,5,0,2,4,3];
let G0Id03 = [2,4,1,3,5,3,5,0,4];
let G0Id04 = [5,1,5,0,3,4,2,4,3];
let G0Id05 = [3,0,5,3,4,5,1,2,4];
let G0Id06 = [2,0,3,5,3,1,4,4,5];
let G0Id07 = [1,5,4,3,5,0,2,4,3];
let G0Id08 = [2,3,0,5,3,1,4,5,4];
let G0Id09 = [0,2,5,3,4,3,5,1,4];	// 1 = airport
let G0Id10 = [4,3,5,4,5,2,1,3,0];
let G0Id11 = [4,5,3,1,0,4,3,5,2];
let G0Id12 = [3,1,2,4,5,3,5,0,4];
let G0Id13 = [0,5,3,1,4,2,4,3,5];
let G0Id14 = [1,4,2,5,3,0,4,5,3];
let G0Id15 = [4,1,5,0,3,4,3,5,2];
let G0Indx = [
		G0Id00,G0Id01,G0Id02,G0Id03,G0Id04,G0Id05,G0Id06,G0Id07,G0Id08,G0Id09,
		G0Id10,G0Id11,G0Id12,G0Id13,G0Id14,G0Id15
	];
//= Grid 1 Data ================================================================
let Gr1Mul = 3;
let Gr1Siz = Math.floor(dtSize/Gr1Mul);
// Image Data (Source Data - Resized)
let G1SPtr = [];
	G1SPtr[G0Indx.length-1] = 0;
// Image Data
let G1DPtr = [];
	G1DPtr[G0Indx.length-1] = 0;
// Materials
let G1MPtr = [];
	G1MPtr[G1DPtr.length-1] = 0;
// Index to Display of G1 Textures by Type
// Used by G0 to position squares
// And by G1 to create textures
let G1Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,		//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4, 9,13, 8,12, 7,		// 9 = over
		 4, 7,15,12, 3,11, 9,13, 4,		// 3 = Airport
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];
//= Grid 2 Data ================================================================
let Gr2Mul = 3;
let Gr2Siz = Math.floor(dtSize/Gr2Mul);
// Image Data (Source Data - Resized)
let G2SPtr = [0,0,0,0,0,0,0,0,0];
// Image Data
let G2DPtr = [0,0,0,0,0,0,0,0,0];
// Materials
let G2MPtr = [0,0,0,0,0,0,0,0,0];

//= GRID MODULE ================================================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let GrdSiz = 804.67;				// Size of Smallest Grid Square (1/4 section = 1/2 mile)
let grids = 0;
let grd_ = {
		SPS: new THREE.Vector3 (),	// MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,					// Squares in each of first 2 grids
		Siz: GrdSiz,				// Size of smallest square
		Stp: 3,						// Squares in each of first 2 grids
		Grx: [],					// Index of Grids (0-2)
		Idx: [G0Indx,G1Indx],		// Index to Patterns
		Mat: [G0MPtr,G1MPtr,G2MPtr], // Materials
	}
/* = Roads ===================================================================*/
//- North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}
//- East West
let Rod2 = {
		Typ:	2,
		RCs:	21,					// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,			// Size of square
		Stp:	1,					// Squares to flip
		RCi:	0,					// Rows and Columns Index (computed)
		MZV:	[0],				// Ground Z Value
		MXV:	[0],				// Ground X Value
		Nor:	0,					// Max North Square (updated)
		Est:	0,					// Max East Square (updated)
		Num:	0,					// Size of array (computed)
		Ptr:	[0],				// Ground Address
		Txt:	0,					// Texture Address
		Shd:	1					// Shadow enabled
	}
//- Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//-	Tones of Dirt Brown Color | #836539 Monochromatic Color
//-	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);
//= Trees ======================================================================
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//= Objects ====================================================================
//- Distances in Meters
let ObjNum = 2;						// number of objects
let ObjTyp = [0];					// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];					// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];					// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];					// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];					// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];					// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];					// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];					// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
//- Hangars
	ObjTyp[ObjIdx] = 0;				// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 1000;			// [m]
	ObjMPY[ObjIdx] = 0.3048;		// [m] 1 ft
	ObjMPZ[ObjIdx] = 1524;			// [m] 5000 ft
	ObjIdx = ObjIdx + 1;
//- Giaros Island
	ObjTyp[ObjIdx] = 1;				// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/models/scenery/textures/giaros.png";
	ObjMPX[ObjIdx] = -1609.344;		// [m] 1 mile
	ObjMPY[ObjIdx] = 2*Ft2Mtr;		// [m] 2 ft
	ObjMPZ[ObjIdx] = 8046.72;		// [m] 5 miles

//= MY AIRPLANE ================================================================
//	Airplane Data
let	flight = 0;
let air_ = {
		// General Variables
		DLTime: DLTime,				// Seconds per frame (can vary)
		GrvMPS: GrvMPS,				// Gravity (ups)
		AirDSL: AirDSL,				// Air Density (varies with altitude)
		// Designators
		AirDat: data_,					// Aircraft Type: 1 = Pup
		// Airplane Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Vector3(0,0,0),	// Rotation (in degrees)
		AirObj: makMsh(),			// Airplane Object 
		AirPBY: makMsh(),			// Changes in radians
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(0,0,0),	// Change
		// Airplane Speed
		SpdKPH: BegSpd,				// Speed in KPH
		SpdMPS: BegSpd/3.6,			// Speed - meters per second
		SpdMPF: (BegSpd/3.6)*DLTime,	// Speed - meters per frame	
		// Airplane Map Speed and Position
		MapSpd: new THREE.Vector3(), // Map Speed (meters)
		MapPos: new THREE.Vector3().copy(BegPos), // Map Position (meters)
		MapSPS: new THREE.Vector3(0,BegPos.y,0), // MSX, MPY, MSZ (meters)
		// Variables Obtained from Flight
		PwrPct: BegPwr,				// % of Primary Power (0 to 1) (Main and Flight)
		SupPct: 0,					// Percent of Supplemental Power (War Enmergency or Afterburner)
		CfLift: 0,					// Coefficient of Lift (user input) - determines lift
		CfFlap: 0,					// Coefficient of Lift due to flaps (user input)
		FlpPct: 0,					// Percent of Flaps
		LngPct: 0,					// Percent of Landing Gear
		BrkPct: 0,					// Percent of Air Brakes
		SplPct: 0,					// Percent of Spoiler
		AGBank: 0,					// Aileron Bank on Ground
		BrkVal: 0,					// Brakes
		GrdZed: 0,					// Ground level (default)
		GrdFlg: 0,					// Ground Flag (1 = on ground)
		ACPAdj: 0,					// Airplane pitch adjustment
		MovFlg: 0,					// If Sitting on a Moving Object
		// Values for the Selected Airplane Type (obtained from Flight)
		CfLMax: 0,					// Maximum Coefficient of Lift
		FlpCfL: 0,					// Max Flap Cfl (0.2*CfLMax)
		ACMass: 0,					// Airplane Mass
		Weight: 0,					// Used by autopilots
		PYBmul: new THREE.Vector3().copy(PYBmul), // Airplane Pitch/Yaw/Bank Multiplier
		BnkMax: 0,					// Maximum bank rate
		// AutoPilot - Additional Variables
		AutoOn: 0,					// Autopilot Flag
		InpKey: new THREE.Vector3(), // Inputs - Keys (replace InpKey)
		OldRot: new THREE.Vector3(), // Old Rotation (radians)
		CfLDif: 0,					// Change in CfL
		MaxBnk: 0,					// Max Bank (display only)
		HdgDif: 0,					// Horizontal Turn Rate (display only)
		// Air Density and IAS Comps
		BegTmp: BegTmp,				// Beginning Sea Level Temperature (K)
		BegPrs: 1013.25,			// Beginning Sea Level Air Pressure (mB) - not used
		SpdIAS: 0					// Indicated Airspeed
	}
// 
//- Adjustments
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY);	// PBY includes air_.
	scene.add(air_.AirObj);
let AirGrp = new THREE.Group();		// To hold ACMine and VCMine
	air_.AirPBY.add(AirGrp);
let ACMine = 0;						// My Aircraft (loaded)
//- Load Models and Animations -------------------------------------------------
//-	File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/pup/";	// Used to load models and sounds
//-	Animation Mixers - External Model
let ACFile = "pup_flyt_npa.glb";	// Name of aircraft model file (rotated blender file)
//- Aircraft Animations
let anmfps = 24;					// Blender FPS
let aoarng = 20;					// AoA range (model)
//- Mixers
var mxProp = 0;						// Propeller
var mxRudr = 0;						// Rudder
var mxElev = 0;						// Elevator
var mxAlTL = 0;						// AileronTL
var mxAlTR = 0;						// AileronTR
var mxAlBL = 0;						// AileronTL
var mxAlBR = 0;						// AileronTR
//- All range from 0 to 360 with center at 180
var elvatr = 180;					// Elevator 	degrees = +/- 360
var rudder = 180;					// Rudder 		degrees = +/- 360
var aillft = 180;					// AileronL 	degrees = +/- 360
var ailrgt = 180;					// AileronR 	degrees = +/- 360
var rotaoa = 180;					// AoA 			degrees = +/- 15
var spnprp = 180;					// Taildrag 	degrees = 0 to 360
//- Sounds
let acsnd1 = "pup.mp3";				// File (my engine)
let acvol1 = 0.1;					// Volume
let acsnd3 = "pup_gun.mp3";			// File (my guns)
let acvol3 = 0.5;					// Volume
let xpsnd1 = "fm2_prop.wav";		// File (xp prop)
let xpvol1 = 1.0;					// Volume
let RefDst = 25;					// Reference distance for Positional Sound

//= DEFAULT KEY BINDINGS =======================================================
let K_BnkL = 37;	// Bank Left (left arrow)
let K_BnkR = 39;	// Bank Right (right arrow)
let K_PitU = 40;	// Pitch up (down arrow)
let K_PitD = 38;	// Pitch down (up arrow)
let K_Brak = 66;	// Brakes (b)
let K_Guns = 32;	// Guns (spacebar)
let K_VU45 = 36;	// View Up (alone or modifier)
let K_VD45 = 35;	// View Down (alone or modifier)
let K_VL45 = 33;	// Left 45 degrees
let K_VR45 = 45;	// Right 45 degrees
let K_VL90 = 34;	// Left 90 degrees
let K_VR90 = 46;	// Right 90 degrees
let K_Look = 16;	// Pan (shift)
let K_Soun = 83;	// Toggle sound (s)
let K_Paws = 80;	// Pause (p)
let K_Auto = 65;	// Autopilot (a)
let K_Info = 73;	// Info (i)

//=	VIEW KEYS ==================================================================
let U45flg = 0;		// Up 45 degrees
let D45flg = 0;		// Down 45 degrees
let	L45flg = 0;		// Left 45 degrees
let R45flg = 0;		// Right 45 degrees
let L90flg = 0;		// Left 90 degrees
let R90flg = 0;		// Right 90 degrees

//= POINTER LOCK CONTROL =======================================================

class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement, plc_) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error('THREE.PointerLockControls: Unable to use Pointer Lock API');
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener('mousemove', onMouseMove);
			scope.domElement.ownerDocument.addEventListener('pointerlockchange', onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener('pointerlockerror', onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);
			scope.domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//- Setup ----------------------------------------------------------------------
let controls = new PointerLockControls(camera, renderer.domElement,air_);
let blocker = document.getElementById('blocker');
let instructions = document.getElementById('instructions');
	instructions.addEventListener('click', function () {controls.lock();});
	controls.addEventListener('lock', function () {
		instructions.style.display = 'none';
		blocker.style.display = 'none';
	});
	controls.addEventListener( 'unlock', function () {
		blocker.style.display = 'block';
		instructions.style.display = '';
	});

//= CAMERA =====================================================================
//- Create Cockpit Attach Point
let	CamPVC = makMsh();
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirPBY.add(CamPVC); 		// Attach CamPVC to AirPBY (### not AirObj)
//- Camera Inputs (External Camera linked to air_.AirPBY; 1 Internal Camera Linked to cam_.PVC)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];				// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CamFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
//- Shared Variables
let cam_ = {
		sel: CamSel,			// View Selector (0 = External, 1 = Internal)
		num: CamNum,
		pan: 0,					// Pan Flag (1 = panning)
		// Camera
		lld: new THREE.Vector3().copy(CamLLD[CamSel]),	// cam_.rot Lat, Lon, Dst
		llz: new THREE.Vector3(), // External LLZ
		adj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		mmd: new THREE.Vector3().copy(CamMMD[CamSel]),	// In/Out - min,max,spd
		// Rotator
		rot: makMsh(),			// Camera Rotator
		mmr: new THREE.Vector3().copy(CamMMR[CamSel]),	// Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		par: CamPar[CamSel],	// Center of Rotation	
		flg: CamFlg[CamSel],	// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		lnk: CamLnk[CamSel],
		qat: new THREE.Quaternion(),
		obj: makMsh(),
		deg: makMsh()
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.rot.rotation.order = "YXZ";
	cam_.obj.rotation.order = "YXZ";
	cam_.deg.rotation.order = "YXZ";
	cam_.par.add(cam_.rot);			// Attach Rotator
	cam_.obj.add(cam_.deg);

//= HTML OVERLAY TEXT ==========================================================
let Air_PwrElement = document.getElementById("Air_Pwr");
let Air_PwrNode = document.createTextNode("");
	Air_PwrElement.appendChild(Air_PwrNode);
let Air_SpdElement = document.getElementById("Air_Spd");
let Air_SpdNode = document.createTextNode("");
	Air_SpdElement.appendChild(Air_SpdNode);
let Air_HdgElement = document.getElementById("Air_Hdg");
let Air_HdgNode = document.createTextNode("");
	Air_HdgElement.appendChild(Air_HdgNode);
let Air_AltElement = document.getElementById("Air_Alt");
let Air_AltNode = document.createTextNode("");
	Air_AltElement.appendChild(Air_AltNode);
let Air_CfLElement = document.getElementById("Air_CfL");
let Air_CfLNode = document.createTextNode("");
	Air_CfLElement.appendChild(Air_CfLNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
	On_PawsElement.appendChild(On_PawsNode);
let Air_AtPElement = document.getElementById("Air_AtP");	// Autopilot
let Air_AtPNode = document.createTextNode("");
	Air_AtPElement.appendChild(Air_AtPNode);
let On_Info01Element = document.getElementById("On_Info01");
let On_Info01Node = document.createTextNode("");
	On_Info01Element.appendChild(On_Info01Node);
let On_Info02Element = document.getElementById("On_Info02");
let On_Info02Node = document.createTextNode("");
	On_Info02Element.appendChild(On_Info02Node);
let On_Info03Element = document.getElementById("On_Info03");
let On_Info03Node = document.createTextNode("");
	On_Info03Element.appendChild(On_Info03Node);
let On_Info04Element = document.getElementById("On_Info04");
let On_Info04Node = document.createTextNode("");
	On_Info04Element.appendChild(On_Info04Node);
let On_Info05Element = document.getElementById("On_Info05");
let On_Info05Node = document.createTextNode("");
	On_Info05Element.appendChild(On_Info05Node);
let On_Info06Element = document.getElementById("On_Info06");
let On_Info06Node = document.createTextNode("");
	On_Info06Element.appendChild(On_Info06Node);
let On_Info07Element = document.getElementById("On_Info07");
let On_Info07Node = document.createTextNode("");
	On_Info07Element.appendChild(On_Info07Node);
let On_Info08Element = document.getElementById("On_Info08");
let On_Info08Node = document.createTextNode("");
	On_Info08Element.appendChild(On_Info08Node);
let On_Info09Element = document.getElementById("On_Info09");
let On_Info09Node = document.createTextNode("");
	On_Info09Element.appendChild(On_Info09Node);
//
let Air_Pwr, Air_Spd, Air_Hdg, Air_Alt, Air_CfL;
let On_Paws, On_Info01, On_Info02, On_Info03, On_Info04, On_Info05, On_Info06, On_Info07, On_Info08;

//= MAIN PROGRAMS ==============================================================

	loadAll();

//=	0 LOAD ALL =================================================================

function loadAll() {
	// Initialize Loading Screen
	WaitScreen();						// init loading screen
	loadSkyBox();
	if (SnFFlg) loadSunFlr(SnF_);	// SunFlare
	loadObject();
	loadACMine();
}

//= WAIT SCREEN ================================================================

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 INITIALIZE ================//==============================================

function initAll() {
	initSkyBox();						// load skybox
	if (SnFFlg) initSunFlr(scene,camera,SnF_);	// SunFlare
	flight = new Flight(air_);			// position airplane using air_.GrdZed
//	flight.update;
	air_.PYBmul.x = air_.PYBmul.x*MosMul.x;	// Pitch Adjustment
	air_.PYBmul.z = air_.PYBmul.x*MosMul.z;	// Bank Adjustment
	initGrdTxt();
	grd_.SPS.y = air_.MapSPS.y;
	grids = new GrdMap(grd_,scene);		// Init Grid Map
	grids.update(grd_);					// Mode Grid Map
	initRoads();
//	makeTrees();
	initObject();						// Stationary Objects
	// Other
	initCamera(camera,cam_);			// position camera
	PawsText();
	AutoText();
	InfoText();
	// Show stats
	if (StatOn) {						// show stats
		StatOn = new Stats({
			precision: 3,
			horizontal: false
		});
		StatOn.init(renderer);
		StatOn.domElement.style.cssText = "position:absolute;top:75%;left:95%;";
		container.appendChild(StatOn.dom);
	}
	LodFlg = 1;
}

//= 2 RENDER ===================//==============================================

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;												// Stop the function here.
	}
	if (PawsOn == 0 && LodFlg > 0 && controls.isLocked === true) {
		moveCamera(camera,cam_);
		if (SnFFlg) {			// SunFlare
			SnF_.asp = CamAsp;	// Camera Aspect
			SnF_.cam.copy(cam_.llz); // Camera LLZ		
			moveSunFlr(SnF_);	// SunFlare
		}
		// Move Objects
		moveAirObj();					// Move aircaft
		// Move Grids
		grd_.SPS.copy(air_.MapSPS);		// Update Position
		grids.update(grd_);				// Mode Grid Map
		moveRoads();
//		moveTrees();		
		moveObject();					// Move objects
		moveSounds();
		prntHUDval();					// change HUD value
		if (StatOn) StatOn.update();	// update stats
	}
	renderer.renderAsync(scene, camera);
}

//= SKYBOX =====================================================================

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace;	// ### r152
	scene.background = envMap;
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
}

//= SUNFLARE ===================================================================

function loadSunFlr(SnF_) {
	let SnFtxt,SnFmat;
	for (let i = 0; i < SnF_.num; i++) {
		SnFtxt = txtrLoader.load(SnFsrc[i]);
		SnFmat = new THREE.SpriteNodeMaterial({
			colorNode: color(0xffffff),
			colorNode: texture(SnFtxt),
			transparent:true,
			opacityNode: SnFopa[i], // Opacity
			depthTest:false,
			depthWrite:false
		});
		SnF_.spr[i] = new THREE.Sprite(SnFmat);
		SnF_.spr[i].scale.set(SnFsiz[i],SnFsiz[i],1);
		SnF_.spr[i].position.z = -SnFdst;		// Make Negative
	}
}

function initSunFlr(scene,camera,SnF_) {
	SnF_.par = camera;
	// Get Sprites
	for (let i = 0; i < SnF_.num; i++) {
		// Sprite Rotators
		SnF_.msh[i] = makMsh();			// Make Rotators
		SnF_.msh[i].add(SnF_.spr[i]);	// Add Sprite to Rotator
		scene.add(SnF_.msh[i]);			// Make Visible
		SnF_.par.add(SnF_.msh[i]);		// Add to Parent
	}
};

function moveSunFlr(SnF_) {
	// Get Difference Between Sun and Camera Directions
	SnF_.off.x = SnF_.sun.x-SnF_.cam.x;				// Camera Lat Offset
	SnF_.off.y = PoM360(Mod360(SnF_.sun.y-SnF_.cam.y));	// Camera Lon Offset
	if (SnF_.cam.z) {	// If the Camera is banked
		let radius = Math.sqrt(SnF_.off.x*SnF_.off.x+SnF_.off.y*SnF_.off.y);
		let angle0 = Mod360(Math.atan2(SnF_.off.y,SnF_.off.x)*RadDeg);	// Angle to Sun
		let angle1 = Mod360(angle0-SnF_.cam.z);			// Subtract Bank
		SnF_.off.x = radius*Math.cos(angle1*DegRad);	// Recompute offsets
		SnF_.off.y = radius*Math.sin(angle1*DegRad);
	}
	// Test Visibility
	let VisFlg = 0;
	if (Math.abs(SnF_.off.x) > 45 || Math.abs(SnF_.off.y) > 45*SnF_.asp) VisFlg = 1;
	if (VisFlg || cam_.sel == 1) {
		for (let i = 0; i < SnF_.num; i++) {
			SnF_.spr[i].visible = false;	
		}
	}
	// If visible, Compute Displacement
	else {
		for (let i = 0; i < SnF_.num; i++) {
			SnF_.spr[i].visible = true;
			SnF_.msh[i].rotation.x = SnF_.off.x*SnF_.mlt[i]*DegRad;
			SnF_.msh[i].rotation.y = -SnF_.off.y*SnF_.mlt[i]*DegRad;
		}
	}
};

//= GRID MAP ===================================================================

//= Make Grid Map Textures =====================================================

function initGrdTxt() {
	initGr0Txt();
	initGr1Txt();
	initGr6Txt();
}

function initGr0Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G0DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G0DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);	// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);	// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(GrdMul,GrdMul);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		G0MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});		
		G0MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G0DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr1Siz,Gr1Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G1SPtr[n] = context.getImageData(0,0,Gr1Siz,Gr1Siz);				//
	}
}

function initGr1Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr1Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G0Indx.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G0Indx[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
//				let ImgDat = G0DPtr[stIndx[idx]];
				let ImgDat = G1SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G1DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G1DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
//		G1MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});
		G1MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G1DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr2Siz,Gr2Siz);
		G2SPtr[n] = context.getImageData(0,0,Gr2Siz,Gr2Siz);
	}
}

function initGr6Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr2Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G2SPtr[G1Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G2DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G2DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;		// ###
			DatTxt.needsUpdate = true;
//			G2MPtr[n] = new THREE.MeshLambertMaterial({map: DatTxt});
			G2MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

//= Make Textures ==============================================================

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

/* Roads ==================================================================*/

function initRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

function initRoad2(Rod) {

	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(25*Ft2Mtr,Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz,25*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].renderOrder = 1;
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*.99+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

// Move Roads
function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - grd_.SPS.z;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*.99+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

//= TREES ======================================================================

//- Make Trees ------------------------------------------------------------------

function makeTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)		// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;	// ###
	txttre.needsUpdate = true;
	let mtltre = new THREE.MeshLambertNodeMaterial({colorNode: texture(txttre)});
	let mtltrn = new THREE.MeshLambertNodeMaterial({colorNode: color(0x161005)});
	let mtlshd = new THREE.MeshBasicNodeMaterial({colorNode: color(0x000000),transparent:true,opacity:0.5,depthWrite: false});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
		TreePZ[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
	}
	moveTrees();
}

//- Move Trees -----------------------------------------------------------------

function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*GrdSiz;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-air_.MapPos.x-GrdSiz/2;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		let z = air_.MapPos.z-TreePZ[n]-GrdSiz/2;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		let y = -grd_.SPS.y*.99+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

/* Load and Move Fixed Objects ===============================================*/
/* These objects include the airfield, islands and hangar */

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = txtrLoader.load(ObjTxt[i]);
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gltfLoader.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				let s = 32000 * Ft2Mtr;
				ObjPtr[i].scale.set(s,s,s);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*.99;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*.99;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

//= AIRPLANE =============================================================*/

// Load Airplane
function loadACMine() {
	let fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {				// The OnLoad function
		gltf.scene.traverse(function (child) {	
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
//				child.geometry.computeVertexNormals();		// Better result?  Or remove smoothing?
			}
			if (child.name == "propeller") {
				child.castShadow = false;
				child.receiveShadow = false;
			}		
		});
		ACMine = gltf.scene;
		ACMine.rotation.order = "YXZ";
		// Convert from feet to meters
		ACMine.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		/* Animations --------------------------------------------------------------- */
		// Propeller
		let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
		mxProp = new THREE.AnimationMixer(ACMine);
		let actun = mxProp.clipAction(clip);
		actun.play();
		if (mxProp) mxProp.setTime(spnprp/anmfps);
		// Rudder
		mxRudr = new THREE.AnimationMixer(ACMine);
		clip = THREE.AnimationClip.findByName(gltf.animations, "rudderAction");
		actun = mxRudr.clipAction(clip);
		actun.play();
		if (mxRudr) mxRudr.setTime(rudder/anmfps);
		// Elevator
		clip = THREE.AnimationClip.findByName(gltf.animations, "elevatorAction");
		mxElev = new THREE.AnimationMixer(ACMine);
		actun = mxElev.clipAction(clip);
		actun.play();
		if (mxElev) mxElev.setTime(elvatr/anmfps);
		// AileronTL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTLAction");
		mxAlTL = new THREE.AnimationMixer(ACMine);
		actun = mxAlTL .clipAction(clip);
		actun.play();
		if (mxAlTL) mxAlTL.setTime(aillft/anmfps);
		// AileronTR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTRAction");
		mxAlTR = new THREE.AnimationMixer(ACMine);
		actun = mxAlTR.clipAction(clip);
		actun.play();
		if (mxAlTR) mxAlTR.setTime(ailrgt/anmfps);
		// AileronBL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBLAction");
		mxAlBL = new THREE.AnimationMixer(ACMine);
		actun = mxAlBL .clipAction(clip);
		actun.play();
		if (mxAlBL) mxAlBL.setTime(aillft/anmfps);
		// AileronBR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBRAction");
		mxAlBR = new THREE.AnimationMixer(ACMine);
		actun = mxAlBR.clipAction(clip);
		actun.play();
		if (mxAlBR) mxAlBR.setTime(ailrgt/anmfps);
		//
		AirGrp.add(ACMine);
		// Initialize
		ACMine.visible = true;
		loadSounds();
	});
}

//= Move Airplane Model / Virtual Cockpit ======================================
function moveAirObj() {
	// Add Delay to Power
	let gal = PwrDif * PwrMsD.x;		// Current input delayed
	let lag = PwrMsD.z * PwrMsD.y;		// Released from Cumulator
	PwrMsD.z = PwrMsD.z + gal - lag;	// Change in Cumulator
	PwrDif = PwrDif - gal + lag;
	// Input Engine Power
	air_.PwrPct = air_.PwrPct + PwrDif;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	PwrDif = 0;							// Reset
	// Coefficient of Lift
	if (air_.AutoOn) {						// Autopilot
		air_.CfLDif = air_.InpKey.x;
		// Add Delay to Lift
		gal = air_.CfLDif * CfLApD.x;		// Current input delayed
		lag = CfLMsD.z * CfLApD.y;			// Released from Cumulator
		CfLMsD.z = CfLMsD.z + gal - lag; 	// Change in Cumulator
	}
	else {
		air_.CfLDif = (InpMos.y)*air_.PYBmul.x;	// Input Coefficient of Lift
		// Add Delay to Lift
		gal = air_.CfLDif * CfLMsD.x;		// Current input delayed
		lag = CfLMsD.z * CfLMsD.y;			// Released from Cumulator
		CfLMsD.z = CfLMsD.z + gal - lag;	// Change in Cumulator
	}
	air_.CfLDif = air_.CfLDif - gal + lag;
	air_.CfLift = air_.CfLift + air_.CfLDif;	// New Coefficient of Lift	
	if (air_.CfLift > air_.CfLMax) air_.CfLift = air_.CfLMax;
	if (air_.CfLift < -air_.CfLMax) air_.CfLift = -air_.CfLMax;
//	anm_.stkpit = InpMos.y;					// Joystick pitch animation
	InpMos.y = 0;							// Reset
	// Coefficient of Lift - Flaps
//	air_.CfFlap = air_.FlpCfL*(180-anm_.flppos)/180; 	// [FLAP]
	// Bank
	if (air_.AutoOn) {
		air_.RotDif.z = air_.InpKey.z;
		air_.OldRot.z = air_.OldRot.z + air_.RotDif.z*DegRad;
	}
	else {
		// Add Delay to Change in Bank Rate due to Mouse
		let BnkDif = InpMos.x * air_.PYBmul.z;
		gal = BnkDif * BnkMsD.x;			// Current input delayed
		lag = BnkMsD.z * BnkMsD.y;			// Released from Cumulator
		BnkMsD.z = BnkMsD.z + gal - lag;	// Change in Cumulator
		BnkDif = BnkDif - gal + lag;
		air_.RotDif.z = air_.RotDif.z + BnkDif;	
		air_.RotDif.z = MaxVal(air_.RotDif.z,air_.BnkMax);	// Max values
		if (air_.RotDif.z == air_.BnkMax && BnkDif < 0) air_.RotDif.z = BnkDif;
		if (air_.RotDif.z == -air_.BnkMax && BnkDif > 0) air_.RotDif.z = BnkDif;
		air_.RotDif.z = air_.RotDif.z;		// Inputs are +/-
		air_.AGBank = air_.RotDif.z;
//		anm_.stkbnk = InpMos.x;				// Joystick bank animation
		InpMos.x = 0;						// Reset
	}
	// Input Yaw
	if (air_.SpdKPH < 1) air_.RotDif.y = 0;	// No Yaw if Speed < 1;
	// Input Brakes
	air_.BrkVal = InpBrk;				// Brakes
	// Compute Rotation and Vectors --------------------------------------------
	flight.update();
	// Animate -----------------------------------------------------------------	
	// Propeller
	let prpspd =  4 * (air_.PwrPct - 0.6);					// Range = -2.4 to + 1.6
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359;							// A complete circle
	// Rudder
	rudder = 180 + air_.RotDif.y * 100;
	// Elevator
	elvatr = 180 - 10*air_.ACPAdj-25;							// estimated adjustment
	if (elvatr < 150) elvatr = 150;							// Range = 00 to 60
	else if (elvatr > 209) elvatr = 209;
	// Ailerons
	let ailbnk = air_.RotDif.z;
	if (air_.GrFlag) ailbnk = AGBank;
	// Left
	aillft = 180 + ailbnk * 30;
	if (aillft < 151) aillft = 151;							// Range = 00 to 60
	else if (aillft > 209) aillft = 209;
	// Right
	ailrgt = 180 - ailbnk * 30;
	if (ailrgt < 151) ailrgt = 151;							// Range = 00 to 60
	else if (ailrgt > 209) ailrgt = 209;
	/* Animations (Display) ------------------------------------------------- */
	// Propeller
	if (mxProp) mxProp.setTime(spnprp/anmfps);
	// Rudder
	if (mxRudr) mxRudr.setTime(rudder/anmfps);
	// Elevator
	if (mxElev) mxElev.setTime(elvatr/anmfps);
	// Ailerons
	// Left
	if (mxAlTL) mxAlTL.setTime(aillft/anmfps);
	if (mxAlBL) mxAlBL.setTime(aillft/anmfps);
	// Rite
	if (mxAlTR) mxAlTR.setTime(ailrgt/anmfps);
	if (mxAlBR) mxAlBR.setTime(ailrgt/anmfps);
	// View Keys ---------------------------------------------------------------
	if (cam_.pan < 1) {					// Only If Not Panning		
		// If No Keys Pressed, Set Default View
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg < 1)	{
			if (cam_.flg) cam_.lld.x = 0;	// Internal view
			else cam_.lld.x = -12.5;		// External view
			cam_.lld.y = 0;
		}
		// Down 45
		else if (D45flg) {
			cam_.lld.x = 0;
			// Look Back
			if ((L90flg) && (L90flg) && (R90flg)) cam_.lld.y = 180;
			// Look Back Left 90 + 45
			else if (L90flg) cam_.lld.y = 135;
			// Look Back Right 270 - 45
			else if (R90flg) cam_.lld.y = 225;
			// Look Down
			else {
				cam_.lld.y = 0;
				cam_.lld.x = 45;
			}
		}
		// Up 45
		else if (U45flg) {
			cam_.lld.x = 315;
			if (cam_.flg == 0 && (air_.GrdFlg)) cam_.lld.x = 0;
			// Look Up Left 45
			if (L45flg) cam_.lld.y = 45;
			// Look Up Right 45
			else if (R45flg) cam_.lld.y = 315;
			// Look Up Left 90
			else if (L90flg) cam_.lld.y = 90;
			// Look Up Right 90
			else if (R90flg) cam_.lld.y = 270;
			// Look Up
			else cam_.lld.y = 0;
		}
		// Level
		else {
			cam_.lld.x = 0;
			// Look Left 45
			if (L45flg) cam_.lld.y = 45;
			// Look Right 45
			else if (R45flg) cam_.lld.y = 315;
			// Look Left 90
			else if (L90flg) cam_.lld.y = 90;
			// Look Right 90
			else if (R90flg) cam_.lld.y = 270;
		}
	}
}

//= SOUNDS =====================================================================

// Load Sounds
function loadSounds() {	
	// My Engine ---------------------------------------------------------------
	let fname = ACPath + "sounds/" + acsnd1;
	audioLoader.load(fname, function(buffer) {
		sound1.setBuffer(buffer);
		sound1.setRefDistance(RefDst);
		sound1.setLoop(true);
		sound1.setVolume(0);
	});
	// My Guns -----------------------------------------------------------------
	fname = ACPath + "sounds/" + acsnd3;
	audioLoader.load(fname, function(buffer) {
		sound3.setBuffer(buffer);
		sound3.setRefDistance(RefDst);
		sound3.setLoop(true);
		sound3.setVolume(0);
	});
}

// Change Sounds
function moveSounds() {
	// My Engine
	sound1.setVolume(acvol1 + air_.PwrPct * 0.05);				// Range = .1 to .2
	sound1.setPlaybackRate(1 + air_.PwrPct * 0.5);				// Range = 1 to 1.5
	// My Guns
	sound3.setVolume(acvol3);
	// XP Engine
	sound4.setVolume(xpvol1);
}

//= CAMERA =====================================================================

function initCamera(camera,cam_) {
	camera.position.z = -cam_.lld.z;
	camera.rotation.y = cam_.adj*DegRad;
	cam_.rot.add(camera);		// Attach to rotator
	// Common Changes
	cam_.lld.copy(CamLLD[cam_.sel]);		// Restore Saved Values
	cam_.mmd.copy(CamMMD[cam_.sel]);		// In/Out - min, max, spd
	cam_.adj = CamAdj[cam_.sel];			// Load Adjustment
	camera.rotation.y = cam_.adj*DegRad;	// 180 = Looking in
	cam_.mmr.copy(CamMMR[cam_.sel]);		// Rotation min, max, spd
	cam_.par = CamPar[cam_.sel]				// Load New Parent
	cam_.par.add(cam_.rot);					// Attach Rotators
	cam_.flg = CamFlg[cam_.sel];			// 1 = cockpit
	cam_.lnk = CamLnk[cam_.sel];			// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);

}

function moveCamera(camera,cam_) {
	// Move Camera In/Out
	camera.position.z = -cam_.lld.z;
	// PointerLockControls
	if (cam_.pan) {
		cam_.lld.x = cam_.lld.x - InpMos.y * cam_.mmr.z;				// Camera Position (Lat)
		cam_.lld.x = MaxVal(cam_.lld.x,cam_.mmr.x);
		cam_.lld.y = Mod360(cam_.lld.y + InpMos.x * cam_.mmr.z);		// Camera Position (Lon)
		// Internal View
		if (cam_.flg) {											// Range: 250 to 360/0 to 110
			if (cam_.lld.y > 180 && cam_.lld.y < (360-cam_.mmr.y)) cam_.lld.y = (360-cam_.mmr.y);
			if (cam_.lld.y < 180 && cam_.lld.y > cam_.mmr.y) cam_.lld.y = cam_.mmr.y;
		}
		// External View
		else {
			if (air_.GrdFlg > 0 && cam_.lld.x > -12.5) cam_.lld.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// Adjust Camera Rotators
	// In internal view, the camera is facing out - view matches rotation
	if (cam_.flg) {
		cam_.rot.rotation.x = Mod360(cam_.lld.x)*DegRad;
		cam_.rot.rotation.y = Mod360(-cam_.lld.y)*DegRad;
	}
	// In external view, the camera is facing in and the armature is pointing out:
	else {
		cam_.rot.rotation.x = Mod360(-cam_.lld.x)*DegRad;
		cam_.rot.rotation.y = Mod360(180-cam_.lld.y)*DegRad;
		//= Determine Camera Rotation (for SunFlare - always linked)
		if (SnFFlg) {
			// Load Parent Rotation
			cam_.obj.rotation.copy(cam_.par.rotation);
			// Load Camera Adjustments
			cam_.deg.rotation.x = cam_.lld.x*DegRad;
			cam_.deg.rotation.y = -cam_.lld.y*DegRad;	
			// Combine and Transfer Combined Rotation to cam_.obj
			cam_.deg.getWorldQuaternion(cam_.qat);
			cam_.obj.setRotationFromQuaternion(cam_.qat);	
			// Load Resulting Values into Variables (for display)
			cam_.llz.x = cam_.obj.rotation.x*RadDeg;
			cam_.llz.y = Mod360(-cam_.obj.rotation.y*RadDeg);
			cam_.llz.z = Mod360(-cam_.obj.rotation.z*RadDeg);
		}		
	}
}

//= OUTPUTS ====================================================================

// Change HUD Values
function prntHUDval() {
	Air_Pwr = air_.PwrPct;							// Throttle
	Air_PwrNode.nodeValue = Air_Pwr.toFixed(2);
	Air_Spd = air_.SpdKPH*Km2Mil;					// Speed
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Hdg = Mod360(air_.AirRot.y);				// Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
	Air_Alt = air_.MapPos.y;						// Altitude
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);	
	Air_CfL = air_.CfLift;							// Cf Lift
	Air_CfLNode.nodeValue = Air_CfL.toFixed(4);
}

//	Paused On
function PawsText(){
	if (PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//	Autopilot Text
function AutoText(){
	if (air_.AutoOn) Air_AtPNode.nodeValue = "Autopilot On";
	else {Air_AtPNode.nodeValue = "AutoP: Press A";}
}

function InfoText() {
	if (InfoOn == 0) onInfo0();
	else if (InfoOn == 1) onInfo1();
	else if (InfoOn == 2) onInfo2();
}

//	Info Off
function onInfo0(){
	On_Info01Node.nodeValue = "Info : Press I";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

// Info On
function onInfo1(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "CONTROLS";
	On_Info03Node.nodeValue = "Use Mouse to change Pitch and Bank";
	On_Info04Node.nodeValue = "AutoPilot: Use Arrow Keys to change Pitch and Bank";
	On_Info05Node.nodeValue = "Use Mouse Buttons or Z/X Keys to change Yaw";
	On_Info06Node.nodeValue = "Use Mouse Wheel or -/= Keys to change Throttle";
	On_Info07Node.nodeValue = "Press S to toggle sound";
	On_Info08Node.nodeValue = "Spacebar fires guns";
	On_Info09Node.nodeValue = "";
}

// Info On
function onInfo2(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "VIEW KEYS";
	On_Info03Node.nodeValue = "Hold Shift and use Mouse to pan around aircraft";
	On_Info04Node.nodeValue = "Press DELETE or PAGE DOWN to look left/right";
	On_Info05Node.nodeValue = "Press HOME and the above to look up";
	On_Info06Node.nodeValue = "Press END and DELETE or PAGE DOWN to look back";
	On_Info07Node.nodeValue = "Press all 3 keys to look back";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

//= INPUTS =====================================================================
// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//- MOUSE ----------------------------------------------------------------------

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		air_.RotDif.y = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		air_.RotDif.y = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		air_.RotDif.y = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		air_.RotDif.y = 0;
	}
}

//- Mousewheel -----------------------------------------------------------------
function onDocumentMouseWheel(event) {
	event.preventDefault();
	PwrDif = - event.deltaY * PwrMul;	// Increment = 1%
}

//- KEYBOARD -------------------------------------------------------------------

//- Keyboard (Down) ------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	if (event.keyCode == K_BnkL) air_.InpKey.z = -KeyVal.z;	// Bank Left
	if (event.keyCode == K_BnkR) air_.InpKey.z = KeyVal.z;	// Bank Right
	if (event.keyCode == K_PitU) air_.InpKey.x = KeyVal.x;	// Pitch Up
	if (event.keyCode == K_PitD) air_.InpKey.x = -KeyVal.x;	// Pitch Down
	if (event.keyCode == K_Brak) InpBrk = 0.01;			// Brakes
	if (event.keyCode == K_VU45) D45flg = 1;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 1;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 1;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 1;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 1;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 1;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.pan = 1;			// Pan View
	if (event.keyCode == K_Guns) sound3.play();			// Guns
	// Toggle
	if (event.keyCode == K_Soun) toglSoun();			// Toggle Sound
	if (event.keyCode == K_Paws) toglPaws();			// Toggle Pause
	if (event.keyCode == K_Auto) toglAuto();			// Toggle AutoPilot
	if (event.keyCode == K_Info) toglInfo();			// Toggle Information
}

//-	Keyboard (Up) --------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	if (event.keyCode == K_BnkL) air_.InpKey.z = 0;		// Bank Left
	if (event.keyCode == K_BnkR) air_.InpKey.z = 0;		// Bank Right	
	if (event.keyCode == K_PitU) air_.InpKey.x = 0;		// Pitch Up
	if (event.keyCode == K_PitD) air_.InpKey.x = 0;		// Pitch Down
	if (event.keyCode == K_Brak) InpBrk = 0;			// Brakes
	if (event.keyCode == K_VU45) D45flg = 0;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 0;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 0;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 0;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 0;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 0;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.pan = 0;			// Pan View
	if (event.keyCode == K_Guns) sound3.stop();			// Guns
}

//- Subroutines ----------------------------------------------------------------

//. Toggle Sound ...............................................................
function toglSoun() {
	SndFlg = 1 - SndFlg;
	if (SndFlg) {	// Off to On
		sound1.play();
		sound2.play();
		sound4.play();
	}
	else {			// On to Off
		sound1.stop();
		sound2.stop();
		sound3.stop();
		sound4.stop();
	}
}

//. Toggle Pause ...............................................................
function toglPaws() {
	PawsOn = 1 - PawsOn;
	PawsText();
}

//. Toggle AutoPilot ...........................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................................................................
function toglInfo() {
	InfoOn++
	if (InfoOn == 3) InfoOn = 0;
	InfoText();
}

//= WINDOW RESIZE ==============================================================
function onWindowResize() {
	CamAsp = window.innerWidth/window.innerHeight;
	camera.aspect = CamAsp;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>