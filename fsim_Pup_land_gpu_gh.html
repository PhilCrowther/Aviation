<!doctype html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 7 Jun 2025

A demo of a flight simulation of an animated airplane model over farmland using WebGPU and NodeMaterials.
-->

<head>
<title>fsim Pup land gpu r177</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Throttle: <span id="Air_Pwr"></span></div>
		<div>AirSpeed: <span id="Air_Spd"></span> mph</div>
		<div>Altitude: <span id="Air_Alt"></span> ft</div>
		<div>Heading : <span id="Air_Hdg"></span> deg</div>
		<div>CoefLift: <span id="Air_CfL"></span></div>
	</div>
	<div class="overlay2">
		<div><span id="On_Paws"></span></div>
		<div><span id="Air_AtP"></span></div>
		<div><span id="On_Inf0"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Inf1"></span></div>
		<div><span id="On_Inf2"></span></div>
		<div><span id="On_Inf3"></span></div>
		<div><span id="On_Inf4"></span></div>
		<div><span id="On_Inf5"></span></div>
		<div><span id="On_Inf6"></span></div>
		<div><span id="On_Inf7"></span></div>
		<div><span id="On_Inf8"></span></div>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script src="https://PhilCrowther.github.io/Aviation/data/fsim_Pup_land_gpu.js"></script>
<script src="https://PhilCrowther.github.io/Aviation/models/pup/data/data.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.webgpu.js",
			"three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.webgpu.js",
			"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.tsl.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/",
			"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.8/dist/main.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {color,float,texture} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement} from "three/addons/objects/LensflareMesh.js";
import Stats from "stats-gl";
// Custom Modules
import {initBullet,moveBullet} from "https://PhilCrowther.github.io/Aviation/jsm/Effects.js";
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdMap.js";
import {Flight,Mod360,PoM360,MaxVal} from "https://PhilCrowther.github.io/Aviation/jsm/Flight.js";
import {PointerLockControls} from "https://PhilCrowther.github.io/Aviation/jsm/Controls.js";

/*= GENERAL ====================//==============================================

This flight simulation demo uses the most advanced version of three.js

=FEATURES
-Flight Smulation
	* Realistic Flight Simulation and AutoPilot (Flight Module)
	* Taildragger takeoff and landing
	* Static Landing Surfaces
-Scenery:
	* Textured Farmland
	* Mountains
	* SunFlare
-My Airplane:
	* Detailed Airplane Model
	* Animated Controls
	* 3D Sounds

TO DO:
-	Program:
	* After landing with brakes, not always stay stopped.
	* Sometimes, need to wiggle plane to take off.
*/

//= INPUTS =====================//==============================================
//- AIRPLANE: Start -----------------------------------------------------------
let BegLoc = 0;					// Starting Location (0 = Base; 1 = Air)
let CamSel = 0;					// Camera Seletion (0 = External; 1 = Internal)
let BegTmp = 288.15;			// K = 59F
//- AIRPLANE: Flight -----------------------------------------------------------
let PYBmul = new THREE.Vector3(0.004,1.0,0.001); // Basic airplane values
let	MosMul = new THREE.Vector3(1.0,1.0,1.0); // Adjustment to PYBmul (default = 1)
let Throtl = 0;					// Throttle Setting (0 to 1)
//- Mouse Delays ...............................................................
//- (x = diverted, y = released, z = stored)
let LagPwr = new THREE.Vector3(1-1/30,1/15,0);	// Power
let LagCfL = new THREE.Vector3(1-1/30,1/15,0);	// CfL
let LagAtP = new THREE.Vector2(0.967,0.099);	// CfL - Autopilot
let LagBnk = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- Key Vaulues (XZ = Autopilot Pitch/Bank; Y = Yaw Mouse Button or Key) .......
let KeyVal = new THREE.Vector3(1,.05,0.25);	// Key Values (Yaw = turn rate in 15 deg bank)

//= SUN VALUES =================//==============================================
//- New
let SunSph = new THREE.Spherical(sky_.SunDst,(90-sky_.SunLat)*DegRad,Mod360(180-sky_.SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);

//= STANDARD SETUP =============//==============================================
//- Scene
let scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
//- Light
let ambLight = new THREE.AmbientLight(sky_.SunCol,0.2);
	scene.add(ambLight);
//- SunLight
let sunLight = new THREE.DirectionalLight(sky_.SunCol,sky_.SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = sky_.SunDst*0.75;
	sunLight.shadow.camera.far = sky_.SunDst+sky_.ShdDst+sky_.ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -sky_.ShdBLR;
	sunLight.shadow.camera.right = sky_.ShdBLR;
	sunLight.shadow.camera.top = sky_.ShdBTB;
	sunLight.shadow.camera.bottom = -sky_.ShdBTB;
	sunLight.shadow.bias = -0.00001; // WebGPU (0 flashing; -0.0001 no wheels)
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
let camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//- Renderer
let renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
let maxAnisotropy = renderer.getMaxAnisotropy();
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
let audoLoader = new THREE.AudioLoader();
// Create Audio Listener
let	listener = new THREE.AudioListener();
	camera.add(listener);
//- Wait Screen
let loadingScreen = {
		scene: new THREE.Scene(),
		camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
		box: 0
	};
let boxrot = 0;

//= GEOMAT =====================//==============================================
//= Textures Data ==============//==============================================
//- All textures are 512X512
let dqSize = 1024;
let dqArea = dqSize*dqSize;
let dtSize = 512;
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;					// Total Textures
//- Canvas
let ImgSiz = 1024;				// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext("2d",{willReadFrequently: true});
//= Grid 4 Data ================//==============================================
//- 1/4 section squares (1/2 mile X 1/2 mile)
//- Variables
let GrdMul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];
//- Colors
let GrdDrt = "#1c160e";			// Color of underlying dirt (affects brightness)
let drtclr = [0x8e6d3d,0x47361e]; // Dirt
let pstclr = [0x00b000,0x005000]; // Pasture
let cvrclr = [0x75b24c,0x466b2d]; // Green
let whtclr = [0xfbf4e5,0xeabb63]; // Wheat
let bnsclr = [0xacd193,0x5d8e3d]; // Beans
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//	[https://icolorpalette.com/color/dirt-brown
let count0;
//= MATERIALS ==================//==============================================
//= Grid 0 Data ================//==============================================
//- Image Data
let G0DPtr = [];
	G0DPtr[txtTot-1] = 0;
//- Materials
let G0MPtr = [];
	G0MPtr[txtTot-1] = 0;
// Patterns for Grid 5 3X3 Textures
// Also used to draw Grid 4 textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G0Id00 = [4,3,5,4,3,0,5,2,1];
let G0Id01 = [3,0,4,1,2,4,5,3,5];
let G0Id02 = [5,1,3,4,5,0,2,4,3];
let G0Id03 = [2,4,1,3,5,3,5,0,4];
let G0Id04 = [5,1,5,0,3,4,2,4,3];
let G0Id05 = [3,0,5,3,4,5,1,2,4];
let G0Id06 = [2,0,3,5,3,1,4,4,5];
let G0Id07 = [1,5,4,3,5,0,2,4,3];
let G0Id08 = [2,3,0,5,3,1,4,5,4];
let G0Id09 = [0,2,5,3,4,3,5,1,4];
let G0Id10 = [4,3,5,4,5,2,1,3,0];
let G0Id11 = [4,5,3,0,1,4,3,5,2];
let G0Id12 = [3,1,2,4,5,3,5,0,4];
let G0Id13 = [0,5,3,1,4,2,4,3,5];
let G0Id14 = [1,4,2,5,3,0,4,5,3];
let G0Id15 = [4,1,5,0,3,4,3,5,2];
let G0Indx = [
		G0Id00,G0Id01,G0Id02,G0Id03,G0Id04,G0Id05,G0Id06,G0Id07,G0Id08,G0Id09,
		G0Id10,G0Id11,G0Id12,G0Id13,G0Id14,G0Id15
	];
//= Grid 1 Data ================//==============================================
let Gr1Mul = 3;
let Gr1Siz = Math.floor(dtSize/Gr1Mul);
// Image Data (Source Data - Resized)
let G1SPtr = [];
	G1SPtr[G0Indx.length-1] = 0;
// Image Data
let G1DPtr = [];
	G1DPtr[G0Indx.length-1] = 0;
// Materials
let G1MPtr = [];
	G1MPtr[G1DPtr.length-1] = 0;
// Index to Display of G1 Textures by Type
// Used by G0 to position squares
// And by G1 to create textures
let G1Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,	//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4,11,13, 8,12, 7,	// 11 = Over Airport
		 4, 7,15,12, 3,11, 9,13, 4,
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];
//= Grid 2 Data ================//==============================================
let Gr2Mul = 3;
let Gr2Siz = Math.floor(dtSize/Gr2Mul);
// Image Data (Source Data - Resized)
let G2SPtr = [0,0,0,0,0,0,0,0,0];
// Image Data
let G2DPtr = [0,0,0,0,0,0,0,0,0];
// Materials
let G2MPtr = [0,0,0,0,0,0,0,0,0];

//= GRID MODULE ================//==============================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let GrdSiz = 804.67;			// Size of Smallest Grid Square (1/4 section = 1/2 mile)
let grids = 0;
let grd_ = {
		SPS: new THREE.Vector3 (), // MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,				// Squares in each of first 2 grids
		Siz: GrdSiz,			// Size of smallest square
		Stp: 3,					// Squares in each of first 2 grids
		Grx: [],				// Index of Grids (0-2)
		Idx: [G0Indx,G1Indx],	// Index to Patterns
		Mat: [G0MPtr,G1MPtr,G2MPtr], // Materials
	}
/* = Roads =====================//============================================*/
//- North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,		// Size of square
		Stp:	1,				// Squares to flip
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		Txt:	0,				// Texture Address
		Shd:	1				// Shadow enabled
	}
//- East West
let Rod2 = {
		Typ:	2,
		RCs:	21,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,		// Size of square
		Stp:	1,				// Squares to flip
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		Txt:	0,				// Texture Address
		Shd:	1				// Shadow enabled
	}
//- Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//-	Tones of Dirt Brown Color | #836539 Monochromatic Color
//-	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);
//= Trees ======================================================================
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//= Objects ====================//==============================================
//- Distances in Meters
let ObjNum = 2;					// number of objects
let ObjTyp = [0];				// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];				// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];				// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];				// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];				// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];				// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];				// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];				// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
//- Hangars
	ObjTyp[ObjIdx] = 0;			// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 200;		// [m]
	ObjMPY[ObjIdx] = 0.3048;	// [m] 1 ft
	ObjMPZ[ObjIdx] = 250;		// [m]
	ObjIdx = ObjIdx + 1;
//- Giaros Island
	ObjTyp[ObjIdx] = 1;			// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/textures/giaros.png";
	ObjMPX[ObjIdx] = -1609.344;	// [m] 1 mile
	ObjMPY[ObjIdx] = 2*Ft2Mtr;	// [m] 2 ft
	ObjMPZ[ObjIdx] = 8046.72;	// [m] 5 miles

//= 5. MY AIRPLANE VARIABLES ===//==============================================
//- Adjustments
	air_.AirDat = data_;
	air_.AirRot = new THREE.Euler();
	air_.AirObj = new THREE.Object3D;
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY = new THREE.Object3D;
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY); // PBY includes air_.ACPadj
	scene.add(air_.AirObj);		// Airplane
	air_.RotDif = new THREE.Vector3();
	air_.MapSpd = new THREE.Vector3();
	air_.MapPos = new THREE.Vector3();
	air_.MapSPS = new THREE.Vector3();
	air_.PYBmul = new THREE.Vector3().copy(PYBmul);
	air_.InpKey = new THREE.Vector3();
	air_.OldRot = new THREE.Euler();
//- Air Group
let AirGrp = new THREE.Group();	// To hold mxr_.Adr and VCMine
	air_.AirPBY.add(AirGrp);

//= GUNASG MODULE ==============//==============================================
//	Adjustments
	myg_.BulClr = new THREE.Vector2(0xff80ff,0x804080); // Red
	myg_.SndSrc = AirSrc + "sounds/" + "pup_gun.mp3", // File (my guns)
	myg_.ObjPos = [new THREE.Vector3(0,0,1)]; // Position of Each Barrel
	myg_.SndMsh = [new THREE.Object3D,new THREE.Object3D];

//=	MY SOUNDS ==================//==============================================
//- Adjustments
	mys_.AirMsh = new THREE.Object3D;

//= CAMERA =====================//==============================================
//- Create Cockpit Attach Point
let	CamPVC = new THREE.Object3D;
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirPBY.add(CamPVC); 	// Attach CamPVC to AirPBY (### not AirObj)
//- Camera Inputs (External Camera linked to air_.AirPBY; 1 Internal Camera Linked to cam_.PVC)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];			// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CmIFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
//- Shared Variables
let cam_ = {
		CamSel: CamSel,			// View Selector (0 = External, 1 = Internal)
		CamNum: CamNum,
		OrbFlg: 0,				// Orbit Flag (1 = Orbiting)
		// Camera
		CamLLD: new THREE.Vector3().copy(CamLLD[CamSel]),	// cam_.MshRot Lat, Lon, Dst
		CamAdj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		CamMMD: new THREE.Vector3().copy(CamMMD[CamSel]),	// In/Out - min,max,spd
		// Rotator
		MshRot: new THREE.Object3D,			// Camera Rotator
		CamMMR: new THREE.Vector3().copy(CamMMR[CamSel]),	// Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		Parent: CamPar[CamSel],	// Center of Rotation	
		CamFlg: CmIFlg[CamSel],	// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		CamLnk: CamLnk[CamSel],
		MshObj: new THREE.Object3D,
		MshDeg: new THREE.Object3D
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.MshRot.rotation.order = "YXZ";
	cam_.MshObj.rotation.order = "YXZ";
	cam_.MshDeg.rotation.order = "YXZ";
	cam_.Parent.add(cam_.MshRot);		// Attach Rotator
	cam_.MshObj.add(cam_.MshDeg);
//- Adjust Camera x.rotation
let CmAdjX = 0;					// Airborne Pitch Adjustment
let CmGrdF = 0;					// Camera Ground Flag (1 = On Ground)
let CmMulX = 15;				// Pitch Adjustment Multiplier
let CmLagX = 0;					// Transition Offset

//= 9. INPUT VARIABLES =========//==============================================
//- POINTER LOCK CONTROLS ------//----------------------------------------------
//	Adjustments
	InpMos = new THREE.Vector2(); // Mouse Inputs
//. Setup ......................................................................
let controls = new PointerLockControls(camera, renderer.domElement,air_);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener( "unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

//= MAIN PROGRAMS ==============================================================

	loadAll();

//=	0 LOAD ALL =================================================================

function loadAll() {
	// Initialize Loading Screen
	WaitScreen();						// init loading screen
	loadSkyBox();
	loadObject();
	loadAirObj();
	gen_.AltDif = air_.MapPos.y*gen_.AltAdj; // Used by everything
}

//= WAIT SCREEN ================================================================

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 INITIALIZE ================//==============================================

function initAll() {
	// Time
	tim_.DLTime = 1/60;			// Seconds per frame (default)
	tim_.DLTim2 = tim_.DLTime**2;
	tim_.GrvDLT = GrvMPS*tim_.DLTim2;
	initSkyBox();				// load skybox
	// Objects
	initAirObj();
	gen_.AltDif = air_.MapPos.y*gen_.AltAdj; // Used by everything
	initGrdTxt();
	grd_.SPS.y = air_.MapSPS.y;
	grids = new GrdMap(grd_,scene);	// Init Grid Map
	grids.update(grd_);			// Mode Grid Map
	initRoads();
	makeTrees();
	initObject();				// Stationary Objects
	// Other
	initCamera(camera,cam_);	// position camera
	PawsText();
	AutoText();
	InfoText();
	// Show stats
	if (gen_.StatOn) {			// show stats
		gen_.StatOn = new Stats({
			precision: 3,
			horizontal: false
		});
		gen_.StatOn.init(renderer);
		gen_.StatOn.domElement.style.cssText = "position:absolute;top:75%;left:95%;";
		container.appendChild(gen_.StatOn.dom);
	}
	gen_.LodFlg = 1;
}

//= 2 RENDER ===================//==============================================

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;					// Stop the function here.
	}
	if (controls.isLocked === true && !gen_.LodSnd) loadSounds();
	if (!gen_.PawsOn && gen_.LodFlg && controls.isLocked === true) {
		moveCamera(camera,cam_);
		// Move Objects
		moveAirObj();			// Move aircaft
		gen_.AltDif = air_.MapPos.y*gen_.AltAdj; // Used by everything
		// Move Grids
		grd_.SPS.copy(air_.MapSPS);	// Update Position
		grids.update(grd_);		// Mode Grid Map
		moveRoads();
		moveTrees();		
		moveObject();			// Move objects
		// Other
		moveSounds();
		prntHUDval();			// change HUD value
		if (gen_.StatOn) gen_.StatOn.update(); // update stats
	}
	if (controls.isLocked === false && gen_.LodSnd) {
		stopSounds();
		gen_.SndFlg = gen_.MYGFlg = 0;
	}
	renderer.renderAsync(scene, camera); // ### WebGPU requires Async
	renderer.resolveTimestampsAsync(THREE.TimestampQuery.RENDER); // r173
}

//= SKYBOX =====================//==============================================

function loadSkyBox() {
	sky_.envMap = cubeLoader
		.setPath(sky_.SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	sky_.envMap.format = THREE.RGBAFormat;
	sky_.envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = sky_.envMap;
	// LensFlare
	if (gen_.LnFFlg) {			// SunFlare	
		sky_.LF0Txt = txtrLoader.load(sky_.LF0Src);
		sky_.LF1Txt = txtrLoader.load(sky_.LF1Src);
	}
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(sky_.FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (gen_.LnFFlg) {			// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);	
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(sky_.LF0Txt,256,0));
			LF.addElement(new LensflareElement(sky_.LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(sky_.LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

//= GRID MAP ===================================================================

//= Make Grid Map Textures =====================================================

function initGrdTxt() {
	initGr0Txt();
	initGr1Txt();
	initGr6Txt();
}

function initGr0Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G0DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G0DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);	// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);	// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(GrdMul,GrdMul);
		DatTxt.anisotropy = maxAnisotropy;
		DatTxt.needsUpdate = true;		
		G0MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G0DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr1Siz,Gr1Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G1SPtr[n] = context.getImageData(0,0,Gr1Siz,Gr1Siz);				//
	}
}

function initGr1Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr1Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G0Indx.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G0Indx[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
				let ImgDat = G1SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G1DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G1DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;
		DatTxt.needsUpdate = true;
		G1MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G1DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr2Siz,Gr2Siz);
		G2SPtr[n] = context.getImageData(0,0,Gr2Siz,Gr2Siz);
	}
}

function initGr6Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr2Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G2SPtr[G1Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G2DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G2DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;
			DatTxt.needsUpdate = true;
			G2MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

//= Make Textures ==============================================================

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

/* Roads ==================================================================*/

function initRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

function initRoad2(Rod) {
	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(25*Ft2Mtr,Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz,25*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].renderOrder = 1;
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*gen_.AltAdj+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

// Move Roads
function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - grd_.SPS.z;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*gen_.AltAdj+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

//= TREES ======================================================================

//- Make Trees ------------------------------------------------------------------

function makeTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)		// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;	// ###
	txttre.needsUpdate = true;
	let mtltre = new THREE.MeshLambertNodeMaterial({colorNode: texture(txttre)});
	let mtltrn = new THREE.MeshLambertNodeMaterial({colorNode: color(0x161005)});
	let mtlshd = new THREE.MeshBasicNodeMaterial({colorNode: color(0x000000),transparent:true,opacity:0.5,depthWrite: false});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
		TreePZ[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
	}
	moveTrees();
}

//- Move Trees -----------------------------------------------------------------

function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*GrdSiz;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-air_.MapPos.x-GrdSiz/2;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		let z = air_.MapPos.z-TreePZ[n]-GrdSiz/2;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		let y = -grd_.SPS.y*gen_.AltAdj+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

/* Load and Move Fixed Objects ===============================================*/
/* These objects include the airfield, islands and hangar */

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = txtrLoader.load(ObjTxt[i]);
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gltfLoader.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(32000*Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-gen_.AltDif;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-gen_.AltDif;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

//= AIRPLANE ===================================================================

// Load Airplane
function loadAirObj() {
	gltfLoader.load(mxr_.Src, function (gltf) {				// The OnLoad function
		gltf.scene.traverse(function (child) {	
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
//				child.geometry.computeVertexNormals();		// Better result?  Or remove smoothing?
			}
			if (child.name == "propeller") {
				child.castShadow = false;
				child.receiveShadow = false;
				child.renderOrder = 1;
			}		
		});
		mxr_.Adr = gltf.scene;
		mxr_.Adr.rotation.order = "YXZ";
		// Convert from feet to meters
		mxr_.Adr.scale.set(Ft2Mtr, Ft2Mtr, Ft2Mtr);
		/* Animations --------------------------------------------------------------- */
		// Propeller
		let clip = THREE.AnimationClip.findByName(gltf.animations, "propellerAction");
		mxr_.Prp = new THREE.AnimationMixer(mxr_.Adr);
		let actun = mxr_.Prp.clipAction(clip);
		actun.play();
		if (mxr_.Prp) mxr_.Prp.setTime(anm_.spnprp/anm_.anmfps);
		// Rudder
		mxr_.Rdr = new THREE.AnimationMixer(mxr_.Adr);
		clip = THREE.AnimationClip.findByName(gltf.animations, "rudderAction");
		actun = mxr_.Rdr.clipAction(clip);
		actun.play();
		if (mxr_.Rdr) mxr_.Rdr.setTime(anm_.rudder/anm_.anmfps);
		// Elevator
		clip = THREE.AnimationClip.findByName(gltf.animations, "elevatorAction");
		mxr_.Elv = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.Elv.clipAction(clip);
		actun.play();
		if (mxr_.Elv) mxr_.Elv.setTime(anm_.elvatr/anm_.anmfps);
		// AileronTL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTLAction");
		mxr_.ATL = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.ATL .clipAction(clip);
		actun.play();
		if (mxr_.ATL) mxr_.ATL.setTime(anm_.aillft/anm_.anmfps);
		// AileronTR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronTRAction");
		mxr_.ATR = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.ATR.clipAction(clip);
		actun.play();
		if (mxr_.ATR) mxr_.ATR.setTime(anm_.ailrgt/anm_.anmfps);
		// AileronBL
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBLAction");
		mxr_.ABL = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.ABL .clipAction(clip);
		actun.play();
		if (mxr_.ABL) mxr_.ABL.setTime(anm_.aillft/anm_.anmfps);
		// AileronBR
		clip = THREE.AnimationClip.findByName(gltf.animations, "aileronBRAction");
		mxr_.ABR = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.ABR.clipAction(clip);
		actun.play();
		if (mxr_.ABR) mxr_.ABR.setTime(anm_.ailrgt/anm_.anmfps);
		//
		AirGrp.add(mxr_.Adr);
		// Initialize
		mxr_.Adr.visible = true;
	});
}

//= Init Airplane ==============//==============================================
// This section initializes starting location and variables before passing to Flight Module
function initAirObj() {
	//	Starting Location
	if (BegLoc == 0) { 			// Base
		air_.MapPos.y = air_.GrdZed;
		air_.GrdFlg = 1;
	}
	if (BegLoc == 1) { 			// Air
		gen_.PwrDif = 1000;			// This forces PwrPct to max
		air_.SpdKPH = 161;		// Speed (kph = 100 mph)
		air_.MapSPS.y = air_.MapPos.y = 200;
	}
	// Speed
	if (air_.SpdKPH) {
		air_.SpdMPS = air_.SpdKPH/3.6; // Speed - meters per second
		air_.SpdMPF = (air_.SpdKPH/3.6)*tim_.DLTime; // Speed - meters per frame
	}
	// Altitude
	if (air_.MapPos.y == 0) air_.GrdFlg = 1; // Altitude
	grd_.SPS.copy(air_.MapSPS); // Use to initialize objects
	// Flight
	flight = new Flight(air_);	// position airplane using air_.GrdZed
	air_.PYBmul.x = air_.PYBmul.x*MosMul.x;	// Pitch Adjustment
	air_.PYBmul.z = air_.PYBmul.x*MosMul.z;	// Bank Adjustment
	// If on Ground, Reaadjust
	grd_.SPS.y = air_.MapSPS.y; // Use to initialize objects (if on ground)
	// Init Bullets
	initBullet(myg_,scene);
}

//= Move Airplane Model ========//==============================================
// This section processes Input before passing to Flight Module
// And manages Views and Animations
function moveAirObj() {
	// Compute Inputs ----------------------------------------------------------
	// Power Percent ...........................................................
	// Add Delay
	let gal = gen_.PwrDif * LagPwr.x; // Current input delayed
	let lag = LagPwr.z * LagPwr.y; // Released from Cumulator
	LagPwr.z = LagPwr.z + gal - lag; // Change in Cumulator
	gen_.PwrDif = gen_.PwrDif - gal + lag;
	// Input Engine Power
	air_.PwrPct = air_.PwrPct + gen_.PwrDif;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	gen_.PwrDif = 0;					// Reset
	// Coefficient of Lift .....................................................
	if (air_.AutoOn) {			// Autopilot
		air_.CfLDif = air_.InpKey.x;
		// Add Delay to Lift
		gal = air_.CfLDif * LagAtP.x; // Current input delayed
		lag = LagCfL.z * LagAtP.y; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	else {
		air_.CfLDif = (InpMos.y)*air_.PYBmul.x;	// Input Coefficient of Lift
		// Add Delay to Lift
		gal = air_.CfLDif * LagCfL.x; // Current input delayed
		lag = LagCfL.z * LagCfL.y; // Released from Cumulator
		LagCfL.z = LagCfL.z + gal - lag; // Change in Cumulator
	}
	air_.CfLDif = air_.CfLDif - gal + lag;
	air_.CfLift = air_.CfLift + air_.CfLDif; // New Coefficient of Lift
	// Limits
	if (air_.CfLift > air_.CfLMax) air_.CfLift = air_.CfLMax;
	if (air_.CfLift < -air_.CfLMax) air_.CfLift = -air_.CfLMax;
	//anm_.stkpit = InpMos.y;	// Joystick pitch animation (NA)
	InpMos.y = 0;				// Reset
	// Coefficient of Lift - Flaps (NA)	
	//air_.CfFlap = air_.FlpCfL*(180-anm_.flppos)/180; // CfL - Flaps
	// Bank ....................................................................
	if (air_.AutoOn) {
		air_.RotDif.z = air_.InpKey.z;
		air_.OldRot.z = air_.OldRot.z + air_.RotDif.z*DegRad;
	}
	else {
		// Add Delay to Change in Bank Rate due to Mouse
		let BnkDif = InpMos.x * air_.PYBmul.z;
		gal = BnkDif * LagBnk.x;			// Current input delayed
		lag = LagBnk.z * LagBnk.y;			// Released from Cumulator
		LagBnk.z = LagBnk.z + gal - lag;	// Change in Cumulator
		BnkDif = BnkDif - gal + lag;
		air_.RotDif.z = air_.RotDif.z + BnkDif;	
		air_.RotDif.z = MaxVal(air_.RotDif.z,air_.BnkMax); // Max values
		if (air_.RotDif.z == air_.BnkMax && BnkDif < 0) air_.RotDif.z = BnkDif;
		if (air_.RotDif.z == -air_.BnkMax && BnkDif > 0) air_.RotDif.z = BnkDif;
		air_.RotDif.z = air_.RotDif.z; // Inputs are +/-
		air_.AGBank = air_.RotDif.z;
//		anm_.stkbnk = InpMos.x;	// Joystick bank animation
		InpMos.x = 0;			// Reset
	}
	// Input Yaw ...............................................................
	if (air_.SpdKPH < 1) air_.RotDif.y = 0;	// No Yaw if Speed < 1;
	// Input Brakes ............................................................
	air_.BrkVal = gen_.InpBrk;		// Brakes
	// Compute Rotation and Vectors --------------------------------------------
	flight.update();
	// View Keys ---------------------------------------------------------------
	if (!cam_.OrbFlg) {			// Only If Not Panning		
		// If No Keys Pressed, Set Default View
		if (key_.U45flg+key_.D45flg+key_.L45flg+key_.R45flg+key_.L90flg+key_.R90flg < 1)	{
			if (cam_.IntFlg) cam_.CamLLD.x = 0; // Internal view
			else cam_.CamLLD.x = -12.5; // External view
			cam_.CamLLD.y = 0;
		}
		// Down 45
		else if (key_.D45flg) {
			cam_.CamLLD.x = 0;
			// Look Back
			if ((key_.L90flg) && (key_.L90flg) && (key_.R90flg)) cam_.CamLLD.y = 180;
			// Look Back Left 90 + 45
			else if (key_.L90flg) cam_.CamLLD.y = 135;
			// Look Back Right 270 - 45
			else if (key_.R90flg) cam_.CamLLD.y = 225;
			// Look Down
			else {
				cam_.CamLLD.y = 0;
				cam_.CamLLD.x = 45;
			}
		}
		// Up 45
		else if (key_.U45flg) {
			cam_.CamLLD.x = 315;
			if (!cam_.IntFlg && (air_.GrdFlg)) cam_.CamLLD.x = 0;
			// Look Up Left 45
			if (key_.L45flg) cam_.CamLLD.y = 45;
			// Look Up Right 45
			else if (key_.R45flg) cam_.CamLLD.y = 315;
			// Look Up Left 90
			else if (key_.L90flg) cam_.CamLLD.y = 90;
			// Look Up Right 90
			else if (key_.R90flg) cam_.CamLLD.y = 270;
			// Look Up
			else cam_.CamLLD.y = 0;
		}
		// Level
		else {
			cam_.CamLLD.x = 0;
			// Look Left 45
			if (key_.L45flg) cam_.CamLLD.y = 45;
			// Look Right 45
			else if (key_.R45flg) cam_.CamLLD.y = 315;
			// Look Left 90
			else if (key_.L90flg) cam_.CamLLD.y = 90;
			// Look Right 90
			else if (key_.R90flg) cam_.CamLLD.y = 270;
		}
	}
	// Animate -----------------------------------------------------------------	
	// Propeller
	let prpspd =  4 * (air_.PwrPct - 0.6);					// Range = -2.4 to + 1.6
	anm_.spnprp = anm_.spnprp - prpspd;
	if (anm_.spnprp < 0) anm_.spnprp = 359;					// A complete circle
	// Rudder
	anm_.rudder = 180 + air_.RotDif.y * 100;
	// Elevator
	anm_.elvatr = 180 - 10*air_.ACPAdj-25;					// estimated adjustment
	if (anm_.elvatr < 150) anm_.elvatr = 150;				// Range = 00 to 60
	else if (anm_.elvatr > 209) anm_.elvatr = 209;
	// Ailerons
	let ailbnk = air_.RotDif.z;
	if (air_.GrFlag) ailbnk = AGBank;
	// Left
	anm_.aillft = 180 + ailbnk * 30;
	if (anm_.aillft < 151) anm_.aillft = 151;				// Range = 00 to 60
	else if (anm_.aillft > 209) anm_.aillft = 209;
	// Right
	anm_.ailrgt = 180 - ailbnk * 30;
	if (anm_.ailrgt < 151) anm_.ailrgt = 151;				// Range = 00 to 60
	else if (anm_.ailrgt > 209) anm_.ailrgt = 209;
	/* Animations (Display) ------------------------------------------------- */
	// Propeller
	if (mxr_.Prp) mxr_.Prp.setTime(anm_.spnprp/anm_.anmfps);
	// Rudder
	if (mxr_.Rdr) mxr_.Rdr.setTime(anm_.rudder/anm_.anmfps);
	// Elevator
	if (mxr_.Elv) mxr_.Elv.setTime(anm_.elvatr/anm_.anmfps);
	// Ailerons
	// Left
	if (mxr_.ATL) mxr_.ATL.setTime(anm_.aillft/anm_.anmfps);
	if (mxr_.ABL) mxr_.ABL.setTime(anm_.aillft/anm_.anmfps);
	// Rite
	if (mxr_.ATR) mxr_.ATR.setTime(anm_.ailrgt/anm_.anmfps);
	if (mxr_.ABR) mxr_.ABR.setTime(anm_.ailrgt/anm_.anmfps);
	// Bullets
	moveBullet(myg_,air_,gen_,tim_,0);
}

//= SOUNDS =====================//==============================================

//- Load and Initialize Sounds -------------------------------------------------
function loadSounds() {
	// Engine Sounds ...........................................................
	air_.AirObj.add(mys_.AirMsh);
	mys_.AirMsh.position.z = -5;
	let RefDst = 25;			// Reference distance for Positional Audio
	// Engine - Idle
	mys_.IdlSnd = new THREE.PositionalAudio(listener);
	audoLoader.load(mys_.IdlSrc,function(buffer) {
		mys_.IdlSnd.setBuffer(buffer);
		init1Sound(mys_.IdlSnd,RefDst,0,1,1,mys_.AirMsh);		
	});
	// Engine
	mys_.EngSnd = new THREE.PositionalAudio(listener);
	audoLoader.load(mys_.EngSrc,function(buffer) {
		mys_.EngSnd.setBuffer(buffer);
		init1Sound(mys_.EngSnd,RefDst,0,1,1,mys_.AirMsh);		
	});
	// My Guns (Center) ........................................................
	myg_.SndPtr[0] = new THREE.PositionalAudio(listener);
	audoLoader.load(myg_.SndSrc,function(buffer) {
		myg_.SndPtr[0].setBuffer(buffer);
		init1Sound(myg_.SndPtr[0],RefDst,0,1,1,myg_.SndMsh[0]);
		air_.AirObj.add(myg_.SndMsh[0]);
	});
	//- Set Flag
	gen_.LodSnd = 1;
}

//- Change Sounds --------------------------------------------------------------
function moveSounds() {
	// Switch Between Idle and Engine Sounds
	if (Throtl < .25 && mys_.EngSnd.isPlaying) {
		mys_.IdlSnd.play();
		mys_.EngSnd.stop();
	}
	if (Throtl >= .25 && mys_.IdlSnd.isPlaying) {
		mys_.IdlSnd.stop();
		mys_.EngSnd.play();
	}
	// Idle Sound
	if (mys_.IdlSnd.isPlaying) mys_.IdlSnd.setVolume(mys_.IdlVol);
	else {mys_.IdlSnd.setVolume(0);}
	// My Engine
	if (mys_.EngSnd.isPlaying) mys_.EngSnd.setVolume(mys_.EngVol + air_.PwrPct * 0.05); // Range = .1 to .2
	else {mys_.EngSnd.setVolume(0);};
	mys_.EngSnd.setPlaybackRate(1 + air_.PwrPct * 0.5); // Range = 1 to 1.5
	// My Guns
	for (let n = 0; n < myg_.ObjNum; n ++) {myg_.SndPtr[n].setVolume(myg_.SndVol);}
}

//- Play Sounds ----------------------------------------------------------------
function playSounds() {
	// This leaves gen_.SndFlg and gen_.MYGFlg unchanged.
	if (!mys_.IdlSnd.isPlaying) mys_.IdlSnd.play();
	if (!mys_.EngSnd.isPlaying) mys_.EngSnd.play();
	for (let n = 0; n < myg_.ObjNum; n ++) {if (gen_.MYGFlg && !myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].play();}
}

//- Stop Sounds ----------------------------------------------------------------
function stopSounds() {
	// This leaves gen_.SndFlg and gen_.MYGFlg unchanged.
	if (mys_.IdlSnd.isPlaying) mys_.IdlSnd.stop();
	if (mys_.EngSnd.isPlaying) mys_.EngSnd.stop();
	for (let n = 0; n < myg_.ObjNum; n ++) {if (myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].stop();}
}

//- INIT 1 SOUND ---------------//----------------------------------------------

//- Positional Audio
function init1Sound(dest,dist,volm,rate,loop,link) {
	dest.setRefDistance(dist);	// Position
	dest.setVolume(volm);
	dest.playbackRate = rate;
	if (loop) dest.setLoop(true);
	link.add(dest);
}

//- Positional Audio
function init2Sound(dest,dist,volm,rate,loop) {
	dest.setRefDistance(dist);	// Position
	dest.setVolume(volm);
	dest.playbackRate = rate;
	if (loop) dest.setLoop(true);
}

//- Audio
function initASound(dest,volm,rate) {
	dest.setVolume(volm);
	dest.playbackRate = rate;
}

//= CAMERA =====================//==============================================

//- Init Camera ----------------//----------------------------------------------
function initCamera(camera,cam_) {
	camera.position.z = -cam_.CamLLD.z;
	camera.rotation.y = cam_.CamAdj*DegRad;
	cam_.MshRot.add(camera);	// Attach to rotator
	// Common Changes
	cam_.CamLLD.copy(CamLLD[cam_.CamSel]);	// Restore Saved Values
	cam_.CamMMD.copy(CamMMD[cam_.CamSel]);	// In/Out - min, max, spd
	cam_.CamAdj = CamAdj[cam_.CamSel];		// Load Adjustment
	camera.rotation.y = cam_.CamAdj*DegRad;	// 180 = Looking in
	cam_.CamMMR.copy(CamMMR[cam_.CamSel]);	// Rotation min, max, spd
	cam_.Parent = CamPar[cam_.CamSel]		// Load New Parent
	cam_.Parent.add(cam_.MshRot);			// Attach Rotators
	cam_.IntFlg = CmIFlg[cam_.CamSel];		// 1 = cockpit
	cam_.CamLnk = CamLnk[cam_.CamSel];		// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);

}

//- Move Camera ----------------//----------------------------------------------
function moveCamera(camera,cam_) {
	// Move Camera In/Out
	camera.position.z = -cam_.CamLLD.z;
	// PointerLockControls
	if (cam_.OrbFlg) {
		cam_.CamLLD.x = cam_.CamLLD.x - InpMos.y * cam_.CamMMR.z; // Camera Position (Lat)
		cam_.CamLLD.x = MaxVal(cam_.CamLLD.x,cam_.CamMMR.x);
		cam_.CamLLD.y = Mod360(cam_.CamLLD.y + InpMos.x * cam_.CamMMR.z); // Camera Position (Lon)
		// Internal View
		if (cam_.IntFlg) {		// Range: 250 to 360/0 to 110
			if (cam_.CamLLD.y > 180 && cam_.CamLLD.y < (360-cam_.CamMMR.y)) cam_.CamLLD.y = (360-cam_.CamMMR.y);
			if (cam_.CamLLD.y < 180 && cam_.CamLLD.y > cam_.CamMMR.y) cam_.CamLLD.y = cam_.CamMMR.y;
		}
		// External View
		else {
			if (air_.GrdFlg && cam_.CamLLD.x > -12.5) cam_.CamLLD.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// Adjust Camera Rotators
	// In internal view, the camera is facing out - view matches rotation
	if (cam_.IntFlg) {
		cam_.MshRot.rotation.x = Mod360(cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(-cam_.CamLLD.y)*DegRad;
	}
	// In external view, the camera is facing in and the armature is pointing out:
	if (!cam_.IntFlg) {
		if (!cam_.OrbFlg && air_.GrdFlg) { // Air to Ground
			if (!CmGrdF) {		// if just landed
				CmLagX = CmAdjX; // All landings are smooth
//				if (CmLagX > 0.5) CmLagX = 0.5; // Make extreme landings more jarring
				CmGrdF = 1;
			}
			CmAdjX = CmLagX;	// From Landing Value to 0
		}	
		if (!cam_.OrbFlg && !air_.GrdFlg) { // Ground to Air
			if (CmGrdF) {		// if just took off
				CmLagX = CmMulX*air_.RotDif.x;
				CmGrdF = 0;
			}
			CmAdjX = (CmMulX*air_.RotDif.x)-CmLagX; // From 0 to Take-Off Value
		}
		if (CmLagX) {			// Reduce Lag
			CmLagX = 0.99*CmLagX; // Reduction in Adj/AdjOff
			if (Math.abs(CmLagX) < 0.1) CmLagX = 0;
		}
		camera.rotation.x = CmAdjX*DegRad; // + = up/airplane down
		cam_.MshRot.rotation.x = Mod360(-cam_.CamLLD.x)*DegRad;
		cam_.MshRot.rotation.y = Mod360(180-cam_.CamLLD.y)*DegRad;
	}
}

//= OUTPUTS ====================//==============================================

//-	Print HUD Values -----------------------------------------------------------
function prntHUDval() {
	Air_Pwr = Throtl;			// Throttle Setting
	Air_PwrNode.nodeValue = Air_Pwr.toFixed(2);
	Air_Spd = air_.SpdKPH*Km2Mil; // Speed
	Air_SpdNode.nodeValue = Air_Spd.toFixed(0);
	Air_Alt = air_.MapPos.y*Mtr2Ft;	// Altitude
	Air_AltNode.nodeValue = Air_Alt.toFixed(0);
	Air_Hdg = air_.AirRot.y;	// Heading
	Air_HdgNode.nodeValue = Air_Hdg.toFixed(0);
	Air_CfL = air_.CfLift;		// Cf Lift
	Air_CfLNode.nodeValue = Air_CfL.toFixed(4);
}

//-	Pause Text -----------------------------------------------------------------
function PawsText(){
	if (gen_.PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//-	Autopilot Text -------------------------------------------------------------
function AutoText(){
	if (air_.AutoOn) Air_AtPNode.nodeValue = "Autopilot On";
	else {Air_AtPNode.nodeValue = "AutoP: Press A";}
}

//- Info Text ------------------------------------------------------------------
function InfoText() {
	if (!gen_.InfoOn) onInfo0();
	else if (gen_.InfoOn == 1) onInfo1();
	else if (gen_.InfoOn == 2) onInfo2();
}

//	Info Off
function onInfo0(){
	On_Inf0Node.nodeValue = "Info : Press I";
	On_Inf1Node.nodeValue = "";
	On_Inf2Node.nodeValue = "";
	On_Inf3Node.nodeValue = "";
	On_Inf4Node.nodeValue = "";
	On_Inf5Node.nodeValue = "";
	On_Inf6Node.nodeValue = "";
	On_Inf7Node.nodeValue = "";
	On_Inf8Node.nodeValue = "";
}

//	Info On - Page1
function onInfo1(){
	On_Inf0Node.nodeValue = "";
	On_Inf1Node.nodeValue = "CONTROLS";
	On_Inf2Node.nodeValue = "Use Mouse to change Pitch and Bank";
	On_Inf3Node.nodeValue = "AutoPilot: Use Arrow Keys to change Pitch and Bank";
	On_Inf4Node.nodeValue = "Use Mouse Buttons or Z/X Keys to change Yaw";
	On_Inf5Node.nodeValue = "Use Mouse Wheel or -/= Keys to change Throttle";
	On_Inf6Node.nodeValue = "Press S to toggle sound";
	On_Inf7Node.nodeValue = "Spacebar fires guns";
	On_Inf8Node.nodeValue = "";
}

//	Info On - Page2
function onInfo2(){
	On_Info0Node.nodeValue = "";
	On_Inf1Node.nodeValue = "VIEW KEYS";
	On_Inf2Node.nodeValue = "Hold Shift and use Mouse to pan around aircraft";
	On_Inf3Node.nodeValue = "Press DELETE or PAGE DOWN to look left/right";
	On_Inf4Node.nodeValue = "Press HOME and the above to look up";
	On_Inf5Node.nodeValue = "Press END and DELETE or PAGE DOWN to look back";
	On_Inf6Node.nodeValue = "Press all 3 keys to look back";
	On_Inf7Node.nodeValue = "";
	On_Inf8Node.nodeValue = "";
}

//= INPUTS =====================================================================
// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//- MOUSE ----------------------------------------------------------------------

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		air_.RotDif.y = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		air_.RotDif.y = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		air_.RotDif.y = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		air_.RotDif.y = 0;
	}
}

//- Mousewheel -----------------------------------------------------------------
function onDocumentMouseWheel(event) {
	event.preventDefault();
	gen_.PwrDif = - event.deltaY * gen_.PwrMul;	// Increment = 1%
	Throtl = Throtl + gen_.PwrDif;
	if (Throtl > 1) {
		Throtl = 1;
		gen_.PwrDif = 0;
	}
	if (Throtl < 0) {
		Throtl = 0;
		gen_.PwrDif = 0;
	}
}

//- KEYBOARD -------------------------------------------------------------------

//- Keyboard (Down) ------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == key_.PwLU) gen_.PwrDif = 0.1;	// Power Up - keyboard left
	if (event.keyCode == key_.PwLD) gen_.PwrDif = -0.1;	// Power Down - keyboard left
	if (event.keyCode == key_.PwRU) gen_.PwrDif = 0.1;	// Power Up - keyboard right
	if (event.keyCode == key_.PwRD) gen_.PwrDif = -0.1;	// Power Down - keyboard right
	if (event.keyCode == key_.BnkL) air_.InpKey.z = -KeyVal.z;	// Bank Left - autopilot only
	if (event.keyCode == key_.BnkR) air_.InpKey.z = KeyVal.z;	// Bank Right - autopilot only
	if (event.keyCode == key_.PitU) air_.InpKey.x = KeyVal.x;	// Pitch Up - autopilot only
	if (event.keyCode == key_.PitD) air_.InpKey.x = -KeyVal.x;	// Pitch Down - autopilot only
	if (event.keyCode == key_.YwLL) air_.RotDif.y = -KeyVal.z;	// YawL - keyboard left
	if (event.keyCode == key_.YwLR) air_.RotDif.y = KeyVal.z;	// YawR - keyboard left
	if (event.keyCode == key_.YwRL) air_.RotDif.y = -KeyVal.z;	// YawL - keyboard right
	if (event.keyCode == key_.YwRR) air_.RotDif.y = KeyVal.z;	// YawR - keyboard right
	if (event.keyCode == key_.Brak) gen_.InpBrk = 0.01;	// Brakes
	// Views
	if (event.keyCode == key_.VU45) key_.D45flg = 1;	// View - 45 deg up
	if (event.keyCode == key_.VD45) key_.U45flg = 1;	// View - 45 deg down
	if (event.keyCode == key_.VL45) key_.L45flg = 1;	// View - 45 deg left
	if (event.keyCode == key_.VR45) key_.R45flg = 1;	// View - 45 deg right
	if (event.keyCode == key_.VL90) key_.L90flg = 1;	// View - 90 deg left
	if (event.keyCode == key_.VR90) key_.R90flg = 1;	// View - 90 deg right
	if (event.keyCode == key_.Look) cam_.OrbFlg = 1;	// Orbit
	// Guns
	if (event.keyCode == key_.Guns) {					// Guns
		if (!gen_.PawsOn) {
			for (let n = 0; n < myg_.ObjNum; n ++) {
				if (gen_.SndFlg && !myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].play();
			}
		};
		gen_.MYGFlg = 1;
	}
	// Toggle
	if (event.keyCode == key_.Paws) toglPaws();			// Toggle Pause
	if (event.keyCode == key_.Auto) toglAuto();			// Toggle AutoPilot
	if (event.keyCode == key_.Info) toglInfo();			// Toggle Information
	if (event.keyCode == key_.Soun) toglSoun();			// Toggle Sound
}

//-	Keyboard (Up) --------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == key_.PwLU) gen_.PwrDif = 0;	// Power Up - keyboard left
	if (event.keyCode == key_.PwLD) gen_.PwrDif = 0;	// Power Down - keyboard left
	if (event.keyCode == key_.PwRU) gen_.PwrDif = 0;	// Power Up - keyboard right
	if (event.keyCode == key_.PwRD) gen_.PwrDif = 0;	// Power Down - keyboard right
	if (event.keyCode == key_.BnkL) air_.InpKey.z = 0;	// Bank Left - autopilot only
	if (event.keyCode == key_.BnkR) air_.InpKey.z = 0;	// Bank Right - autopilot only
	if (event.keyCode == key_.PitU) air_.InpKey.x = 0;	// Pitch Up - autopilot only
	if (event.keyCode == key_.PitD) air_.InpKey.x = 0;	// Pitch Down - autopilot only
	if (event.keyCode == key_.YwLL) air_.RotDif.y = 0;	// YawL - keyboard left
	if (event.keyCode == key_.YwLR) air_.RotDif.y = 0;	// YawR - keyboard left
	if (event.keyCode == key_.YwRL) air_.RotDif.y = 0;	// YawL - keyboard right
	if (event.keyCode == key_.YwRR) air_.RotDif.y = 0;	// YawR - keyboard right
	if (event.keyCode == key_.Brak) gen_.InpBrk = 0;	// Brakes
	// Views
	if (event.keyCode == key_.VU45) key_.D45flg = 0;	// View - 45 deg up
	if (event.keyCode == key_.VD45) key_.U45flg = 0;	// View - 45 deg down
	if (event.keyCode == key_.VL45) key_.L45flg = 0;	// View - 45 deg left
	if (event.keyCode == key_.VR45) key_.R45flg = 0;	// View - 45 deg right
	if (event.keyCode == key_.VL90) key_.L90flg = 0;	// View - 90 deg left
	if (event.keyCode == key_.VR90) key_.R90flg = 0;	// View - 90 deg right
	if (event.keyCode == key_.Look) cam_.OrbFlg = 0;	// Orbit
	// Guns
	if (event.keyCode == key_.Guns) {					// Guns
		for (let n = 0; n < myg_.ObjNum; n ++) {
			myg_.SndPtr[n].stop();
		}
		if (!gen_.PawsOn) {
			for (let n = 0; n < myg_.ObjNum; n ++) {
				if (myg_.SndPtr[n].isPlaying) myg_.SndPtr[n].stop();
			}
		};
		gen_.MYGFlg = 0;
	}
}

//- Subroutines ----------------------------------------------------------------

//. Toggle Pause ...............................................................
function toglPaws() {
	gen_.PawsOn = 1 - gen_.PawsOn;
	if ( gen_.PawsOn && gen_.SndFlg) stopSounds();	// Sounds On to Off
	if (!gen_.PawsOn && gen_.SndFlg) playSounds();	// Sounds Off to On
	PawsText();
}

//. Toggle AutoPilot ...........................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................................................................
function toglInfo() {
	gen_.InfoOn++
	if (gen_.InfoOn == 3) gen_.InfoOn = 0;
	InfoText();
}

//. Toggle Sound ...............................................................
function toglSoun() {
	if (!gen_.PawsOn) {			// If not paused
		gen_.SndFlg = 1 - gen_.SndFlg;	// Switch flag
		if (gen_.SndFlg)  playSounds();	// Off to On
		if (!gen_.SndFlg) stopSounds();	// On to Off
	}
}

//= WINDOW RESIZE ==============//==============================================
function onWindowResize() {
	CamAsp = window.innerWidth/window.innerHeight;
	camera.aspect = CamAsp;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>