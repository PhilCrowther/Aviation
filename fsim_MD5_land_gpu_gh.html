<!doctype html>
<html>

<!--
/*******************************************************************************
*
*	FSIM UH1 LAND GPU
*
********************************************************************************

Copyright 2017-26, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 25 Feb 2026

A flight simulation of an animated helicopter model over procedural land using WebGPU
-->

<head>
<title>fsim MD5 land gpu r183.1</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Power%: <span id="Air_Pwr"></span> %</div>
		<div>Height: <span id="AC_Hite"></span> ft</div>
		<div>ACPtch: <span id="AC_Ptch"></span> deg</div>
		<div>SpeedZ: <span id="AC_SpdZ"></span> mph</div>
		<div>ACBank: <span id="AC_Bank"></span> deg</div>
		<div>SpeedX: <span id="AC_SpdX"></span> mph</div>	
		<div>Headng: <span id="AC_Head"></span> deg</div>
		<div>DirFly: <span id="AC_DFly"></span> deg</div>
	</div>
	<div class="overlay2">
		<p>
		<div><span id="On_Paws"></span></div>
		<div><span id="On_Info01"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
		<div><span id="On_Info05"></span></div>
		<div><span id="On_Info06"></span></div>
		<div><span id="On_Info07"></span></div>
		<div><span id="On_Info08"></span></div>
		<div><span id="On_Info09"></span></div>
		</p>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
			"three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
			"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/"
		}
	}
</script>

<script type="module">

/*******************************************************************************
*
*	PROGRAM
*
*******************************************************************************/

//= LOAD MODULES ===============================================================
//- Basic Modules --------------------------------------------------------------
import * as THREE from "three";
import {color,float,texture} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement} from "three/addons/objects/LensflareMesh.js";
import Stats from "three/addons/libs/stats.module.js";
// Special Modules
import {initCamera,moveCamera,	// camera
	} from "https://PhilCrowther.github.io/Aviation/jsm/Controls2.js";
import {loadGrdMat,initGrdMat,GrdMap,
		initRoads,moveRoads,
		loadTreLin,moveTreLin
	} from "https://PhilCrowther.github.io/Aviation/jsm/GrdLnd.js"; // r171

//= GENERAL ====================================================================

//	This flight simulation demo uses the most advanced version of three.js

//= CONTROLS
//	This simulation primarily relies on mouse controls:
//	* Mouse wheel sets altitude (like the throttle/collective control in a real helicopter)
//	* Mouse movement changes direction (like the cyclic control in a real helicopter)
//	* Mouse buttons cause yaw left/right (like tail rotor in real helicopter)

//=	SIMPLIFICATIONS
//	A Helicopter is extremely difficult to fly. Your "pilot personna" will handle the following:
//	* Adjust power for changes in collective.
//	* Adjust power/collective to maintain altitude in horizontal flight.
//  * Adjust tail rotor to offset changes in power/collective.

//=	TO DO:
//-	Flight Module:
//	* Fix Weathervane adjustment (YawAdj)
//	* Allow for greater pitch and bank adjustments where excess thrust available.
//	* Reduce excess thrust available as altitude increases.
//	* Reduce/increase excess thrust available as climb/descend

/*******************************************************************************
*
*	VARIABLES
*
*******************************************************************************/

//= INPUTS =====================//==============================================
let BegCam = 0;					// 0 = External; 1 = Internal (default)
//- Starting Values ------------------------------------------------------------
let BegPwr = 0;					// Initial Power Percent
let BegSpd = 0;					// Speed (kph)
let BegRot = new THREE.Euler(0,0,0); // Position (degrees) ### new
let BegPos = new THREE.Vector3(0,0,0); // Position (meters)
let CamSel = 0;					// Camera Seletion (0 = External; 1 = Internal)
//- Mouse Input Adjustments ----------------------------------------------------
let	MosMul = new THREE.Vector3(1,1,1); // Adjustment to PYBmul (default = 1)
let PYBmul = new THREE.Vector3(0.004,1.0,0.001);
let AltMul = 0.0001;			// Power % Input - Mouse Multiplier
let RotMax = new THREE.Vector3(1,1,1);
//- Mouse Input Delays ---------------------------------------------------------
//- (x = diverted, y = released, z = stored)
let PwrMsD = new THREE.Vector3(1-1/30,1/15,0);	// Power
let PitMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
let BnkMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- Key Input Variables --------------------------------------------------------
let KeyVal = new THREE.Vector3(0.5,0.4,0.5); // Key Values
let InpAlt = 0;					// Input Altitude
let InpACP = 0;					// Input Pitch
let InpACB = 0;					// Input Bank
let InpYaw = 0;					// Input Yaw
//- Power/Thrust Adjustments ---------------------------------------------------
let ThrMlt = 1.25;				// Thrust to Weight Ratio
let ThrAdj = new THREE.Vector3(1/60,1,1/60); // Limits ZX Acceleration/Speed

//- POINTER LOCK CONTROLS ------------------------------------------------------
let InpMos = new THREE.Vector2();	// Inputs - Mouse
let _changeEvent = {type: "change"};
let _lockEvent = {type: "lock"};
let _unlockEvent = {type: "unlock"};

//= 1. MAIN VARIABLES ==========//==============================================

//- CONSTANTS ------------------//----------------------------------------------
//	Time
let	DLTime = 1/60;				// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;		//
//	Conversions
let DegRad = Math.PI/180;		// Convert Degrees to Radians
let RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Ft2Mtr = 0.3048;			// Convert Feet to Meters
let Mtr2Ft = 1/0.3048;
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//	Default Constants
let AirDen = 1.225;				// (kg/m3)
//	Starting Constants per frame
let BegTmp = 288.15;			// K = 59F
//	Misc
let quaternion = new THREE.Quaternion();
//
let GrvMPS = 9.80665;

//- GENERAL VARIABLES ----------//----------------------------------------------
let gen_ = {
		// General
		scene:  0,				// Scene
		render: 0,				// Renderer
		imagLd: 0,				// Image Loader
		txtrLd: 0,				// Texture Loader
		cubeLd: 0,				// Cube Loader
		gltfLd: 0,				// GLTF Loader
		//- Display
		PawsOn:	0,				// Pause
		StatOn:	1,				// Stats (0 = off, 1 = on)
		LnFFlg:	1,				// Lensflare
		// Program Flags
		LodFlg:	0,				// Set at end of initialization
		LodSnd: 0,
		// Altitude Adjustment
		AltAdj:	0.99,			// Raises objects above map as altitude increases
		AltDif:	0,
		// Misc
		MaxAni: 0,				// MaxAnisotropy
		// Canvas
		contxt: 0,
		canvas: 0,
	}

let tim_ = {
		DLTime: 1/60,
	}

//= 2. SKY VARIABLES ===========//==============================================
let sky_ = {
		// Sun
		SunCol: "white",		// Sun
		SunInt: 4,				// Use 4 to overcome darkness of DifTxt
		// Fog
		FogCol: 0xbab4a6,		// Sky (for Fog only)
		// SkyBox
		SBxSrc: "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/",
		envMap: 0,				// For this SkyBox
		// Sun (position in SkyBox)
		SunLat: 23,				// Direction - Vert (+/- 90) deg
		SunLon: 312,			// Direction - Horz (0->360) deg
		// LensFlare		
		LF0Src: "https://PhilCrowther.github.io/Aviation/textures/fx/lensflare1.png",
		LF1Src: "https://PhilCrowther.github.io/Aviation/textures/fx/lensflare3.png",
		LF0Txt: 0,
		LF1Txt: 0,
		// Shadow Beg Info
		SunDst: 50,				// Distance
		ShdBox: 6,				// Size of shadow box
		ShdBLR: 6.5,
		ShdBTB: 4,
		ShdDst: 1500,			// Shadow Distance (meters)
	}

//= SUN VALUES =================//==============================================
let SunSph = new THREE.Spherical(sky_.SunDst,(90-sky_.SunLat)*DegRad,Mod360(180-sky_.SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);

//= STANDARD SETUP =============//==============================================
//- Scene
let scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
//- Light
let ambLight = new THREE.AmbientLight(sky_.SunCol,0.2);
	scene.add(ambLight);
//- SunLight
let sunLight = new THREE.DirectionalLight(sky_.SunCol,sky_.SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = sky_.SunDst*0.75;
	sunLight.shadow.camera.far = sky_.SunDst+sky_.ShdDst+sky_.ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -sky_.ShdBLR;
	sunLight.shadow.camera.right = sky_.ShdBLR;
	sunLight.shadow.camera.top = sky_.ShdBTB;
	sunLight.shadow.camera.bottom = -sky_.ShdBTB;
	sunLight.shadow.bias = -0.0002; // WebGPU (0 flashing; -0.0001 no wheels)
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
let camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//- Renderer
let renderer = new THREE.WebGPURenderer({antialias: true});	// r168
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.BasicShadowMap;
	renderer.logarithmicDepthBuffer = true;
	document.body.appendChild(renderer.domElement);
	gen_.MaxAni = renderer.getMaxAnisotropy();
	await renderer.init();		// Allows time for backend to initialize
//- Timer
let	timer = new THREE.Timer();	// r183
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	// Window Resize
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
	gen_.txtrLd = new THREE.TextureLoader(loadingManager);
	gen_.imagLd = new THREE.ImageLoader(loadingManager);
	gen_.cubeLd = new THREE.CubeTextureLoader(loadingManager);
	gen_.gltfLd = new GLTFLoader(loadingManager);
	gen_.audoLd = new THREE.AudioLoader();
//- Create Audio Listener
let	listener = new THREE.AudioListener();
	camera.add(listener);
//- Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= MODULES - General ==========//==============================================
	gen_.scene  = scene;
	gen_.render = renderer;
	gen_.camera = camera;
	gen_.listnr = listener;

//= GROUND TEXTURES ============//==============================================
//- Canvas
let ImgSiz = 1024;
	gen_.canvas = document.createElement("canvas");
	gen_.canvas.width = ImgSiz;
	gen_.canvas.height = ImgSiz;
	gen_.contxt = gen_.canvas.getContext("2d",{willReadFrequently: true});

//= GRID MODULE ================//==============================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let grids = 0;
let grd_ = {
		SPS: new THREE.Vector3(), // MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,				// Squares in each of first 2 grids
		Siz: 804.67,			// Size of smallest square (1/4 section = 1/2 mile)
		Stp: 3,					// Squares in each of first 2 grids
		Grx: [],				// Index of Grids (0-2)
		Idx: [0],				// Index to Patterns
		Mat: [0],				// Index to Materials
		// Texture Modifiers
		DfT: ["https://PhilCrowther.github.io/Aviation/scenery/textures/transition1F2.jpg",
			  "https://PhilCrowther.github.io/Aviation/scenery/textures/transition1G2.jpg",
			  "https://PhilCrowther.github.io/Aviation/scenery/textures/transition1G3.jpg"],
		DfM: [0.8,0.8],			// Darken outer grids to match inner grid [transition1G2]
	}

//= OBJECTS ====================//==============================================
//- Distances in Meters
let ObjNum = 2;					// number of objects
let ObjTyp = [0];				// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];				// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];				// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];				// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];				// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];				// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];				// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];				// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
//- Hangars
	ObjTyp[ObjIdx] = 0;			// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 1000;		// [m]
	ObjMPY[ObjIdx] = Ft2Mtr;	// [m] 1 ft
	ObjMPZ[ObjIdx] = 1524;		// [m] 5000 ft
	ObjIdx = ObjIdx + 1;
//- Giaros Island
	ObjTyp[ObjIdx] = 1;			// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/textures/giaros.jpg";
	ObjMPX[ObjIdx] = -1609.344;	// [m] 1 mile
//	ObjMPY[ObjIdx] = 2*Ft2Mtr;	// [m] 2 ft
	ObjMPY[ObjIdx] = -50;		// [m]
	ObjMPZ[ObjIdx] = 8046.72;	// [m] 5 miles
	
//= MY HELICOPTER ==============//==============================================
let air_ = {
		// General Variables
		DLTime: DLTime,			// Seconds per frame (can vary)
		AirDSL: AirDen,			// Air Density (varies with altitude)
		// Helicopter Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Euler().copy(BegRot), // Rotation (in degrees)
		AirObj: new THREE.Object3D,
		AirPBY: new THREE.Object3D,
		OldRot: new THREE.Euler(), // Old Rotation (radians)
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(), // Change
		RotMax: new THREE.Vector3().copy(RotMax),
		// Airplane Speed
		SpdKPH: BegSpd,			// Total Speed - KPH [computed, but not used]
		SpdMPS: BegSpd/3.6,		// Total Speed - meters per second [computed, but not used]
		AirSpd: new THREE.Vector3(), // Airspeed (mps)
		// Airplane Map Speed and Position
		DirFlt: BegRot.y,
		MapSpd: new THREE.Vector3(), // Map Speed (mpf)
		MapPos: new THREE.Vector3(), // Map Position (meters)
		MapSPS: new THREE.Vector3(), // MSX, MPY, MSZ (meters)
		// Variables
		PwrPct: BegPwr,			// % of Primary Power (0 to 1) (Main and Flight)
		PYBmul: new THREE.Vector3().copy(PYBmul), // Airplane Pitch/Yaw/Bank Multiplier
		// Variables Obtained from Flight
		GrdZed: 0,				// Ground level (default)
		GrdFlg: 0,				// Ground Flag (1 = on ground)
		ACPAdj: 0,				// Airplane pitch adjustment
		MovFlg: 0,				// If Sitting on a Moving Object
		// Variables Obtained from Data
		ThrMlt: ThrMlt,			// Thrust to Weight Ratio
		ThrAdj: new THREE.Vector3().copy(ThrAdj),
		MaxAng: 60,				// Max Rotor and Body Angle (deg) [not used]
		MaxKPH: 217.26,			// Max Speed (mph = 135 mph) [not used]
		MinAng: 15,				// Min Rotor and Body Angle (deg) to main MaxKPH
		ACMass: 1364,			// Aircraft Mass (kg = 3000 lb / 2.2)
		Weight: 13345,			// N (= 3000 lbs)
		FrntAr: 1.951,			// Frontal Area (m2 = 21 ft2)
		DrgCdz: 1.94,			// Coefficient of Drag (z-direction)
		DrgCdx: 43.525,			// Coefficient of Drag (x-direction)
		MdlAlt: 1.65,			// Model Center Height above Ground (meters)
		// Rotor
		RtrAng: new THREE.Vector3(), // Rotor Pitch/Bank
		RtrDif: new THREE.Vector3(), // Change in Rotor Pitch/Bank
		RtrOld: new THREE.Vector3(), // Old Rotor PitchBank
	}
	
//- Load Models and Animations -------------------------------------------------
//-	File Path
let AirSrc = "https://PhilCrowther.github.io/Aviation/models/md5/";	// Used to load models and sounds
let mxrFNm = "md5.glb"; // Name of airplane model file (rotated blender file)
let vxrFNm = "md5_int.glb"; // Name of airplane model file (rotated blender file)

//- Aircraft Animations --------------------------------------------------------
let	anmfps = 24;				// Blender FPS (used by Main Program and all modules (used by Objects.js)
//	Animation Positions (all range from 0 to 360 with center at 180)
let anm_ = {
		pitprp: 180,			// Main Rotor - Pitch
		bnkprp: 180,			// Main Rotor - Bank
		spnprp: 180,			// Main Rotor - Spin
		spnrtr: 180,			// Tail Rotor - Spin
}
//	Animation Mixers - External Model
let mxr_ = {
		// Source
		Src: AirSrc + mxrFNm,
		// Address
		Adr: 0,
		//
		RtrB: 0,				// Main Rotor - Blades
		RtrP: 0,				// Main Rotor - Pitch
		RtrK: 0,				// Main Rotor - Bank
		RtrV: 0,				// Main Rotor - Vertical
		RtrT: 0,				// Tail Rotor
	}
//	Animation Mixers - Internal Model
let vxr_ = {
		// Source
		Src: AirSrc + vxrFNm,
		// Address
		Adr: 0,
		//
		RtrB: 0,				// Main Rotor - Blades
		RtrP: 0,				// Main Rotor - Pitch
		RtrK: 0,				// Main Rotor - Bank
		RtrV: 0,				// Main Rotor - Vertical
		RtrT: 0,				// Tail Rotor
	}

//=	SOUNDS =====================//==============================================
let mys_ = {
		// General
		RefDst: 25,				// Reference distance for Positional Audio		
		// Engine
		EngSrc: AirSrc + "sounds/" + "md5.wav",
		EngSnd: new THREE.PositionalAudio(gen_.listnr),
		EngMsh: new THREE.Object3D,
		EngVol: 0.1,			// Volume
	}
	air_.AirObj.add(mys_.EngMsh);

//= DEFAULT KEY BINDINGS =======//==============================================
let key_ = {
		// WASD
		PitU: 83,				// Pitch up (s)
		PitD: 87,				// Pitch down (w)
		BnkL: 65,				// Bank Left (a)
		BnkR: 68,				// Bank Right (d)
		// Arrow Keys (Override WASD)
		PitU: 40,				// Pitch up (down arrow)
		PitD: 38,				// Pitch down (up arrow)
		BnkL: 37,				// Bank Left (left arrow)
		BnkR: 39,				// Bank Right (right arrow)
		// Collective and Cyclic
		AltU: 81,				// Altitude Up (q)
		AltD: 69,				// Altitude Dn (e)
		YawL: 90,				// Yaw Left (z)
		YawR: 88,				// Yaw Right (x)
		//	View
		Look:	 16,			// Orbit (shift)
		// View Keys (Keypad Num Lock)
		KPad: 0,				// 1 = Using KeyPad
//		VR45: 105,				// [9] Right 45 deg
//		VU45: 104,				// [8] View Up 45 deg
//		VL45: 103,				// [7] Left 45 deg (315 deg)
//		VR90: 102,				// [6] Right 90 deg
//		VD45: 101,				// [5] View Down or Back 45 deg
//		VL90: 100,				// [4] Left 90 deg (270 deg)
//		VRBk: 99,				// [3] Right Back (135 deg)
//		VCBk: 98,				// [2] Center Back (180 deg)
//		VLBk: 97,				// [1] Left Back (225 deg)
		// Views (Override Keypad)
		VR45: 45,				// [INS] Right 45 degrees 
		VU45: 36,				// [HM]  View Up (alone or modifier)
		VL45: 33,				// [PU]  Left 45 degrees
		VR90: 46,				// [DEL] Right 90 degrees
		VD45: 35,				// [END] View Down (alone or modifier)
		VL90: 34,				// [PD]  Left 90 degrees
		// Toggle
		View: 86,				// Toggle Visibility (v)
		Soun: 79,				// Toggle sound (o)
		Info: 73,				// Info (i)
		Paws: 80,				// Pause (p)
		// Flags
		U45flg:	0,				// Up 45 deg
		D45flg:	0,				// Down 45 deg
		L45flg:	0,				// Left 45 deg (315 deg)
		R45flg:	0,				// Right 45 deg
		L90flg:	0,				// Left 90 deg (270 deg)
		R90flg:	0,				// Right 90 deg
		LBkflg:	0,				// Left Back 45 deg (225 deg)
		RBkflg:	0,				// Right Back 45 deg (135 deg)
		CBkflg:	0,				// Center Back (180 degrees)
}

//= 7. CAMERA VARIABLES ========//==============================================
//	Only Two Views: 0 = External; 1 = Internal			
//- Shared Variables
let cam_ = {
		CamSel: 0,				// View Selector (0 = External, 1 = Internal)
		OrbFlg: 0,				// Orbit Flag (1 = Orbiting)
		// Camera
		CamLLD: 0, 				// cam_.MshRot Lat, Lon, Dst
		CamAdj: 0,				// Camera Adjustment (180 = look in)
		CamMMD: 0,				// In/Out - min,max,spd
		// Rotator
		MshRot: 0,				// Camera Rotator
		CamMMR: 0,				// Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		CamPar: 0,				// Center of Rotation	
		CamFlg: 0,				// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		CamLnk: 0,
		MshObj: 0,
		MshDeg: 0,
		//- Camera Vertical Lag
		LagFlg: 0,				// 1 = Enable
		CmAdjX: 0,				// Airborne Pitch Adjustment
		CmMulX: 35,				// Pitch Adjustment Multiplier
		CmLagX: 0,				// Transition Offset
		CmGrdF: 0,				// Camera Ground Flag (1 = On Ground)
		// Beginning Head Rotation
		VewRot: 0,
		//- Source
		SrcLLD: [0,0],
		SrcMMD: [0,0],
		SrcMMR: [0,0],
		SrcPar: [0,0],
		SrcAdj: [180,0],
		SrcFlg: [0,1],			// 1 = Internal View
		SrcLnk: [1,1],			// 1 = Linked to Airplane
	}

//- Create Internal Attach Point
const CamPVC = new THREE.Object3D;
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(-0.3674,0.35,-0.6);	// Internal View
	air_.AirPBY.add(CamPVC); 	// Attach CamPVC to AirPBY (### not AirObj)
//- Camera Inputs (External Camera linked to air_.AirPBY; 1 Internal Camera Linked to cam_.PVC)
	cam_.SrcLLD = [new THREE.Vector3(-2.5,0,15),new THREE.Vector3(0,0,0.001)];
	cam_.SrcMMD = [new THREE.Vector3(cam_.SrcLLD[0].z*0.5,cam_.SrcLLD[0].z*2.0,0.1),new THREE.Vector3(0,1,0.001)]; // In/Out - min,max,spd
	cam_.SrcMMR = [new THREE.Vector3(80,0,0.5),new THREE.Vector3(45,110,0.5)]; // Rotate - min/max Lat/Lon,rspd			   
	cam_.SrcPar = [air_.AirObj,CamPVC];
//- Objects --------------------------------------------------------------------
	cam_.MshRot = new THREE.Object3D;	// Camera Rotator
	cam_.MshRot.rotation.order = "YXZ";
	cam_.MshRot.add(camera);	// Attach camera to rotator	
	cam_.MshObj = new THREE.Object3D;
	cam_.MshObj.rotation.order = "YXZ";
	cam_.MshDeg = new THREE.Object3D;
	cam_.MshDeg.rotation.order = "YXZ";
	cam_.MshObj.add(cam_.MshDeg);
//- Adjustments ----------------------------------------------------------------
	cam_.CamSel = BegCam;
	cam_.CamPar = cam_.SrcPar[cam_.CamSel];	// Center of Rotation
	cam_.CamPar.add(cam_.MshRot); // Attach Rotator

//= POINTER LOCK CONTROL =======================================================
class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.addEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener("pointerlockerror", onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//- Setup ----------------------------------------------------------------------
let controls = new PointerLockControls(camera, renderer.domElement);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener("unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

//= HTML OVERLAY TEXT ==========================================================
let Air_PwrElement = document.getElementById("Air_Pwr"); // Power
let Air_PwrNode = document.createTextNode("");
	Air_PwrElement.appendChild(Air_PwrNode);
let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
	AC_HiteElement.appendChild(AC_HiteNode);
let AC_PtchElement = document.getElementById("AC_Ptch");
let AC_PtchNode = document.createTextNode("");
	AC_PtchElement.appendChild(AC_PtchNode);
let AC_SpdZElement = document.getElementById("AC_SpdZ");
let AC_SpdZNode = document.createTextNode("");
	AC_SpdZElement.appendChild(AC_SpdZNode);
let AC_BankElement = document.getElementById("AC_Bank");
let AC_BankNode = document.createTextNode("");
	AC_BankElement.appendChild(AC_BankNode);
let AC_SpdXElement = document.getElementById("AC_SpdX");
let AC_SpdXNode = document.createTextNode("");
	AC_SpdXElement.appendChild(AC_SpdXNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
	AC_HeadElement.appendChild(AC_HeadNode);
let AC_DFlyElement = document.getElementById("AC_DFly");
let AC_DFlyNode = document.createTextNode("");
	AC_DFlyElement.appendChild(AC_DFlyNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
	On_PawsElement.appendChild(On_PawsNode);
let On_Info01Element = document.getElementById("On_Info01");
let On_Info01Node = document.createTextNode("");
	On_Info01Element.appendChild(On_Info01Node);
let On_Info02Element = document.getElementById("On_Info02");
let On_Info02Node = document.createTextNode("");
	On_Info02Element.appendChild(On_Info02Node);
let On_Info03Element = document.getElementById("On_Info03");
let On_Info03Node = document.createTextNode("");
	On_Info03Element.appendChild(On_Info03Node);
let On_Info04Element = document.getElementById("On_Info04");
let On_Info04Node = document.createTextNode("");
	On_Info04Element.appendChild(On_Info04Node);
let On_Info05Element = document.getElementById("On_Info05");
let On_Info05Node = document.createTextNode("");
	On_Info05Element.appendChild(On_Info05Node);
let On_Info06Element = document.getElementById("On_Info06");
let On_Info06Node = document.createTextNode("");
	On_Info06Element.appendChild(On_Info06Node);
let On_Info07Element = document.getElementById("On_Info07");
let On_Info07Node = document.createTextNode("");
	On_Info07Element.appendChild(On_Info07Node);
let On_Info08Element = document.getElementById("On_Info08");
let On_Info08Node = document.createTextNode("");
	On_Info08Element.appendChild(On_Info08Node);
let On_Info09Element = document.getElementById("On_Info09");
let On_Info09Node = document.createTextNode("");
	On_Info09Element.appendChild(On_Info09Node);

let Air_Pwr,AC_Hite,AC_Ptch,AC_SpdZ,AC_Bank,AC_SpdX,AC_Head,AC_DFly,On_Paws, 
	On_Info01,On_Info02,On_Info03,On_Info04,On_Info05,On_Info06,On_Info07,On_Info08,On_Info09;

/*******************************************************************************
*
*	1. MAIN PROGRAM
*
*******************************************************************************/

	loadAll();

//=	0 LOAD ALL =================//==============================================

function loadAll() {
	WaitScreen();				// init loading screen
	loadSkyBox();
	loadGrdMat(grd_,gen_);	
	loadTreLin(grd_,gen_);
	loadAirObj();
	loadObject();
	// Load stats
	if (gen_.StatOn) {			// show stats
		gen_.StatOn = new Stats();
		document.body.appendChild(gen_.StatOn.dom);
		gen_.StatOn.domElement.style.cssText = "position:absolute;top:90%;left:95%;";
	}
	loadSounds();
}

//= WAIT SCREEN ================//==============================================

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = gen_.txtrLd.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 INITIALIZE ================//==============================================

function initAll() {
	initSkyBox();				// load skybox
	initAirObj();
	gen_.AltDif = air_.MapPos.y*gen_.AltAdj; // Used by everything
	initGrdMat(grd_,gen_);
	grd_.SPS.y = air_.MapPos.y;	// Init Position
	grids = new GrdMap(grd_,gen_);	// Init Grid Map
	grids.update(grd_);			// Mode Grid Map
	initRoads(grd_,gen_);
	moveTreLin(grd_,gen_,air_); // Add TreeLines
	initObject();				// Stationary Objects
	// Other
	initCamera(cam_,air_,key_,gen_,mxr_,vxr_,InpMos); // position camera
	PawsText();
	InfoText();
	gen_.LodFlg = 1;
}

//= 2 RENDER ===================//==============================================

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;					// Stop the function here.
	}
	if (controls.isLocked === true && !gen_.LodSnd) {
		loadSounds();
	}
	if (!gen_.PawsOn && gen_.LodFlg && controls.isLocked === true) {
		moveCamera(cam_,air_,key_,gen_,InpMos);
		// Move AirObj
		moveAirObj();
		// Move Objects
		grd_.SPS.copy(air_.MapSPS);	// Update Position
		grids.update(grd_);		// Mode Grid Map
		moveRoads(grd_,gen_);
		moveTreLin(grd_,gen_,air_); // Add TreeLines		
		moveObject();			// Move objects
		moveSounds();
		prntHUDval();			// change HUD value
		if (gen_.StatOn) gen_.StatOn.update(); // update stats
	}
	if (controls.isLocked === false && gen_.LodSnd) {
		stopSounds();
		gen_.SndFlg = 0;
	}
	renderer.render(scene,camera);
}

/*******************************************************************************
*
*	2. SKY
*
*******************************************************************************/

function loadSkyBox() {
	let envMap = gen_.cubeLd
		.setPath(sky_.SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	// LensFlare
	if (gen_.LnFFlg) {				// SunFlare	
		sky_.LF0Txt = gen_.txtrLd.load(sky_.LF0Src);
		sky_.LF1Txt = gen_.txtrLd.load(sky_.LF1Src);
	}
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(sky_.FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (gen_.LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);	
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(sky_.LF0Txt,256,0));
			LF.addElement(new LensflareElement(sky_.LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(sky_.LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

/*******************************************************************************
*
*	4. OBJECTS
*
*******************************************************************************/
//= These objects include the airfield, mountains and hangar

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gen_.gltfLd.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = gen_.txtrLd.load(ObjTxt[i]);
			texture.anisotropy = gen_.MaxAni;
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gen_.gltfLd.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(32000*Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*gen_.AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*gen_.AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

/*******************************************************************************
*
*	5. HELICOPTER
*
*******************************************************************************/

//= LOAD AIRPLANE ==============//==============================================

function loadAirObj() {
	loadAirExt(air_,mxr_,anm_,gen_);
	loadAirInt(air_,mxr_,anm_,gen_);
}

//- LOAD EXTERNAL ==============//==============================================

function loadAirExt(air_,mxr_,anm_,gen_) {
	gen_.gltfLd.load(mxr_.Src, function (gltf) {
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (
				child.name == "int_glass"		||
				child.name == "int_glass_grn"	||
				child.name == "ixt_controls"	||
				child.name == "ixt_seats2")
			{
				child.castShadow = false;
				child.receiveShadow = false;
			}
		});
		mxr_.Adr = gltf.scene;
		mxr_.Adr.rotation.order = "YXZ";
		// Animations ----------------------------------------------------------
		// Main Rotor - Bank
		let clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_bankAction");
		mxr_.RtrK = new THREE.AnimationMixer(mxr_.Adr);
		let actun = mxr_.RtrK.clipAction(clip);
		actun.play();
		if (mxr_.RtrK) mxr_.RtrK.setTime(anm_.bnkprp/anmfps);
		// Main Rotor - Pitch
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_pitchAction");
		mxr_.RtrP = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.RtrP.clipAction(clip);
		actun.play();
		if (mxr_.RtrP) mxr_.RtrP.setTime(anm_.pitprp/anmfps);
		// Main Rotor - Blades
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_bladesAction");
		mxr_.RtrB = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.RtrB.clipAction(clip);
		actun.play();
		if (mxr_.RtrB) mxr_.RtrB.setTime(anm_.spnprp/anmfps);
		// Main Rotor - Vertical
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_hubAction");
		mxr_.RtrV = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.RtrV.clipAction(clip);
		actun.play();
		if (mxr_.RtrV) mxr_.RtrV.setTime(anm_.spnprp/anmfps);	
		// Tail Rotor
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_tailAction");
		mxr_.RtrT = new THREE.AnimationMixer(mxr_.Adr);
		actun = mxr_.RtrT.clipAction(clip);
		actun.play();
		if (mxr_.RtrT) mxr_.RtrT.setTime(anm_.spnrtr/anmfps);
		//- Save
		air_.AirObj.add(mxr_.Adr);
		mxr_.Adr.visible = true;
	});
}

//- LOAD INTERNAL ==============//==============================================

function loadAirInt(air_,mxr_,anm_,gen_) {
	gen_.gltfLd.load(vxr_.Src, function (gltf) {
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (
				child.name == "int_glass"		||
				child.name == "int_glass_grn"	||
				child.name == "ixt_controls"	||
				child.name == "ixt_seats2")
			{
				child.castShadow = false;
				child.receiveShadow = false;
			}
		});
		vxr_.Adr = gltf.scene;
		vxr_.Adr.rotation.order = "YXZ";
		// Animations ----------------------------------------------------------
		// Main Rotor - Bank
		let clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_bankAction");
		vxr_.RtrK = new THREE.AnimationMixer(vxr_.Adr);
		let actun = vxr_.RtrK.clipAction(clip);
		actun.play();
		if (vxr_.RtrK) vxr_.RtrK.setTime(anm_.bnkprp/anmfps);
		// Main Rotor - Pitch
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_pitchAction");
		vxr_.RtrP = new THREE.AnimationMixer(vxr_.Adr);
		actun = vxr_.RtrP.clipAction(clip);
		actun.play();
		if (vxr_.RtrP) vxr_.RtrP.setTime(anm_.pitprp/anmfps);
		// Main Rotor - Blades
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_bladesAction");
		vxr_.RtrB = new THREE.AnimationMixer(vxr_.Adr);
		actun = vxr_.RtrB.clipAction(clip);
		actun.play();
		if (vxr_.RtrB) vxr_.RtrB.setTime(anm_.spnprp/anmfps);
		// Main Rotor - Vertical
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_hubAction");
		vxr_.RtrV = new THREE.AnimationMixer(vxr_.Adr);
		actun = vxr_.RtrV.clipAction(clip);
		actun.play();
		if (vxr_.RtrV) vxr_.RtrV.setTime(anm_.spnprp/anmfps);	
		// Tail Rotor
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotor_tailAction");
		vxr_.RtrT = new THREE.AnimationMixer(vxr_.Adr);
		actun = vxr_.RtrT.clipAction(clip);
		actun.play();
		if (vxr_.RtrT) vxr_.RtrT.setTime(anm_.spnrtr/anmfps);
		//- Save
		air_.AirObj.add(vxr_.Adr);
		vxr_.Adr.visible = false;
	});
}

//= INIT =======================//==============================================
function initAirObj() {
	initFlight();				// initalize variables
}

//= MOVE =======================//==============================================
function moveAirObj() {
	// Pitch ...................................................................
	let PitDif = InpMos.y * air_.PYBmul.x + InpACP;	
	// Add Delay
//	let gal = PitDif * PitMsD.x; // Current input delayed
//	let lag = PitMsD.z * PitMsD.y; // Released from Cumulator
//	PitMsD.z = PitMsD.z + gal - lag; // Change in Cumulator	
//	PitDif = PitDif - gal + lag;
	air_.RotDif.x = air_.RotDif.x + PitDif;
	// Set Max
	air_.RotDif.x = MaxVal(air_.RotDif.x,air_.RotMax.x); // Max Bank Change values
	if (air_.RotDif.x == air_.RotMax.x && PitDif < 0) air_.RotDif.x = PitDif;
	if (air_.RotDif.x == -air_.RotMax.x && PitDif > 0) air_.RotDif.x = PitDif;
	// Reset
	InpMos.y = 0;
	InpACP = 0;
	// Bank ....................................................................
	let BnkDif = InpMos.x * air_.PYBmul.z + InpACB;
	// Add Delay to Mouse Input
//	gal = BnkDif * BnkMsD.x; // Current input delayed
//	lag = BnkMsD.z * BnkMsD.y; // Released from Cumulator
//	BnkMsD.z = BnkMsD.z + gal - lag; // Change in Cumulator
//	BnkDif = BnkDif - gal + lag;
	air_.RotDif.z = air_.RotDif.z + BnkDif;
	// Set Max
	air_.RotDif.z = MaxVal(air_.RotDif.z,air_.RotMax.z); // Max Bank Change values
	if (air_.RotDif.z == air_.RotMax.z && BnkDif < 0) air_.RotDif.z = BnkDif;
	if (air_.RotDif.z == -air_.RotMax.z && BnkDif > 0) air_.RotDif.z = BnkDif;
	// Reset
	InpMos.x = 0;
	InpACB = 0;
	// Input Yaw ...............................................................
	air_.RotDif.y = InpYaw;
	// Compute Rotation and Vectors
	moveFlight();
	//- Animations --------------------------------------------------------------
	moveAirCom(air_,anm_);
	if (!cam_.CamFlg) { 		// External View
		// Rotors - Speed
		if (mxr_.RtrB) mxr_.RtrB.setTime(anm_.spnprp/anmfps); // Main Rotor Blades
		if (mxr_.RtrV) mxr_.RtrV.setTime(anm_.spnprp/anmfps); // Main Rotor Hub
		if (mxr_.RtrT) mxr_.RtrT.setTime(anm_.spnprp/anmfps); // Tail Rotor
		// Main Rotor Blades - Pitch
		if (mxr_.RtrP) mxr_.RtrP.setTime(anm_.pitprp/anmfps);
		// Main Rotor Blades - Bank
		if (mxr_.RtrK) mxr_.RtrK.setTime(anm_.bnkprp/anmfps);
	}
	if (cam_.CamFlg) { 			// Internal View
		// Rotors - Speed
		if (vxr_.RtrB) vxr_.RtrB.setTime(anm_.spnprp/anmfps); // Main Rotor Blades
		if (vxr_.RtrV) vxr_.RtrV.setTime(anm_.spnprp/anmfps); // Main Rotor Hub
		if (vxr_.RtrT) vxr_.RtrT.setTime(anm_.spnprp/anmfps); // Tail Rotor
		// Main Rotor Blades - Pitch
		if (vxr_.RtrP) vxr_.RtrP.setTime(anm_.pitprp/anmfps);
		// Main Rotor Blades - Bank
		if (vxr_.RtrK) vxr_.RtrK.setTime(anm_.bnkprp/anmfps);
	}
}

//- MOVE COMMON ANIMATION ------//----------------------------------------------

function moveAirCom(air_,anm_) {
	// Rotors - Speed
	anm_.spnprp = Mod360(anm_.spnprp - 33);
	// Main Rotor Blades - Pitch
	anm_.pitprp = 180 + air_.AirRot.x * 179 / 5;
	if (anm_.pitprp > 359) anm_.pitprp = 359; // Limit Max
	if (anm_.pitprp < 1) anm_.pitprp = 1; // Limit Min
	air_.RtrAng.x = 5*(anm_.pitprp-180)/180;
	air_.RtrDif.x = air_.RtrAng.x - air_.RtrOld.x;
	air_.RtrOld.x = air_.RtrAng.x;
	// Pitch - exclude first 5 degrees
	let PitDfR = PoM360(air_.RtrAng.x);
	if (PitDfR > 0) {
		PitDfR = PitDfR - 5;
		if (PitDfR < 0) PitDfR = 0;
	}
	if (PitDfR < 0) {
		PitDfR = PitDfR + 5;
		if (PitDfR > 0) PitDfR = 0;
	}
	air_.AirObj.rotation.x = Mod360(air_.AirObj.rotation.x * RadDeg - PitDfR) * DegRad; // Bank
	
	// Main Rotor Blades - Bank
	anm_.bnkprp = 180 + PoM360(air_.AirRot.z) * 179 / 5;
	if (anm_.bnkprp > 359) anm_.bnkprp = 359; // Limit Max
	if (anm_.bnkprp < 1) anm_.bnkprp = 1; // Limit Min
	air_.RtrAng.z = 5*(anm_.bnkprp-180)/180;
	air_.RtrDif.z = air_.RtrAng.z - air_.RtrOld.z;
	air_.RtrOld.z = air_.RtrAng.z;
		
	// Bank - exclude first 5 degrees
	let BnkDfR = PoM360(air_.RtrAng.z);
	if (BnkDfR > 0) {
		BnkDfR = BnkDfR - 5;
		if (BnkDfR < 0) BnkDfR = 0;
	}
	if (BnkDfR < 0) {
		BnkDfR = BnkDfR + 5;
		if (BnkDfR > 0) BnkDfR = 0;
	}
	air_.AirObj.rotation.z = Mod360(air_.AirObj.rotation.z * RadDeg + 360 - BnkDfR) * DegRad; // Bank
}

/*******************************************************************************
*
*	FLIGHT MODULE
*
*******************************************************************************/

function initFlight() {
	air_.AirObj.rotation.order = "YXZ";
	air_.AirPBY.rotation.order = "YXZ";
	air_.AirObj.add(air_.AirPBY); // PBY includes air_.ACPAdj
	scene.add(air_.AirObj);
	// Starting on Ground
	let MinAlt = air_.GrdZed + air_.MdlAlt; // Minimum Altitude (ASL = GL+AGL)
	landFlight(MinAlt);
	// Orientation -------------------------------------------------------------
	air_.AirObj.rotation.x = Mod360(air_.AirRot.x)*DegRad;	// Pitch
	air_.AirObj.rotation.y = Mod360(-air_.AirRot.y)*DegRad;	// Heading
	air_.AirObj.rotation.z = Mod360(360-air_.AirRot.z)*DegRad; // Bank
	//
	moveFlight();
}

//= MOVE =======================//==============================================
function moveFlight() {
// Inputs: air_.GrdFlg, GrdZed, air_.MapSpd.z, air_.AirRot.x, air_.AirRot.z
	// Compute Vectors
	DLTime = 1/60;				// Delta Time (1/60 seconds)
	DLTim2 = DLTime ** 2;
	let FrcAcc = DLTim2/air_.ACMass;
	if (air_.GrdFlg && (air_.ThrMlt*air_.PwrPct) > 1) air_.GrdFlg = 0;	// If going to leave ground
	if (!air_.GrdFlg) {			// Compute Change in mps, convert MapSpd to mpf
		// 1. Recompute and Load ZXY Airspeed (mpf) - since ACH (which redirects AirSpd.xz) may have changed
		// Use mps so that DynPrs and Drag is correct
		let ACHRad = air_.AirRot.y * DegRad;
		let PSpdZS = air_.MapSpd.z * Math.cos(-ACHRad) - air_.MapSpd.x * Math.sin(-ACHRad);
		let PSpdXS = air_.MapSpd.z * Math.sin(-ACHRad) + air_.MapSpd.x * Math.cos(-ACHRad);
		let PSpdYS = air_.MapSpd.y * air_.DLTime;
		// Convert to mps
		air_.AirSpd.z = PSpdZS / air_.DLTime; // Convert to mps
		air_.AirSpd.x = PSpdXS / air_.DLTime;
		// 2. SPEED (mpf) ------------------------------------------------------
		let ThrFrc = air_.Weight*air_.ThrMlt*air_.PwrPct;
		// 2a. Forward Speed (mpf) .............................................
		// Thrust Force (F/s)
		let ACPRad = (-air_.AirRot.x - air_.RtrAng.x) * DegRad;
		let PThrZF = ThrFrc * Math.sin(ACPRad); // Propeller Acceleration - Forward
		// Drag
		let DynPrZ = 0.5 * air_.AirDSL * (air_.AirSpd.z ** 2); // Dynamic Pressure (Absolute value)
		let PDrgZF = DynPrZ * air_.FrntAr * air_.DrgCdz; // Parasitic Drag
		if (PSpdZS < 0) PDrgZF = -DynPrZ * air_.DrgCdx/air_.DrgCdz; // Use large drag to limit max backward speed		
		let PnetZF = PThrZF - PDrgZF; // Net Force
		// Acceleration (mpf)		
		let PnetZA = (PnetZF/air_.ACMass); // (mps)
		PnetZA = PnetZA*DLTime*air_.ThrAdj.z; // (mpf)	
		PSpdZS = PSpdZS + PnetZA; // new Speed (mpf)
		// 2b. Lateral Speed (mpf) .............................................
		// Thrust Force (F/s)
		let ACBRad = (air_.AirRot.z + air_.RtrAng.z) * DegRad;
		let PThrXF = ThrFrc * Math.cos(ACPRad) * Math.sin(ACBRad); // Propeller Acceleration - Lateral
		// Drag
		let DynPrX = 0.5 * air_.AirDSL * (air_.AirSpd.x ** 2); // Dynamic Pressure
		let PDrgXF = DynPrX * air_.FrntAr * air_.DrgCdx; // Parasitic Drag
		if (PSpdXS < 0) PDrgXF = -PDrgXF; // If going left, drag = right		
		let PnetXF = PThrXF - PDrgXF; // Net Force
		// Acceleration (mpf)
		let PnetXA = (PnetXF/air_.ACMass); // (mps)
		PnetXA = PnetXA*DLTime*air_.ThrAdj.x; // (mpf)
		PSpdXS = PSpdXS + PnetXA; // new Speed (mpf)
		// 2c. Vertical Speed (mpf) ............................................
		// Thrust Force (F/s)
		let PThrYF = ThrFrc * Math.cos(ACPRad) * Math.cos(ACBRad); // Propeller Acceleration - Vertical
		let PnetYF = PThrYF; 	// Net Force
//		console.log(PnetYF);
		// Acceleration (mpf)
		let PnetYA = (PnetYF/air_.ACMass) - GrvMPS; // (mps)
		PnetYA = PnetYA*DLTime*air_.ThrAdj.y; // (mpf)
		PSpdYS = PSpdYS + PnetYA; // new Speed (mpf)
		// 3. COMPUTE DIRECTION OF FLIGHT --------------------------------------
		// Inputs: air_.RotDif
		// This routine uses 2 linked meshes to correctly rotate aircraft.
		// Rotate Aircraft (Heading Not Change)
		// Changes to AirPBY (User Input)
		air_.AirPBY.rotation.z = -air_.RotDif.z*DegRad;	// Change in Bank (due to user imput)
		air_.AirPBY.rotation.x = air_.RotDif.x*DegRad;	// Change in Pitch (due to user input)
		air_.AirPBY.rotation.y = -air_.RotDif.y*DegRad;	// Change in Yaw (due to user input)
		// Transfer Combined Rotation to AirAxe
		air_.AirPBY.getWorldQuaternion(quaternion);
		air_.AirObj.setRotationFromQuaternion(quaternion);
		// Zero Out AirPBY Rotations (so display has correct values)
		air_.AirPBY.rotation.z = 0;
		air_.AirPBY.rotation.x = 0;
		air_.AirPBY.rotation.y = 0;
		// Pitch ...............................................................
		air_.AirRot.x = PoM360(air_.AirObj.rotation.x*RadDeg);
		// Heading .............................................................
		air_.AirRot.y = Mod360(-air_.AirObj.rotation.y*RadDeg);
		air_.HdgDif = (air_.AirRot.y-air_.OldRot.y)/air_.DLTime; // Change in Heading (display)
		air_.OldRot.y = air_.AirRot.y; // Save old heading	
		// Bank ................................................................
		air_.OldRot.z = air_.AirObj.rotation.z;
		air_.AirRot.z = Mod360(-air_.AirObj.rotation.z*RadDeg);
		//- 4. ROTATE HELICOPTER -----------------------------------------------
		// Weather-Vane Adjustment
		// At Slow Speed, Helicopter Can Fly Sideways without Chaninge Direction
		// At Higher Speeds, Helicopter will Point in Direction of Flight
		let TotSpd = Math.sqrt(air_.AirSpd.z*air_.AirSpd.z+air_.AirSpd.x*air_.AirSpd.x);
		TotSpd = Math.abs(TotSpd);
		let YawAdj;
		if (TotSpd) { // if moving
			air_.DirFlt = Mod360(Math.atan2(air_.MapSpd.x,air_.MapSpd.z) * RadDeg);
			let DirDif = Mod360(air_.DirFlt-air_.AirRot.y);	// Difference
			DirDif = PoM360(DirDif)*DegRad;
			YawAdj = Math.sin(DirDif); // Range = 0, +1, 0, -1
			if (DirDif > 90) YawAdj = 1;
			if (DirDif < -90) YawAdj = -1;
			YawAdj = YawAdj * TotSpd / air_.MaxKPH;
			YawAdj = YawAdj * 10;
			air_.AirRot.y = air_.AirRot.y + YawAdj;
		}
		air_.RotDif.y = air_.RotDif.y + YawAdj;
		air_.AirObj.rotation.y = Mod360(-air_.AirRot.y) * DegRad; // Heading
		// 5. MAPSPD AND MAPPOS ------------------------------------------------
		// 5a. Compute MSpd (mpf)
		air_.MapSpd.z = PSpdZS * Math.cos(ACHRad) - PSpdXS * Math.sin(ACHRad);
		air_.MapSpd.x = PSpdZS * Math.sin(ACHRad) + PSpdXS * Math.cos(ACHRad);
		air_.MapSpd.y = PSpdYS;
		// 5b. Compute Map Pos (meters)
		air_.MapPos.z = air_.MapPos.z + air_.MapSpd.z;
		air_.MapPos.x = air_.MapPos.x + air_.MapSpd.x;
		air_.MapPos.y = air_.MapPos.y + air_.MapSpd.y;
		// 5c. Compute MapSPS
		air_.MapSPS.x = air_.MapSpd.x; // (mpf)
		air_.MapSPS.y = air_.MapPos.y; // (meters)
		air_.MapSPS.z = air_.MapSpd.z; // (mpf)
		// 5d. For Display Only (mps)
		air_.AirSpd.z = PSpdZS/DLTime;
		air_.AirSpd.x = PSpdXS/DLTime;
		air_.AirSpd.y = PSpdYS/DLTime;
		// 5e. Compute Total Speeds (not used)
		air_.SpdMPS = TotSpd/DLTime;	// (mps)
		air_.SpdKPH = air_.SpdMPS*3.6; // (KPH) = *3600/1000
	}
	// Landing Override
	let MinAlt = air_.GrdZed + air_.MdlAlt; // Minimum Altitude (ASL = GL+AGL)
	if (air_.MapPos.y <= MinAlt) air_.GrdFlg = 1;
	if (air_.GrdFlg) landFlight(MinAlt);	
}

function landFlight(MinAlt) {
//	air_.GrdFlg = 1;	// If Flag Not Set and Hit Ground
	air_.MapPos.y = air_.MapSPS.y = MinAlt;	// Altitude = GL + AGL
	// Inputs
	air_.RotDif.x = air_.RotDif.z = 0;		
	// Rotation
	air_.AirRot.x = air_.AirRot.z = 0;
	// AirSpeed
	air_.AirSpd.z = air_.AirSpd.x = air_.AirSpd.y = 0;
	// MapSpeed
	air_.MapSpd.z = air_.MapSpd.x = air_.MapSpd.y = 0;
	// MapSPS
	air_.MapSPS.x = air_.MapSPS.z = 0;
	// DirFlt
	air_.DirFlt = air_.AirRot.y;
	//
	air_.AirObj.rotation.z = air_.AirObj.rotation.x = 0;	
	// Main Rotor Blades - Pitch
	if (mxr_.RtrP) mxr_.RtrP.setTime(180/anmfps);
	// Main Rotor Blades - Bank
	if (mxr_.RtrK) mxr_.RtrK.setTime(180/anmfps);
}

/*******************************************************************************
*
*	SUBROUTINES
*
*******************************************************************************/

//- Convert degrees to 360
function Mod360(deg) {
	while (deg < 0) deg = deg+360; // Make deg a positive number
	deg = deg % 360;			// Compute remainder of any number divided by 360
return deg;}

//- Converts 360 degrees to +/- 180
function PoM360(deg) {
	if (deg > 180) deg = deg-360;
return deg;}

//- Limit Maximum +/- Value
function MaxVal(x, max) {
	if (x > 0 && x >  max) x =  max;
	if (x < 0 && x < -max) x = -max;
return x;}

/*******************************************************************************
*
*	6. SOUNDS
*
*******************************************************************************/

//= LOAD SOUNDS ================//==============================================

function loadSounds() {
	// Load Sounds .............................................................
	gen_.audoLd.load(mys_.EngSrc, function(buffer) {
		mys_.EngSnd.setBuffer(buffer);
		mys_.EngSnd.setRefDistance(mys_.RefDst);
		mys_.EngSnd.setLoop(true);
		mys_.EngSnd.setVolume(0);
		mys_.EngMsh.add(mys_.EngSnd);
	});
	//- Set Flag
	gen_.LodSnd = 1;	
}

//= MOVE SOUNDS ================================================================

// Change Sounds
function moveSounds() {
	// My Engine
	mys_.EngSnd.setVolume(mys_.EngVol);
	mys_.EngSnd.setPlaybackRate(1);
}

//- Play Sounds ----------------------------------------------------------------
function playSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (!mys_.EngSnd.isPlaying) mys_.EngSnd.play();
}

//- Stop Sounds ----------------------------------------------------------------
function stopSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (mys_.EngSnd.isPlaying) mys_.EngSnd.stop();
}

/*******************************************************************************
*
*	8. OUTPUTS
*
*******************************************************************************/

// Change HUD Values
function prntHUDval() {
	Air_Pwr = air_.PwrPct*100;		// Throttle Setting
	Air_PwrNode.nodeValue = Air_Pwr.toFixed(0);
	AC_Hite = air_.MapPos.y*Mtr2Ft; // Altitude (feet)
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);
	AC_Ptch = air_.AirRot.x;	// Pitch (deg)
	AC_PtchNode.nodeValue = AC_Ptch.toFixed(0);
	AC_SpdZ =  air_.AirSpd.z * 3.6 * Km2Mil; // Speed - Forward (mph)
	AC_SpdZNode.nodeValue = AC_SpdZ.toFixed(0);
	AC_Bank = air_.AirRot.z;	// Bank (deg)
	AC_BankNode.nodeValue = AC_Bank.toFixed(0);
	AC_SpdX = air_.AirSpd.x * 3.6 * Km2Mil; // Speed - Lateral (mph)
	AC_SpdXNode.nodeValue = AC_SpdX.toFixed(0);
	AC_Head = Mod360(Math.round(air_.AirRot.y)); // Heading (deg)
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_DFly = air_.DirFlt;		// Direction of Flight (deg)
	AC_DFlyNode.nodeValue = AC_DFly.toFixed(0);
}

//	Paused On
function PawsText(){
	if (gen_.PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//	Info
function InfoText() {
	if (!gen_.InfoOn) onInfo0();
	else if (gen_.InfoOn == 1) onInfo1();
	else if (gen_.InfoOn == 2) onInfo2();
}

//	Info Off
function onInfo0(){
	On_Info01Node.nodeValue = "Info : Press I";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

// Info On
function onInfo1(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "CONTROLS";
	On_Info03Node.nodeValue = "Mouse Wheel or Q/E Keys change Altitude";
	On_Info04Node.nodeValue = "Mouse, Arrow or W/S Keys change Pitch";
	On_Info05Node.nodeValue = "Mouse, Arrow or A/D Keys change Bank";
	On_Info06Node.nodeValue = "Mouse Buttons or Z/X Keys change Yaw";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "O Key toggles sound";
}

// Info On
function onInfo2(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "VIEW KEYS";
	On_Info03Node.nodeValue = "Shift Key and Mouse pans around aircraft";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "DELETE/PAGE DOWN Keys look left/right";
	On_Info06Node.nodeValue = "Above plus HOME Key looks up";
	On_Info07Node.nodeValue = "END Key plus DELETE/PAGE DOWN Keys look back";
	On_Info08Node.nodeValue = "All 3 Keys to look back";
	On_Info09Node.nodeValue = "";
}

/*******************************************************************************
*
*	9. INPUTS
*
*******************************************************************************/

// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//= MOUSE ======================//==============================================

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		InpYaw = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		InpYaw = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		InpYaw = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		InpYaw = 0;
	}
}

// Mousewheel - Power
function onDocumentMouseWheel(event) {
	event.preventDefault();
	air_.PwrPct = air_.PwrPct - event.deltaY * 0.0005;
	if (air_.PwrPct < 0) air_.PwrPct = 0;
	if (air_.PwrPct > 1) air_.PwrPct = 1;
//	console.log(air_.PwrPct);
}

//- KEYBOARD ===================//==============================================

//- Keyboard (Down) ------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == key_.AltU) InpAlt = 0.001;		// Altitude Up
	if (event.keyCode == key_.AltD) InpAlt = -0.001;	// Altitude Down
	if (event.keyCode == key_.PitU) InpACP = KeyVal.x;	// Pitch Up
	if (event.keyCode == key_.PitD) InpACP = -KeyVal.x;	// Pitch Down
	if (event.keyCode == key_.BnkL) InpACB = -KeyVal.z;	// Bank Left
	if (event.keyCode == key_.BnkR) InpACB = KeyVal.z;	// Bank Right
	if (event.keyCode == key_.PitD) InpACP = -KeyVal.x;	// Pitch Down
	if (event.keyCode == key_.PitU) InpACP = KeyVal.x;	// Pitch Up
	if (event.keyCode == key_.BnkL) InpACB = -KeyVal.z;	// Bank Left
	if (event.keyCode == key_.BnkR) InpACB = KeyVal.z;	// Bank Right
	if (event.keyCode == key_.YawL) InpYaw = -KeyVal.y;	// Yaw Left
	if (event.keyCode == key_.YawR) InpYaw = KeyVal.y;	// Yaw Right
	// Views
	if (event.keyCode == key_.Look) cam_.OrbFlg = 1;	// Orbit View
	if (event.keyCode == key_.VU45) cam_.D45flg = 1;	// View - 45 deg up
	if (event.keyCode == key_.VD45) cam_.U45flg = 1;	// View - 45 deg down
	if (event.keyCode == key_.VL45) cam_.L45flg = 1;	// View - 45 deg left
	if (event.keyCode == key_.VR45) cam_.R45flg = 1;	// View - 45 deg right
	if (event.keyCode == key_.VL90) cam_.L90flg = 1;	// View - 90 deg left
	if (event.keyCode == key_.VR90) cam_.R90flg = 1;	// View - 90 deg right
	// Toggle
	if (event.keyCode == key_.View) toglView();			// Switch View
	if (event.keyCode == key_.Paws) toglPaws();			// Toggle Pause
	if (event.keyCode == key_.Info) toglInfo();			// Toggle Information
	if (event.keyCode == key_.Soun) toglSoun();			// Toggle Sound
}

//-	Keyboard (Up) --------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == key_.AltU) InpAlt = 0;			// Altitude Up
	if (event.keyCode == key_.AltD) InpAlt = 0;			// Altitude Down
	if (event.keyCode == key_.PitU) InpACP = 0;			// Pitch Up
	if (event.keyCode == key_.PitD) InpACP = 0;			// Pitch Down
	if (event.keyCode == key_.BnkL) InpACB = 0;			// Bank Left
	if (event.keyCode == key_.BnkR) InpACB = 0;			// Bank Right
	if (event.keyCode == key_.PitD) InpACP = 0;			// Pitch Down
	if (event.keyCode == key_.PitU) InpACP = 0;			// Pitch Up
	if (event.keyCode == key_.BnkL) InpACB = 0;			// Bank Left
	if (event.keyCode == key_.BnkR) InpACB = 0;			// Bank Right
	if (event.keyCode == key_.YawL) InpYaw = 0;			// Yaw Left
	if (event.keyCode == key_.YawR) InpYaw = 0;			// Yaw Right
	// Views
	if (event.keyCode == key_.Look) cam_.OrbFlg = 0;	// Orbit View
	if (event.keyCode == key_.VU45) cam_.D45flg = 0;	// View - 45 deg up
	if (event.keyCode == key_.VD45) cam_.U45flg = 0;	// View - 45 deg down
	if (event.keyCode == key_.VL45) cam_.L45flg = 0;	// View - 45 deg left
	if (event.keyCode == key_.VR45) cam_.R45flg = 0;	// View - 45 deg right
	if (event.keyCode == key_.VL90) cam_.L90flg = 0;	// View - 90 deg left
	if (event.keyCode == key_.VR90) cam_.R90flg = 0;	// View - 90 deg right
}

//- Subroutines ----------------------------------------------------------------

//. Toggle Camera View (2-Way) -//----------------------------------------------
function toglView() {
	// Old CamSel
	cam_.CamPar.remove(cam_.MshRot); // Unlink Old Parent
	cam_.SrcLLD[cam_.CamSel].copy(cam_.CamLLD);	// Save LLD
	// New CamSel
	cam_.CamSel = 1 - cam_.CamSel;
	initCamera(cam_,air_,key_,gen_,mxr_,vxr_,InpMos);
}

//. Toggle Pause ...............................................................
function toglPaws() {
	gen_.PawsOn = 1 - gen_.PawsOn;
	if (gen_.PawsOn && gen_.SndFlg) {		//On to Off
		stopSounds();
	}
	if (!gen_.PawsOn && gen_.SndFlg) {	// Off to On
		playSounds();
	}
	PawsText();
}

//. Toggle AutoPilot ...........................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................................................................
function toglInfo() {
	gen_.InfoOn++
	if (gen_.InfoOn == 3) gen_.InfoOn = 0;
	InfoText();
}

//. Toggle Sound ...............................................................
function toglSoun() {
	if (!gen_.PawsOn) {
		gen_.SndFlg = 1 - gen_.SndFlg;
		if (gen_.SndFlg) playSounds();	// Off to On
		else {stopSounds();}			// On to Off
	}
}

//= WINDOW RESIZE ==============//==============================================

function onWindowResize() {
	camera.aspect = window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

/*******************************************************************************
*
*	CHANGE LOG
*
********************************************************************************
251125: Use gen_ to Store Loader and Scene values
*/

</script>
</body>
</html>