<!doctype html>
<html>

<!--
Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 31 Jan 2025

A flight simulation of an animated airplane model over procedural land using
-->

<head>
<title>fsim U1H land gpu r173</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Height: <span id="AC_Hite"></span> ft</div>
		<div>ACPtch: <span id="AC_Ptch"></span> deg</div>
		<div>SpeedZ: <span id="AC_SpdZ"></span> mph</div>
		<div>ACBank: <span id="AC_Bank"></span> deg</div>
		<div>SpeedX: <span id="AC_SpdX"></span> mph</div>	
		<div>Headng: <span id="AC_Head"></span> deg</div>
		<div>DirFly: <span id="AC_DFly"></span> deg</div>
	</div>
	<div class="overlay2">
		<p>
		<div><span id="On_Paws"></span></div>
		<div><span id="On_Info01"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
		<div><span id="On_Info05"></span></div>
		<div><span id="On_Info06"></span></div>
		<div><span id="On_Info07"></span></div>
		<div><span id="On_Info08"></span></div>
		<div><span id="On_Info09"></span></div>
		</p>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.173.0/build/three.webgpu.js",
			"three/webgpu": "https://unpkg.com/three@0.173.0/build/three.webgpu.js",
			"three/tsl": "https://unpkg.com/three@0.173.0/build/three.tsl.js",
			"three/addons/": "https://unpkg.com/three@0.173.0/examples/jsm/",
			"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.8/dist/main.js"
		}
	}
</script>

<script type="module">

import * as THREE from "three";
import {color,float,texture} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement } from "three/addons/objects/LensflareMesh.js";
import Stats from "stats-gl";
// Special Modules
import {GrdMap} from "https://PhilCrowther.github.io/Aviation/jsm/GrdMap3b.js"; // r171

//= GENERAL ===================================================================

//	This flight simulation demo uses the most advanced version of three.js

//= CONTROLS
//	This simulation primarily relies on mouse controls:
//	* Mouse wheel sets altitude (like the throttle/collective control in a real helicopter)
//	* Mouse movement changes direction (like the cyclic control in a real helicopter)
//	* Mouse buttons cause yaw left/right (like tail rotor in real helicopter)

//=	SIMPLIFICATIONS
//	A Helicopter is extremely difficult to fly. Your "pilot personna" will handle the following:
//	* Adjust power for changes in collective.
//	* Adjust power/collective to maintain altitude in horizontal flight.
//  * Adjust tail rotor to offset changes in power/collective.

//=	TO DO:
//-	Flight Module:
//	* Fix Weathervan adjustment (YawAdj)
//	* Allow for greater pitch and bank adjustments where excess thrust available.
//	* Reduce excess thrust available as altitude increases.
//	* Reduce/increase excess thrust available as climb/descend

//= INPUTS =====================//==============================================	
//- CAMERA ---------------------------------------------------------------------
let CamSel = 0;					// Camera Seletion (0 = External; 1 = Internal)
//- AIRPLANE: Start -----------------------------------------------------------
let BegPwr = 0;					// Initial Power Percent
let BegSpd = 0;					// Speed (kph)
let BegRot = new THREE.Euler(0,0,0); // Position (degrees) ### new
let BegPos = new THREE.Vector3(0,0,0); // Position (meters)
//- AIRPLANE: Inputs -----------------------------------------------------------
let PYBmul = new THREE.Vector3(0.1,1,0.1); // Basic airplane values
let	MosMul = new THREE.Vector3(1,1,1); // Adjustment to PYBmul (default = 1)
let AltMul = 0.0001;			// Power % Input - Mouse Multiplier
let AltDif = 0;					// Power % Input - Value
//- Mouse Delays ...............................................................
//- (x = diverted, y = released, z = stored)
//let PwrMsD = new THREE.Vector3(1-1/30,1/15,0);	// Power
//let PitMsD = new THREE.Vector3(1-1/30,1/15,0);	// CfL
//let BnkMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//let YawMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- Keys -----------------------------------------------------------------------
let KeyVal = new THREE.Vector3(0.5,0.4,0.5); // Key Values
let InpAlt = 0;					// Input Altitude
let InpACP = 0;					// Input Pitch
let InpACB = 0;					// Input Bank
let InpYaw = 0;					// Input Yaw

//- POINTER LOCK CONTROLS ------------------------------------------------------
let InpMos = new THREE.Vector2();	// Inputs - Mouse
let _changeEvent = {type: "change"};
let _lockEvent = {type: "lock"};
let _unlockEvent = {type: "unlock"};

//= CONSTANTS ==================//==============================================
//	Time
let	DLTime = 1/60;				// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;		//
//	Conversions
let DegRad = Math.PI/180;		// Convert Degrees to Radians
let RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Ft2Mtr = 0.3048;			// Convert Feet to Meters
let Mtr2Ft = 1/0.3048;
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//	Default Constants
let AirDen = 1.225;				// (kg/m3)
//	Starting Constants per frame
let BegTmp = 288.15;			// K = 59F

//= INPUT VALUES ===============//==============================================
//- Display
let PawsOn = 0;					// Pause
let InfoOn = 0;					// Info
let SndFlg = 0;
let StatOn = 1;					// Stats ((0 = off, 1 = on)
let LnFFlg = 1;					// Lensflare
//	Program Flags
let LodFlg = 0;					// Set at end of initialization
let LodSnd = 0;					// Set when sound initialized
//	Altitude Adjustment
let AltAdj = 0.99;				// Raises objects above map as altitude increases

//= SUN VALUES =================//==============================================
let SunCol = 0xffffff;			// Sun
let SunInt = 3;					// Default intensity of light/sun
//- Rotation and Position (fixed)
let SunDst = 50;				// Distance (for shadows)
let SunLat = 23;				// Direction - Vert (+/- 90)
let SunLon = 312;				// Direction - Horz (0->360)
//- New
let SunSph = new THREE.Spherical(SunDst,(90-SunLat)*DegRad,Mod360(180-SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);
//	Shadows
let ShdBox = 6;					// Size of shadow box
let ShdBLR = 10;
let ShdBTB = 6;
let ShdDst = 1500;				// Shadow Distance (meters)

//= STANDARD SETUP =============//==============================================
//- Scene
let scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
//- Light
let ambLight = new THREE.AmbientLight(SunCol,0.2);
	scene.add(ambLight);
//- SunLight
let sunLight = new THREE.DirectionalLight(SunCol,SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = SunDst*0.75;
	sunLight.shadow.camera.far = SunDst+ShdDst+ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -ShdBLR;
	sunLight.shadow.camera.right = ShdBLR;
	sunLight.shadow.camera.top = ShdBTB;
	sunLight.shadow.camera.bottom = -ShdBTB;
	sunLight.shadow.bias = -0.0002; // WebGPU (0 flashing; -0.0001 no wheels)
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
let camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//- Renderer
let renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
let maxAnisotropy = renderer.getMaxAnisotropy();
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
//- Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= SKY ========================//==============================================
let FogCol = 0xbab4a6;			// Sky (for Fog only)
//- SkyBox
let SBxSrc = "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/";
//-	LensFlare
let LF0Src = "https://threejs.org/examples/textures/lensflare/lensflare1.png";
let LF1Src = "https://threejs.org/examples/textures/lensflare/lensflare3.png";
let LF0Txt, LF1Txt = 0;

//= GEOMAT =====================//==============================================
//= Textures Data ==============//==============================================
//- All textures are 512X512
let dqSize = 1024;
let dqArea = dqSize*dqSize;
let dtSize = 512;
let dtArea = dtSize*dtSize;
let dtData = 0;
let txtTot = 6;					// Total Textures
//- Canvas
let ImgSiz = 1024;				// !!! Change this for each image
let canvas = document.createElement("canvas");
	canvas.width = ImgSiz;
	canvas.height = ImgSiz;
let context = canvas.getContext("2d",{willReadFrequently: true});
//= Grid 4 Data ================//==============================================
//- 1/4 section squares (1/2 mile X 1/2 mile)
//- Variables
let GrdMul = 10;
let red = [0,0];
let grn = [0,0];
let blu = [0,0];
//- Colors
let GrdDrt = "#1c160e";			// Color of underlying dirt (affects brightness)
let drtclr = [0x8e6d3d,0x47361e]; // Dirt
let pstclr = [0x00b000,0x005000]; // Pasture
let cvrclr = [0x75b24c,0x466b2d]; // Green
let whtclr = [0xfbf4e5,0xeabb63]; // Wheat
let bnsclr = [0xacd193,0x5d8e3d]; // Beans
//	Tones of Dirt Brown Color | #836539 Monochromatic Color
//	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
//	Neutral Scheme (Brown to Green)
//	0x836539, 0x837738, 0x7b8338, 0x698338, 0x568338, 0x448338
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//	[https://icolorpalette.com/color/dirt-brown
let count0;
//= MATERIALS ==================//==============================================
//= Grid 0 Data ================//==============================================
//- Image Data
let G0DPtr = [];
	G0DPtr[txtTot-1] = 0;
//- Materials
let G0MPtr = [];
	G0MPtr[txtTot-1] = 0;
// Patterns for Grid 5 3X3 Textures
// Also used to draw Grid 4 textures
// 0 = Dirt
// 1 = Pasture
// 2 = Plowed Dirt
// 3 = Green Vertical
// 4 = Wheat
// 5 = Green Horizontal
// Per Pattern: 1X 0-2 2X 3-5
let G0Id00 = [4,3,5,4,3,0,5,2,1];
let G0Id01 = [3,0,4,1,2,4,5,3,5];
let G0Id02 = [5,1,3,4,5,0,2,4,3];
let G0Id03 = [2,4,1,3,5,3,5,0,4];
let G0Id04 = [5,1,5,0,3,4,2,4,3];
let G0Id05 = [3,0,5,3,4,5,1,2,4];
let G0Id06 = [2,0,3,5,3,1,4,4,5];
let G0Id07 = [1,5,4,3,5,0,2,4,3];
let G0Id08 = [2,3,0,5,3,1,4,5,4];
let G0Id09 = [0,2,5,3,4,3,5,1,4];	// 1 = airport
let G0Id10 = [4,3,5,4,5,2,1,3,0];
let G0Id11 = [4,5,3,1,0,4,3,5,2];
let G0Id12 = [3,1,2,4,5,3,5,0,4];
let G0Id13 = [0,5,3,1,4,2,4,3,5];
let G0Id14 = [1,4,2,5,3,0,4,5,3];
let G0Id15 = [4,1,5,0,3,4,3,5,2];
let G0Indx = [
		G0Id00,G0Id01,G0Id02,G0Id03,G0Id04,G0Id05,G0Id06,G0Id07,G0Id08,G0Id09,
		G0Id10,G0Id11,G0Id12,G0Id13,G0Id14,G0Id15
	];
//= Grid 1 Data ================//==============================================
let Gr1Mul = 3;
let Gr1Siz = Math.floor(dtSize/Gr1Mul);
// Image Data (Source Data - Resized)
let G1SPtr = [];
	G1SPtr[G0Indx.length-1] = 0;
// Image Data
let G1DPtr = [];
	G1DPtr[G0Indx.length-1] = 0;
// Materials
let G1MPtr = [];
	G1MPtr[G1DPtr.length-1] = 0;
// Index to Display of G1 Textures by Type
// Used by G0 to position squares
// And by G1 to create textures
let G1Indx = [
		 0, 1, 2, 3, 4, 5, 6, 7, 8,	//value of 9-15 in first row causes white space 
		10, 2, 4,15,10,12,10, 9, 5,
		 3,12,11, 8,13, 3, 1, 0,14,
		 0, 7,10,14,12,10,11, 2, 4,
		 9,14, 5, 4, 9,13, 8,12, 7,	// 9 = over
		 4, 7,15,12, 3,11, 9,13, 4,	// 3 = Airport
		11,12, 8, 5,13, 2,10,15,13,
		 6,10, 7, 9,15,14,12, 5,11,
		 0,13, 6,10, 3, 2,14, 4, 8
	];
//= Grid 2 Data ================//==============================================
let Gr2Mul = 3;
let Gr2Siz = Math.floor(dtSize/Gr2Mul);
// Image Data (Source Data - Resized)
let G2SPtr = [0,0,0,0,0,0,0,0,0];
// Image Data
let G2DPtr = [0,0,0,0,0,0,0,0,0];
// Materials
let G2MPtr = [0,0,0,0,0,0,0,0,0];

//= GRID MODULE ================//==============================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let GrdSiz = 804.67;			// Size of Smallest Grid Square (1/4 section = 1/2 mile)
let grids = 0;
let grd_ = {
		SPS: new THREE.Vector3 (), // MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,				// Squares in each of first 2 grids
		Siz: GrdSiz,			// Size of smallest square
		Stp: 3,					// Squares in each of first 2 grids
		Grx: [],				// Index of Grids (0-2)
		Idx: [G0Indx,G1Indx],	// Index to Patterns
		Mat: [G0MPtr,G1MPtr,G2MPtr], // Materials
	}
/* = Roads =====================//============================================*/
//- North/South
let Rod1 = {
		Typ:	1,
		RCs:	21,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,		// Size of square
		Stp:	1,				// Squares to flip
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		Txt:	0,				// Texture Address
		Shd:	1				// Shadow enabled
	}
//- East West
let Rod2 = {
		Typ:	2,
		RCs:	21,				// Rows and Columns - use odd number (for now = divisible by 3)
		Siz:	2*GrdSiz,		// Size of square
		Stp:	1,				// Squares to flip
		RCi:	0,				// Rows and Columns Index (computed)
		MZV:	[0],			// Ground Z Value
		MXV:	[0],			// Ground X Value
		Nor:	0,				// Max North Square (updated)
		Est:	0,				// Max East Square (updated)
		Num:	0,				// Size of array (computed)
		Ptr:	[0],			// Ground Address
		Txt:	0,				// Texture Address
		Shd:	1				// Shadow enabled
	}
//- Materials
let rodclr = [0xd0b894,0x8e6d3d];		// Colors
//-	Tones of Dirt Brown Color | #836539 Monochromatic Color
//-	0xefe7db, 0xe0cfb7, 0xd0b894, 0xc1a070, 0xb1884d, 0x8e6d3d, 0x6a522e, 0x47361e
let r0Size = 32;
let r0Area = r0Size*r0Size;
let r0Data = new Uint8Array(4*r0Area);
//= Trees ======================//==============================================
let TreTot = 64;
let t0Size = 128;
let t0Area = t0Size*t0Size;
let t0Data = new Uint8Array(4*t0Area);
let Trees = [];
	Trees[TreTot-1] = 0;
let TreePZ = [0];
	TreePZ[TreTot-1] = 0;
let	TreePX = [0];
	TreePX[TreTot-1] = 0;
let treclr = [0x75b24c,0x2e471e];		// Colors
//	Hot Pepper Green ( similar ) Color | 568338 Monochromatic Color
//	0xe3efdb, 0xc7e0b7, 0xacd193, 0x90c170, 0x75b24c, 0x5d8e3d, 0x466b2d, 0x2e471e
//= Objects ====================//==============================================
//- Distances in Meters
let ObjNum = 2;					// number of objects
let ObjTyp = [0];				// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];				// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];				// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];				// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];				// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];				// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];				// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];				// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
//- Hangars
	ObjTyp[ObjIdx] = 0;			// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 1000;		// [m]
	ObjMPY[ObjIdx] = 0.3048;	// [m] 1 ft
	ObjMPZ[ObjIdx] = 1524;		// [m] 5000 ft
	ObjIdx = ObjIdx + 1;
//- Giaros Island
	ObjTyp[ObjIdx] = 1;			// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/textures/giaros.png";
	ObjMPX[ObjIdx] = -1609.344;	// [m] 1 mile
	ObjMPY[ObjIdx] = 2*Ft2Mtr;	// [m] 2 ft
	ObjMPZ[ObjIdx] = 8046.72;	// [m] 5 miles
//= MY AIRPLANE ================//==============================================
let dat_ = {
		MaxThr: 32620,			// Level Flight Thrust (N = 7333 lbs)
		MaxAng: 30,				// Max Rotor and Body Angle (deg) [rotor moves +/-11 deg]
		MaxKPH: 217.26,			// Max Speed (mph = 135 mph)
		MinAng: 15,				// Min Rotor and Body Angle (deg) to main MaxKPH
		ACMass: 3326,			// Aircraft Mass (kg = 7333 lb / 2.2)
		FrntAr: 1.951,			// Frontal Area (m2 = 21 ft2)
		DrgCdz: 1.94,			// Coefficient of Drag (z-direction)
		DrgCdx: 43.525,			// Coefficient of Drag (x-direction)
		MdlAlt: 1.3,			// Model Center Height above Ground (meters)
	}
//= 
let air_ = {
		// General Variables
		DLTime: DLTime,			// Seconds per frame (can vary)
		AirDSL: AirDen,			// Air Density (varies with altitude)
		// Designators
		AirDat: dat_,			// Aircraft Type: 1 = Pup
		// Helicopter Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Euler(0,0,0).copy(BegRot), // Rotation (in degrees)
		AirObj: makMsh(),
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(), // Change
		AltDif: 0,
		// Airplane Speed
		SpdKPH: BegSpd,			// Speed in KPH
		SpdMPS: BegSpd/3.6,		// Speed - meters per second
		AirSpd: new THREE.Vector3(), // Airspeed (mpf) ### new
		// Airplane Map Speed and Position
		DirFlt: BegRot.y,
		MapSpd: new THREE.Vector3(), // Map Speed (mpf)
		MapPos: new THREE.Vector3(), // Map Position (meters)
		MapSPS: new THREE.Vector3(), // MSX, MPY, MSZ (meters)
		// Variables
		PwrPct: BegPwr,			// % of Primary Power (0 to 1) (Main and Flight)
		// Variables Obtained from Flight
		GrdZed: 0,				// Ground level (default)
		GrdFlg: 0,				// Ground Flag (1 = on ground)
		ACPAdj: 0,				// Airplane pitch adjustment
		MovFlg: 0,				// If Sitting on a Moving Object
		// Variables Obtained from Data
		MaxThr: 0,				// Prop Maximum Power (kW = 17000 lbs X 4.445)
		MaxAng: 0,				// Max Rotor and Body Angle (deg)
		MaxKPH: 0,				// Max Speed (KPH)
		MinAng: 0,
		ACMass: 0,				// Airplane Mass
		FrntAr: 0,				// Frontal Area
		DrgCdz: 0,				// Coefficient of Drag (z-direction)
		DrgCdx: 0,				// Coefficient of Drag (x-direction)
		Weight: 0,				// Used by autopilots
		MdlAlt: 0,				// Model Center Height above Ground (meters)
	}
//- Adjustments
	air_.AirObj.rotation.order = "YXZ";
	scene.add(air_.AirObj);
//- Load Models and Animations -------------------------------------------------
//-	File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/u1h/";	// Used to load models and sounds
//-	Animation Mixers - External Model
let ACFile = "u1h_flyt.glb"; // Name of aircraft model file (rotated blender file)
//- Aircraft Animations
let anmfps = 24;				// Blender FPS
let aoarng = 20;				// AoA range (model)
//	Animation Mixers - External Model
let mxRtrB = 0;					// Main Rotor - Blades
let mxRtrP = 0;					// Main Rotor - Pitch
let mxRtrK = 0;					// Main Rotor - Bank
let mxRtrV = 0;					// Main Rotor - Vertical
let mxRtrT = 0;					// Tail Rotor
let mxDorL = 0;					// Main Doors - Left
let mxDorR = 0;					// Main Doors - Right
//- All range from 0 to 360 with center at 180
let pitprp = 180;				// Main Rotor - Pitch
let bnkprp = 180;				// Main Rotor - Bank
let spnprp = 180;				// Main Rotor - Spin
let spnrtr = 180;				// Tail Rotor - Spin (not used)
let doormn = 0;					// Main Doors

//=	SOUNDS =====================//==============================================
let EngSrc = "xbell_rotor03a.wav"; // File (my engine)
let EngVol = 0.1;				// Volume
let EngSnd = 0;
let EngMsh = new makMsh();		// Aircraft Engine

//= POINTER LOCK CONTROL =======================================================
class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.addEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener("pointerlockerror", onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//- Setup ----------------------------------------------------------------------
let controls = new PointerLockControls(camera, renderer.domElement);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener("unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

//= DEFAULT KEY BINDINGS =======//==============================================
let	K_AltU = 81;				// Altitude Up (q)
let	K_AltD = 69;				// Altitude Dn (e)
let	A_PitU = 40;				// Pitch up (down arrow)
let	A_PitD = 38;				// Pitch down (up arrow)
let	A_BnkL = 37;				// Bank Left (left arrow)
let	A_BnkR = 39;				// Bank Right (right arrow)
let	K_PitU = 88;				// Pitch up (w)
let	K_PitD = 83;				// Pitch down (s)
let	K_BnkL = 65;				// Bank Left (a)
let	K_BnkR = 68;				// Bank Right (d)
let	K_YawL = 90;				// Yaw Left (z)
let	K_YawR = 88;				// Yaw Right (x)
//	Views
let K_Look = 16;				// Pan (shift)
let K_VU45 = 36;				// View Up (alone or modifier)
let K_VD45 = 35;				// View Down (alone or modifier)
let K_VL45 = 33;				// Left 45 degrees
let K_VR45 = 45;				// Right 45 degrees
let K_VL90 = 34;				// Left 90 degrees
let K_VR90 = 46;				// Right 90 degrees
//	Toggle
let K_Soun = 83;				// Toggle sound (s)
let K_Paws = 80;				// Pause (p)
let K_Info = 73;				// Info (i)

//=	VIEW KEYS ==================//==============================================
let U45flg = 0;					// Up 45 degrees
let D45flg = 0;					// Down 45 degrees
let	L45flg = 0;					// Left 45 degrees
let R45flg = 0;					// Right 45 degrees
let L90flg = 0;					// Left 90 degrees
let R90flg = 0;					// Right 90 degrees

//= CAMERA =====================//==============================================
//- Create Cockpit Attach Point
let	CamPVC = makMsh();
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirObj.add(CamPVC); 	// Attach CamPVC to AirObj
//- Camera Inputs (External Camera linked to air_.AirObj; 1 Internal Camera Linked to cam_.PVC)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];			// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CamFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
//- Shared Variables
let cam_ = {
		sel: CamSel,			// View Selector (0 = External, 1 = Internal)
		num: CamNum,
		pan: 0,					// Pan Flag (1 = panning)
		// Camera
		lld: new THREE.Vector3().copy(CamLLD[CamSel]),	// cam_.rot Lat, Lon, Dst
		llz: new THREE.Vector3(), // External LLZ
		adj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		mmd: new THREE.Vector3().copy(CamMMD[CamSel]),	// In/Out - min,max,spd
		// Rotator
		rot: makMsh(),			// Camera Rotator
		mmr: new THREE.Vector3().copy(CamMMR[CamSel]),	// Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		par: CamPar[CamSel],	// Center of Rotation	
		flg: CamFlg[CamSel],	// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		lnk: CamLnk[CamSel],
		qat: new THREE.Quaternion(),
		obj: makMsh(),
		deg: makMsh()
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.rot.rotation.order = "YXZ";
	cam_.obj.rotation.order = "YXZ";
	cam_.deg.rotation.order = "YXZ";
	cam_.par.add(cam_.rot);			// Attach Rotator
	cam_.obj.add(cam_.deg);

//= HTML OVERLAY TEXT ==========================================================
let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
	AC_HiteElement.appendChild(AC_HiteNode);
let AC_PtchElement = document.getElementById("AC_Ptch");
let AC_PtchNode = document.createTextNode("");
	AC_PtchElement.appendChild(AC_PtchNode);
let AC_SpdZElement = document.getElementById("AC_SpdZ");
let AC_SpdZNode = document.createTextNode("");
	AC_SpdZElement.appendChild(AC_SpdZNode);
let AC_BankElement = document.getElementById("AC_Bank");
let AC_BankNode = document.createTextNode("");
	AC_BankElement.appendChild(AC_BankNode);
let AC_SpdXElement = document.getElementById("AC_SpdX");
let AC_SpdXNode = document.createTextNode("");
	AC_SpdXElement.appendChild(AC_SpdXNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
	AC_HeadElement.appendChild(AC_HeadNode);
let AC_DFlyElement = document.getElementById("AC_DFly");
let AC_DFlyNode = document.createTextNode("");
	AC_DFlyElement.appendChild(AC_DFlyNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
	On_PawsElement.appendChild(On_PawsNode);
let On_Info01Element = document.getElementById("On_Info01");
let On_Info01Node = document.createTextNode("");
	On_Info01Element.appendChild(On_Info01Node);
let On_Info02Element = document.getElementById("On_Info02");
let On_Info02Node = document.createTextNode("");
	On_Info02Element.appendChild(On_Info02Node);
let On_Info03Element = document.getElementById("On_Info03");
let On_Info03Node = document.createTextNode("");
	On_Info03Element.appendChild(On_Info03Node);
let On_Info04Element = document.getElementById("On_Info04");
let On_Info04Node = document.createTextNode("");
	On_Info04Element.appendChild(On_Info04Node);
let On_Info05Element = document.getElementById("On_Info05");
let On_Info05Node = document.createTextNode("");
	On_Info05Element.appendChild(On_Info05Node);
let On_Info06Element = document.getElementById("On_Info06");
let On_Info06Node = document.createTextNode("");
	On_Info06Element.appendChild(On_Info06Node);
let On_Info07Element = document.getElementById("On_Info07");
let On_Info07Node = document.createTextNode("");
	On_Info07Element.appendChild(On_Info07Node);
let On_Info08Element = document.getElementById("On_Info08");
let On_Info08Node = document.createTextNode("");
	On_Info08Element.appendChild(On_Info08Node);
let On_Info09Element = document.getElementById("On_Info09");
let On_Info09Node = document.createTextNode("");
	On_Info09Element.appendChild(On_Info09Node);

let AC_Hite, AC_Ptch, AC_SpdZ, AC_Bank, AC_SpdX, AC_Head, AC_DFly;
let On_Paws, On_Info01, On_Info02, On_Info03, On_Info04, On_Info05, On_Info06, On_Info07, On_Info08;

//= MAIN PROGRAMS ==============================================================
	loadAll();

//=	0 LOAD ALL =================//==============================================

function loadAll() {
	WaitScreen();				// init loading screen
	loadSkyBox();
	loadObject();
	loadAirObj();
}

//= WAIT SCREEN ================//==============================================

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 INITIALIZE ================//==============================================

function initAll() {
	initSkyBox();				// load skybox
	initAirObj();	
	initGrdTxt();
	grd_.SPS.y = air_.MapPos.y;	// Init Position
	grids = new GrdMap(grd_,scene);	// Init Grid Map
	grids.update(grd_);			// Mode Grid Map
	initRoads();
	makeTrees();
	initObject();				// Stationary Objects
	// Other
	initCamera(camera,cam_);	// position camera
	PawsText();
	InfoText();
	// Show stats
	if (StatOn) {				// show stats
		StatOn = new Stats({
			precision: 3,
			horizontal: false
		});
		StatOn.init(renderer);
		StatOn.domElement.style.cssText = "position:absolute;top:75%;left:95%;";
		container.appendChild(StatOn.dom);
	}
	LodFlg = 1;
}

//= 2 RENDER ===================//==============================================

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;												// Stop the function here.
	}
	if (controls.isLocked === true && !LodSnd) loadSounds();
	if (!PawsOn && LodFlg && controls.isLocked === true) {
		moveCamera(camera,cam_);
		// Move AirObj
		moveAirObj();
		// Move Objects
		grd_.SPS.copy(air_.MapSPS);	// Update Position
		grids.update(grd_);		// Mode Grid Map
		moveRoads();
		moveTrees();		
		moveObject();			// Move objects
		moveSounds();
		prntHUDval();			// change HUD value
		if (StatOn) StatOn.update(); // update stats
	}
	if (controls.isLocked === false && LodSnd) {
		stopSounds();
		SndFlg = 0;
	}
	renderer.renderAsync(scene, camera); // ### WebGPU requires Async
	renderer.resolveTimestampsAsync(THREE.TimestampQuery.RENDER); // r173
}

//= SKYBOX =====================//==============================================

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	// LensFlare
	if (LnFFlg) {				// SunFlare	
		LF0Txt = txtrLoader.load(LF0Src);
		LF1Txt = txtrLoader.load(LF1Src);
	}
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);	
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(LF0Txt,256,0));
			LF.addElement(new LensflareElement(LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

//= GRID MAP ===================================================================

//= Make Grid Map Textures =====================================================

function initGrdTxt() {
	initGr0Txt();
	initGr1Txt();
	initGr6Txt();
}

function initGr0Txt() {
	for (let n = 0; n < txtTot; n++) {
		// Make Large Image and Get ImageData
		context.fillStyle = GrdDrt;
		context.fillRect(0,0,dqSize,dqSize);
		G0DPtr[n] = context.getImageData(0,0,dqSize,dqSize);
		let dtData = G0DPtr[n].data;
		makeClr1(drtclr,dtData,1.6);	// Dirt
		if (n == 1) makeClr2(pstclr,dtData,4);	// Pasture
		if (n == 2) makeVrtL(drtclr,dtData,1.9,1.5);	// Plowed Line
		if (n == 3) makeVrtL(cvrclr,dtData,1.9,1.5);	// Bean Line
		if (n == 4) makeVrtL(whtclr,dtData,1.9,1.5);	// Wheat Line
		if (n == 5) makeVrtD(bnsclr,dtData,8);	// Bean Dots
		// Make Materials
		let DatTxt = new THREE.DataTexture(dtData, dqSize, dqSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.wrapS = DatTxt.wrapT = THREE.RepeatWrapping;
		DatTxt.offset.set(0,0);
		DatTxt.repeat.set(GrdMul,GrdMul);
		DatTxt.anisotropy = maxAnisotropy;
		DatTxt.needsUpdate = true;		
		G0MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		// Gr5Source = Resized Gr4Data
		// Note: Dividing a Repeated Data Can Lead to Odd Results
		// e.g. If Repeat X10 and then divide by 10, result = Data
		context.putImageData(G0DPtr[n],0,0);
		context.drawImage(canvas,0,0,dqSize,dqSize,0,0,Gr1Siz,Gr1Siz);		// Draw 1024 image into 1/3 of 512 canvas
		G1SPtr[n] = context.getImageData(0,0,Gr1Siz,Gr1Siz);				//
	}
}

function initGr1Txt() {
// This creates up to 81 unique 3X3 Textures (similar to FSX textures)
// Created using ImageData from Gr4IPtr and patterns from Gr4TPtr
// Stored by ID number
// Repeated 9X on the full map.	
	let dd, sd, idx;
	let fx = dtSize/Gr1Mul;
	// For Destination (9 locations arranged linearly)
	for (let n = 0; n < G0Indx.length; n++) {	// Destination
		// For 3X3 Source
		let stIndx = G0Indx[n];			// Index to this pattern
		idx = 0;
		for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
			for (let xs1 = 0; xs1 < 3; xs1++) {
				let ImgDat = G1SPtr[stIndx[idx]];	// Correct, but causes dirt lines
				context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				idx++;
			}
		}
		G1DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// This should be the 3X3 image saved
		let DatTxt = new THREE.DataTexture(G1DPtr[n].data,dtSize,dtSize);
		DatTxt.format = THREE.RGBAFormat;
		DatTxt.magFilter = THREE.LinearFilter;
		DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
		DatTxt.generateMipmaps = true;
		DatTxt.anisotropy = maxAnisotropy;
		DatTxt.needsUpdate = true;
		G1MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
		// Gr6Source = Resized Gr5Data		
		context.putImageData(G1DPtr[n],0,0);
		context.drawImage(canvas,0,0,dtSize,dtSize,0,0,Gr2Siz,Gr2Siz);
		G2SPtr[n] = context.getImageData(0,0,Gr2Siz,Gr2Siz);
	}
}

function initGr6Txt() {
	// Need 27 3X3 textures which will be repeated 27 times
	// Create Grid 6 Texture Data and Materials (9 squares repeated)
	let yd0, xd0;
	let fx = dtSize/Gr2Mul;
	let n = 0;
	// For Destination (9 locations arranged linearly)
	for (let ys0 = 0; ys0 < 3; ys0++) {	// Source of Each 9x9 Square
		for (let xs0 = 0; xs0 < 3; xs0++) {
			// Loads 3x3 Grid of Textures
			for (let ys1 = 0; ys1 < 3; ys1++) {	// Find source within 9x9 Square
				for (let xs1 = 0; xs1 < 3; xs1++) {
					let ImgDat = G2SPtr[G1Indx[ys0*27+xs0*3+ys1*9+xs1]];
					context.putImageData(ImgDat,Math.floor(xs1*fx),Math.floor(ys1*fx));
				}
			}
			//	
			G2DPtr[n] = context.getImageData(0,0,dtSize,dtSize);	// Saved, not used yet
			let DatTxt = new THREE.DataTexture(G2DPtr[n].data, dtSize, dtSize);
			DatTxt.format = THREE.RGBAFormat;
			DatTxt.magFilter = THREE.LinearFilter;
			DatTxt.minFilter = THREE.LinearMipMapLinearFilter;
			DatTxt.generateMipmaps = true;
			DatTxt.anisotropy = maxAnisotropy;
			DatTxt.needsUpdate = true;
			G2MPtr[n] = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});	
			n++;
		}
	}	
}

//= Make Textures ==============================================================

function makeClr1(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			dtData[idx  ] = red[i];
			dtData[idx+1] = grn[i];
			dtData[idx+2] = blu[i];
			dtData[idx+3] = 255;
		}
	}
}

function makeClr2(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let y = 0; y < dqSize; y++) {
		for (let x = 0; x < dqSize; x++) {
			i = Math.floor(Weight*Math.random());
			idx = (y*dqSize + x) * 4;
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}	
	}
}

// Make Vertical Line
function makeVrtL(dtColr,dtData,Weight1,Weight2) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight2*Math.random());
			if (i == 0) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight1*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

// Make Vertical Dots
function makeVrtD(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	let idx, i;
	for (let x = 4; x < dqSize; x+=8) {	// Rows
		for (let y = 0; y < dqSize; y++) {
			idx = (y*dqSize + x) * 4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 0 || i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
			idx = idx+4;
			i = Math.floor(Weight*Math.random());
			if (i == 1) {
				dtData[idx  ] = red[i];
				dtData[idx+1] = grn[i];
				dtData[idx+2] = blu[i];
				dtData[idx+3] = 255;
			}
		}
	}
}

/* Roads ==================================================================*/

function initRoads() {
	let txtrod,matrod,georod;
	makeRClr(rodclr,r0Data,1);
	txtrod = new THREE.DataTexture(r0Data, r0Size, r0Size);
	txtrod.format = THREE.RGBAFormat;
	txtrod.magFilter = THREE.LinearFilter;
	txtrod.minFilter = THREE.LinearMipMapLinearFilter;
	txtrod.generateMipmaps = true;
	txtrod.wrapS = txtrod.wrapT = THREE.RepeatWrapping;
	txtrod.offset.set(0,0);
	Rod1.Txt = txtrod;
	Rod2.Txt = txtrod;
	initRoad2(Rod1);
	initRoad2(Rod2);
}

function moveRoads() {
// Convert Distances into Meters to match landscape program
	moveRoad2(Rod1);
	moveRoad2(Rod2);
}

function makeRClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

function initRoad2(Rod) {

	// Load Variables
	Rod.RCi = Rod.RCs-1;				// Max Index Value
	Rod.MZV[Rod.RCi] = 0;				// Z-Values
	Rod.MXV[Rod.RCi] = 0;				// X-Values
	Rod.Nor = Rod.RCi;					// Max North Square (updated)
	Rod.Est = Rod.RCi;					// Max East Square (updated)
	Rod.Num = Rod.RCs * Rod.RCs;		// Size of array
	Rod.Ptr[Rod.Num-1] = 0;				// Mesh Pointers

	if (Rod.Typ == 1) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz-0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(25*Ft2Mtr,Rod.Siz);	// N/S Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
	
	if (Rod.Typ == 2) {
		// Compute Starting Z and X Values
		let zx = -0.5*(Rod.RCs)*Rod.Siz+0.5*GrdSiz;
		for (let i = 0; i < Rod.RCs; i++) {
			Rod.MZV[i] = zx;
			Rod.MXV[i] = zx;
			zx = zx + Rod.Siz;
		}
		let geometry = new THREE.PlaneGeometry(Rod.Siz,25*Ft2Mtr);	// E/W Road;
		let DatTxt = Rod.Txt;
		DatTxt.repeat.set(10,10);
		DatTxt.anisotropy = maxAnisotropy;		// ###
		DatTxt.needsUpdate = true;
		let material = new THREE.MeshLambertNodeMaterial({colorNode: texture(DatTxt)});
		for (let n = 0; n < Rod.Num; n++) {	// Source
			Rod.Ptr[n] = new THREE.Mesh(geometry,material);
			if (Rod.Shd == 1) Rod.Ptr[n].receiveShadow = true;
		}
	}
			
	let n = 0;
	// Set Starting Position of Squares
	for (let z = 0; z < Rod.RCs; z++) {		// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Column
			Rod.Ptr[n].rotation.x = -90*DegRad;
			scene.add(Rod.Ptr[n]);
			Rod.Ptr[n].renderOrder = 1;
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*AltAdj+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

// Move Roads
function moveRoad2(Rod) {
	let j = 0;
	let v = 0; 
	let max = 0.5*Rod.RCs*Rod.Siz;
	let min = -max;
	// Update Z and X-Values
	for (let i = 0; i < Rod.RCs; i++) {
		Rod.MZV[i] = Rod.MZV[i] - grd_.SPS.z;	// Rows
		Rod.MXV[i] = Rod.MXV[i] - grd_.SPS.x;	// Columns
	}
	// Test North/South
	if (grd_.SPS.z < 0) {					// If Moving South
		j = Rod.Nor;
		if (Rod.MZV[j] >= max) {
			v = min+(Rod.MZV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Nor = Rod.Nor - Rod.Stp;
			if (Rod.Nor < 0) Rod.Nor = Rod.Nor + Rod.RCs;
		}
	}
	if (grd_.SPS.z > 0) {					// If Moving North
		j = Rod.Nor + 1;
		if (j > Rod.RCi) j = 0;
		if (Rod.MZV[j] <= min) {
			v = max-(min-Rod.MZV[j]);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MZV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Nor = Rod.Nor + Rod.Stp;
			if (Rod.Nor > Rod.RCi) Rod.Nor = Rod.Nor - Rod.RCs;
		}
	}
	// Test East/West
	if (grd_.SPS.x < 0) {					// If Moving West
		j = Rod.Est;
		if (Rod.MXV[j] >= max) {
			v = min+(Rod.MXV[j]-max);
			for (let i = 0; i < Rod.Stp; i++) {
				Rod.MXV[j] = v;
				j = j - 1;
				if (j < 0) j = Rod.RCi;
				v = v - Rod.Siz;
			}
			Rod.Est = Rod.Est - Rod.Stp;
			if (Rod.Est < 0) Rod.Est = Rod.Est + Rod.RCs;
		}
	}
	if (grd_.SPS.x > 0) {						// If Moving East
		j = Rod.Est + 1;
		if (j > Rod.RCi) j = 0;	
		if (Rod.MXV[j] <= min) {
			v = max-(min-Rod.MXV[j]);
			for (let i = 0; i < Rod.Stp; i++) {			
				Rod.MXV[j] = v;
				j++;
				if (j > Rod.RCi) j = 0;
				v = v + Rod.Siz;
			}
			Rod.Est = Rod.Est + Rod.Stp;
			if (Rod.Est > Rod.RCi) Rod.Est = Rod.Est - Rod.RCs;
		}
	}
	// Set Position
	let n = 0;
	for (let z = 0; z < Rod.RCs; z++) {	// Row
		for (let x = 0; x < Rod.RCs; x++) {	// Col
			Rod.Ptr[n].position.set(Rod.MXV[x],-grd_.SPS.y*AltAdj+0.01,-Rod.MZV[z]);
			n++;
		}
	}
}

//= TREES ======================================================================

//- Make Trees ------------------------------------------------------------------

function makeTrees() {
	let points = [
		new THREE.Vector2(4.0,-6.7),	// Bot
		new THREE.Vector2(4.9,-3.0),
		new THREE.Vector2(4.2, 3.0),
		new THREE.Vector2(3,5, 2.0),
		new THREE.Vector2(1.8, 5.8),
		new THREE.Vector2(0.1, 6.0)		// Top
	];
	let gomtre = new THREE.LatheGeometry(points,6);
	let gomtrn = new THREE.BoxGeometry(0.9,3.0,0.9);
	let gomshd = new THREE.CircleGeometry(6.0,16);
	// Make Texture	
	makeTClr(treclr,t0Data,1.9);
	let txttre = new THREE.DataTexture(t0Data, t0Size, t0Size);
	txttre.format = THREE.RGBAFormat;
	txttre.magFilter = THREE.LinearFilter;
	txttre.minFilter = THREE.LinearMipMapLinearFilter;
	txttre.generateMipmaps = true;
	txttre.anisotropy = maxAnisotropy;	// ###
	txttre.needsUpdate = true;
	let mtltre = new THREE.MeshLambertNodeMaterial({colorNode: texture(txttre)});
	let mtltrn = new THREE.MeshLambertNodeMaterial({colorNode: color(0x161005)});
	let mtlshd = new THREE.MeshBasicNodeMaterial({colorNode: color(0x000000),transparent:true,opacity:0.5,depthWrite: false});
	// Make Prototype Tree
	let tree0 = new THREE.Mesh(gomtre,mtltre);
	let trnk = new THREE.Mesh(gomtrn,mtltrn);
	trnk.position.y = -7.9;
	tree0.add(trnk);
	let shad = new THREE.Mesh(gomshd,mtlshd);
	shad.position.y = -9.4;
	shad.rotation.x = -90*DegRad;
	tree0.add(shad);
	Trees[0] = tree0.clone();
	// Make Row of Trees
	let sx = 15.0;
	let ry = 13.7;
	let dy = 13.7;
	let px = sx;
	for (let x = 0; x < 10; x++) {
		let tree = tree0.clone();
		tree.position.x = px;
		ry = Mod360(360*Math.random());
		tree.rotation.y = ry*DegRad;
		tree.rotation.z = Mod360(2*Math.random()*DegRad);
		tree.rotation.x = Mod360(2*Math.random()*DegRad);
		ry = ry+dy;
		px = px+sx;
		Trees[0].add(tree);
	}
	Trees[0].position.x = 0;
	Trees[0].position.y = 9.8;
	let pz = 90;
	for (let n = 1; n < TreTot; n++) {
		Trees[n] = Trees[0].clone();
		scene.add(Trees[n]);
		Trees[n].rotation.y = (Math.floor(Math.random()+0.5))*90*DegRad;
		Trees[n].position.y = 9.8;
		TreePX[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
		TreePZ[n] = GrdSiz*Math.floor(27*(Math.random()-0.5))+50*Ft2Mtr;
	}
	moveTrees();
}

//- Move Trees -----------------------------------------------------------------

function moveTrees() {
	// Convert Distances into Meters to match landscape program
	let a = 13.5*GrdSiz;
	for (let n = 0; n < TreTot; n ++) {
		// Set Position 
		let x = TreePX[n]-air_.MapPos.x-GrdSiz/2;
		if (x > a) x = x - 2*a;
		if (x < -a) x = x + 2*a;
		let z = air_.MapPos.z-TreePZ[n]-GrdSiz/2;
		if (z > a) z = z - 2*a;
		if (z < -a) z = z + 2*a;
		let y = -grd_.SPS.y*AltAdj+9.8;	// Objects elevate above ground as we climb to prevent flicker
		Trees[n].position.set(x,y,z);
	}
}

function makeTClr(dtColr,dtData,Weight) {
	// Load 2 colors
	for (let i = 0; i < 2; i++) {
		let clr = new THREE.Color(dtColr[i]);
		red[i] = Math.floor(clr.r * 255);
		grn[i] = Math.floor(clr.g * 255);
		blu[i] = Math.floor(clr.b * 255);
	}
	// Assign colors
	let idx, i;
	for (let n = 0; n < t0Area*4; n+=4) {
		i = Math.floor(Weight*Math.random());
		dtData[n  ] = red[i];
		dtData[n+1] = grn[i];
		dtData[n+2] = blu[i];
		dtData[n+3] = 255;
	}
}

/* Load and Move Fixed Objects ===============================================*/
/* These objects include the airfield, islands and hangar */

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = txtrLoader.load(ObjTxt[i]);
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gltfLoader.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(32000*Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

//= HELICOPTER =================//==============================================

//- LOAD =======================//==============================================
function loadAirObj() {
	let fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {			// The OnLoad function
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (
				child.name == "glass_fuse0" ||
				child.name == "glass_doors" ||
				child.name == "glass_doorL" ||
				child.name == "glass_doorR")
			{
				child.castShadow = false;
				child.receiveShadow = false;
			}
		});
		let AirExt = gltf.scene;
		AirExt.rotation.order = "YXZ";
		AirExt.scale.setScalar(Ft2Mtr);
		/* Animations ------------------------------------------------------------- */
		// Main Rotor - Bank
		let clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMKAction");
		mxRtrK = new THREE.AnimationMixer(AirExt);
		let actun = mxRtrK.clipAction(clip);
		actun.play();
		if (mxRtrK) mxRtrK.setTime(bnkprp/anmfps);
		// Main Rotor - Pitch
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMPAction");
		mxRtrP = new THREE.AnimationMixer(AirExt);
		actun = mxRtrP.clipAction(clip);
		actun.play();
		if (mxRtrP) mxRtrP.setTime(pitprp/anmfps);
		// Main Rotor - Blades
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMBAction");
		mxRtrB = new THREE.AnimationMixer(AirExt);
		actun = mxRtrB.clipAction(clip);
		actun.play();
		if (mxRtrB) mxRtrB.setTime(spnprp/anmfps);
		// Main Rotor - Vertical
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMVAction");
		mxRtrV = new THREE.AnimationMixer(AirExt);
		actun = mxRtrV.clipAction(clip);
		actun.play();
		if (mxRtrV) mxRtrV.setTime(spnprp/anmfps);
		// Tail Rotor
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorTAction");
		mxRtrT = new THREE.AnimationMixer(AirExt);
		actun = mxRtrT.clipAction(clip);
		actun.play();
		if (mxRtrT) mxRtrT.setTime(spnrtr/anmfps);
		// DoorL
		clip = THREE.AnimationClip.findByName(gltf.animations, "doorLAction");
		mxDorL = new THREE.AnimationMixer(AirExt);
		actun = mxDorL.clipAction(clip);
		actun.play();
		if (mxDorL) mxDorL.setTime(doormn/anmfps);
		// DoorR
		clip = THREE.AnimationClip.findByName(gltf.animations, "doorRAction");
		mxDorR = new THREE.AnimationMixer(AirExt);
		actun = mxDorR.clipAction(clip);
		actun.play();
		if (mxDorR) mxDorR.setTime(doormn/anmfps);
		//- Save
		air_.AirObj.add(AirExt);
	});
}

//= INIT =======================//==============================================
function initAirObj() {
	initFlight();				// initalize variables
}

//= MOVE =======================//==============================================
function moveAirObj() {
	// Altitude Change
	air_.AltDif = AltDif * AltMul + InpAlt;
	AltDif = 0;					// Reset
	// Pitch Speed Change
	air_.RotDif.x = InpMos.y * PYBmul.x;
	air_.RotDif.x = PoM360(Mod360(air_.RotDif.x + InpACP));
	InpMos.y = 0;				// Reset
	// Bank Speed Change
	air_.RotDif.z = InpMos.x * PYBmul.z;
	air_.RotDif.z = PoM360(Mod360(air_.RotDif.z + InpACB)); // Inputs are +/-
	InpMos.x = 0;				// Reset
	// Input Yaw
	air_.RotDif.y = InpYaw;
	// Compute Rotation and Vectors
	moveFlight();
	/* Animations ----------------------------------------------------------- */
	// Rotors - Speed
	let prpspd = 33;
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359; // A complete circle
	/* Aircraft ------------------------------------------------------------- */
	// Rotate Aircraft (order:YXZ)
	air_.AirObj.rotation.y = Mod360(-air_.AirRot.y) * DegRad; // Heading
	// Pitch - exclude first 11 degrees
	let PitDfR = air_.AirRot.x;
	if (PitDfR > 0) {
		PitDfR = PitDfR - 11;
		if (PitDfR < 0) PitDfR = 0;
	}
	if (PitDfR < 0) {
		PitDfR = PitDfR + 11;
		if (PitDfR > 0) PitDfR = 0;
	}
	air_.AirObj.rotation.x = Mod360(PitDfR) * DegRad; // Pitch
	// Bank
	// Pitch - exclude first 11 degrees
	let BnkDfR = PoM360(air_.AirRot.z);
	if (BnkDfR > 0) {
		BnkDfR = BnkDfR - 11;
		if (BnkDfR < 0) BnkDfR = 0;
	}
	if (BnkDfR < 0) {
		BnkDfR = BnkDfR + 11;
		if (BnkDfR > 0) BnkDfR = 0;
	}
	air_.AirObj.rotation.z = Mod360(360 - BnkDfR) * DegRad; // Bank
	// Main Rotor - Speed
	if (mxRtrB) mxRtrB.setTime(spnprp/anmfps);
	if (mxRtrV) mxRtrV.setTime(spnprp/anmfps);
	// Main Rotor - Pitch
	pitprp = 180 + air_.AirRot.x * 179 / 5;
	if (pitprp > 359) pitprp = 359;
	if (pitprp < 1) pitprp = 1; 
	if (mxRtrP) mxRtrP.setTime(pitprp/anmfps);
	// Main Rotor - Bank
	bnkprp = 180 + PoM360(air_.AirRot.z) * 179 / 5;
	if (bnkprp > 359) bnkprp = 359;
	if (bnkprp < 1) bnkprp = 1; 
	if (mxRtrK) mxRtrK.setTime(bnkprp/anmfps);
	// Tail Rotor
	if (mxRtrT) mxRtrT.setTime(spnprp/anmfps);
	// Doors
//	if (mxDoor) mxDoor.setTime(doormn/anmfps);
	// View Keys ---------------------------------------------------------------
	if (cam_.pan < 1) {			// Only If Not Panning		
		// If No Keys Pressed, Set Default View
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg < 1)	{
			if (cam_.flg) cam_.lld.x = 0;	// Internal view
			else cam_.lld.x = -12.5;		// External view
			cam_.lld.y = 0;
		}
		// Down 45
		else if (D45flg) {
			cam_.lld.x = 0;
			// Look Back
			if ((L90flg) && (L90flg) && (R90flg)) cam_.lld.y = 180;
			// Look Back Left 90 + 45
			else if (L90flg) cam_.lld.y = 135;
			// Look Back Right 270 - 45
			else if (R90flg) cam_.lld.y = 225;
			// Look Down
			else {
				cam_.lld.y = 0;
				cam_.lld.x = 45;
			}
		}
		// Up 45
		else if (U45flg) {
			cam_.lld.x = 315;
			if (cam_.flg == 0 && (air_.GrdFlg)) cam_.lld.x = 0;
			// Look Up Left 45
			if (L45flg) cam_.lld.y = 45;
			// Look Up Right 45
			else if (R45flg) cam_.lld.y = 315;
			// Look Up Left 90
			else if (L90flg) cam_.lld.y = 90;
			// Look Up Right 90
			else if (R90flg) cam_.lld.y = 270;
			// Look Up
			else cam_.lld.y = 0;
		}
		// Level
		else {
			cam_.lld.x = 0;
			// Look Left 45
			if (L45flg) cam_.lld.y = 45;
			// Look Right 45
			else if (R45flg) cam_.lld.y = 315;
			// Look Left 90
			else if (L90flg) cam_.lld.y = 90;
			// Look Right 90
			else if (R90flg) cam_.lld.y = 270;
		}
	}
}

//= FLIGHT MODULE ==============//==============================================

function initFlight() {
	// Transfer Constants from dat_ to air_
	let dat_ = air_.AirDat;
	air_.MaxThr = dat_.MaxThr;	// Maximum Thrust
	air_.MaxAng = dat_.MaxAng;	// Maximum Rotor and Body Angle
	air_.MaxKPH = dat_.MaxKPH;	// Maximum Speed
	air_.MinAng = dat_.MinAng;	// Minimum Rotor and Body Angle for Max Speed
	air_.ACMass = dat_.ACMass;	// Airplane Mass
	air_.FrntAr = dat_.FrntAr;	// Frontal Area
	air_.DrgCdz = dat_.DrgCdz;	// Coefficient of Drag (z-direction)
	air_.DrgCdx = dat_.DrgCdx;	// Coefficient of Drag (x-direction)
	air_.MdlAlt = dat_.MdlAlt;	// Model Center Height above Ground (meters)
	// Starting Altitude
	let MinAlt = air_.GrdZed + air_.MdlAlt; // Minimum Altitude (ASL = GL+AGL)
	if (!air_.GrdFlg && air_.MapPos.y <= MinAlt) _landFlight(MinAlt);
	moveFlight();
}

//= MOVE =======================//==============================================
function moveFlight() {
// Inputs: air_.GrdFlg, GrdZed, air_.AltDif, air_.MapSpd.z, air_.AirRot.x, air_.AirRot.z
	// Compute Vectors
	DLTime = 1/60;				// Delta Time (1/60 seconds)
	DLTim2 = DLTime*DLTime;
	let FrcAcc = DLTim2 / air_.ACMass;
	if (air_.GrdFlg && air_.AltDif > 0) air_.GrdFlg = 0;	// If going to leave ground
	if (!air_.GrdFlg) {			// Compute Change in mps, convert MapSpd to mpf
		// 1. Recompute Horizontal Airspeed (mps) - since ACH (which redirects AirSpd.xz) may have changed
		// Use mps so that DynPrs and Drag is correct
		let ACHRad = air_.AirRot.y * DegRad;
		let PSpdZS = air_.MapSpd.z * Math.cos(-ACHRad) - air_.MapSpd.x * Math.sin(-ACHRad);
		let PSpdXS = air_.MapSpd.z * Math.sin(-ACHRad) + air_.MapSpd.x * Math.cos(-ACHRad);
		air_.AirSpd.z = PSpdZS / air_.DLTime; // Convert to mps
		air_.AirSpd.x = PSpdXS / air_.DLTime;
		// 2. Compute Total Drag at Those Speeds ...............................
		// Forward/Backwards Drag Force
		let DynPrZ = 0.5 * air_.AirDSL * (air_.AirSpd.z * air_.AirSpd.z); // Dynamic Pressure (Absolute value)
		let PDrgZF = DynPrZ * air_.FrntAr * air_.DrgCdz; // Parasitic Drag
		if (PSpdZS < 0) PDrgZF = -DynPrZ * air_.DrgCdx/air_.DrgCdz; // Use large drag to limit max speed
		// Lateral Drag Force
		let DynPrX = (air_.AirSpd.x * air_.AirSpd.x) * air_.AirDSL / 2; // Dynamic Pressure
		let PDrgXF = DynPrX * air_.FrntAr * air_.DrgCdx; // Parasitic Drag
		if (PSpdXS < 0) PDrgXF = -PDrgXF; // If going left, drag = right
		// Total Drag
		let DrgTot = Math.abs(PDrgZF) + Math.abs(PDrgXF);
		// 3. Forward Speed (mps) ..............................................	
		// Thrust Force
		let ACPRad = -air_.AirRot.x * DegRad;
		let PThrZF = air_.MaxThr * Math.sin(ACPRad); // Propeller Acceleration - Forward
		// Net Force -> Net Acceleration and Speed (mpf)
		let PnetZF = PThrZF - PDrgZF; // Net Force
		let PnetZA = PnetZF * FrcAcc; // Net Acc (mpf)
		PSpdZS = PSpdZS + PnetZA; // new Speed (mpf)
		// 4. Lateral Speed (mps) ..............................................
		// Thrust Force
		let ACBRad = air_.AirRot.z * DegRad;
		let PThrXF = air_.MaxThr * Math.sin(ACBRad); // Propeller Acceleration - Lateral
		// Net Force -> Net Acceleration and Speed (mpf)
		let PnetXF = PThrXF - PDrgXF; // Net Force
		let PnetXA = PnetXF * FrcAcc; // Net Acc (mpf)
		PSpdXS = PSpdXS + PnetXA; // new Speed (mpf)
		// 5. Vertical Speed (mpf) .............................................
		air_.AirSpd.y = air_.AirSpd.y + air_.AltDif;
		if (air_.AirSpd.y > KeyVal.y) air_.AirSpd.y = KeyVal.y; // Max Up
		if (air_.AirSpd.y < -KeyVal.y) air_.AirSpd.y = -KeyVal.y; // Max Down
		// 6. Compute MSpd (mps to mpf)
		air_.MapSpd.z = PSpdZS * Math.cos(ACHRad) - PSpdXS * Math.sin(ACHRad);
		air_.MapSpd.x = PSpdZS * Math.sin(ACHRad) + PSpdXS * Math.cos(ACHRad);
		air_.MapSpd.y = air_.AirSpd.y; // mpf
		//	Save for Display Only (mps)
		air_.AirSpd.z = PSpdZS / DLTime;
		air_.AirSpd.x = PSpdXS / DLTime;
		//- Rotate Helicopter --------------------------------------------------
		// ACPitch
		let MaxAng = air_.MinAng+(air_.MaxAng-air_.MinAng) * (1-air_.AirSpd.z/(air_.MaxKPH/3.6));
		air_.AirRot.x = air_.AirRot.x + air_.RotDif.x;
		if (air_.AirRot.x > MaxAng) air_.AirRot.x = MaxAng;
		else if (air_.AirRot.x < -MaxAng) air_.AirRot.x = -MaxAng;
		// ACBank
		air_.AirRot.z = Mod360(air_.AirRot.z + air_.RotDif.z);
		if (air_.AirRot.z > air_.MaxAng && air_.AirRot.z < 180) air_.AirRot.z = air_.MaxAng;
		else if (air_.AirRot.z < (360-air_.MaxAng) && air_.AirRot.z > 180) air_.AirRot.z = (360-air_.MaxAng);
		// ACYaw
		air_.AirRot.y = Mod360(air_.AirRot.y + air_.RotDif.y);
		// Weather-Vane Adjustment
		let YawAdj = 0;
		let TotSpd = Math.sqrt(air_.AirSpd.z*air_.AirSpd.z+air_.AirSpd.x*air_.AirSpd.x);
		TotSpd = Math.abs(TotSpd);
		if (TotSpd) { // if moving
			air_.DirFlt = Mod360(Math.atan2(air_.MapSpd.x,air_.MapSpd.z) * RadDeg);
			let DirDif = Mod360(air_.DirFlt-air_.AirRot.y);	// Difference
			DirDif = PoM360(DirDif)*DegRad;
			YawAdj = Math.sin(DirDif); // Range = 0, +1, 0, -1
			if (DirDif > 90) YawAdj = 1;
			if (DirDif < -90) YawAdj = -1;
			YawAdj = YawAdj * TotSpd / air_.MaxKPH;
			YawAdj = YawAdj * 10;
			air_.AirRot.y = air_.AirRot.y + YawAdj;
		}
//		air_.RotDif.y = air_.RotDif.y + YawAdj; // Why not work?
//		console.log(YawAdj);
	}
	// Compute Map Pos (MapSpd = mpf)
	air_.MapPos.z = air_.MapPos.z + air_.MapSpd.z;
	air_.MapPos.x = air_.MapPos.x + air_.MapSpd.x;
	air_.MapPos.y = air_.MapPos.y + air_.MapSpd.y; // ASL
	// Landing Altitude
	let MinAlt = air_.GrdZed + air_.MdlAlt; // Minimum Altitude (ASL = GL+AGL)
	if (!air_.GrdFlg && air_.MapPos.y <= MinAlt) _landFlight(MinAlt);
	// Compute Speeds
	air_.SpdKPH = air_.AirSpd.z/1000; // (KPH)
	air_.SpdMPS = air_.SpdKPH/1000; // (mps)
	air_.MapSPS.x = air_.MapSpd.x; // (mpf)
	air_.MapSPS.y = air_.MapPos.y; // (meters)
	air_.MapSPS.z = air_.MapSpd.z; // (mpf)
	air_.AirObj.rotation.set(air_.AirRot.x*DegRad,air_.AirRot.y*DegRad,air_.AirRot.z*DegRad);
}

function _landFlight(MinAlt) {
		air_.GrdFlg = 1;	// If Flag Not Set and Hit Ground
		air_.MapPos.y = MinAlt;	// Altitude = GL + AGL
		// Inputs
		air_.AltDif = 0;
		air_.RotDif.x = 0;
		air_.RotDif.z = 0;		
		// Rotation
		air_.AirRot.x = 0;
		air_.AirRot.z = 0;
		// AirSpeed
		air_.AirSpd.z = 0;
		air_.AirSpd.x = 0;
		air_.AirSpd.y = 0;
		// MapSpeed
		air_.MapSpd.z = 0;
		air_.MapSpd.x = 0;
		air_.MapSpd.y = 0;
		// DirFlt
		air_.DirFlt = air_.AirRot.y;	
}

//= SUBROUTINES ================//============================================

//- Convert degrees to 360
function Mod360(deg) {
	while (deg < 0) deg = deg+360; // Make deg a positive number
	deg = deg % 360;			// Compute remainder of any number divided by 360
return deg;}

//- Converts 360 degrees to +/- 180
function PoM360(deg) {
	if (deg > 180) deg = deg-360;
return deg;}

//- Limit Maximum +/- Value
function MaxVal(x, max) {
	if (x > 0 && x >  max) x =  max;
	if (x < 0 && x < -max) x = -max;
return x;}

//- Make Mesh ------------------------------------------------------------------
function makMsh() {
	let geometry = new THREE.BoxGeometry(0.01,0.01,0.01);
	let material = new THREE.MeshBasicNodeMaterial({colorNode:color("black"),transparent:true,opacity:0});
	let mesh = new THREE.Mesh(geometry,material);
return mesh;}

//= SOUNDS =====================//==============================================

//- Load and Initialize Sounds -------------------------------------------------
function loadSounds() {
	// Load Sounds .............................................................
	let audioLoader = new THREE.AudioLoader();
	let RefDst = 25;			// Reference distance for Positional Audio
	// My Engine
	let fname = ACPath + "sounds/" + EngSrc;
	audioLoader.load(fname, function(buffer) {
		EngSnd.setBuffer(buffer);
		EngSnd.setRefDistance(RefDst);
		EngSnd.setLoop(true);
		EngSnd.setVolume(0);
	});
	// Init Sounds .............................................................
	let	listener = new THREE.AudioListener();
	camera.add(listener);
	// My Engine
	EngSnd = new THREE.PositionalAudio(listener);
	EngMsh.add(EngSnd);			// Engine
	air_.AirObj.add(EngMsh);
	//- Set Flag
	LodSnd = 1;	
}

// Change Sounds
function moveSounds() {
	// My Engine
	EngSnd.setVolume(EngVol);
	EngSnd.setPlaybackRate(1);
}

//- Play Sounds ----------------------------------------------------------------
function playSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (!EngSnd.isPlaying) EngSnd.play();
}

//- Stop Sounds ----------------------------------------------------------------
function stopSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (EngSnd.isPlaying) EngSnd.stop();
}

//= CAMERA =====================//==============================================

function initCamera(camera,cam_) {
	camera.position.z = -cam_.lld.z;
	camera.rotation.y = cam_.adj*DegRad;
	cam_.rot.add(camera);		// Attach to rotator
	// Common Changes
	cam_.lld.copy(CamLLD[cam_.sel]);		// Restore Saved Values
	cam_.mmd.copy(CamMMD[cam_.sel]);		// In/Out - min, max, spd
	cam_.adj = CamAdj[cam_.sel];			// Load Adjustment
	camera.rotation.y = cam_.adj*DegRad;	// 180 = Looking in
	cam_.mmr.copy(CamMMR[cam_.sel]);		// Rotation min, max, spd
	cam_.par = CamPar[cam_.sel]				// Load New Parent
	cam_.par.add(cam_.rot);					// Attach Rotators
	cam_.flg = CamFlg[cam_.sel];			// 1 = cockpit
	cam_.lnk = CamLnk[cam_.sel];			// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);

}

function moveCamera(camera,cam_) {
	// Move Camera In/Out
	camera.position.z = -cam_.lld.z;
	// PointerLockControls
	if (cam_.pan) {
		cam_.lld.x = cam_.lld.x - InpMos.y * cam_.mmr.z;				// Camera Position (Lat)
		cam_.lld.x = MaxVal(cam_.lld.x,cam_.mmr.x);
		cam_.lld.y = Mod360(cam_.lld.y + InpMos.x * cam_.mmr.z);		// Camera Position (Lon)
		// Internal View
		if (cam_.flg) {											// Range: 250 to 360/0 to 110
			if (cam_.lld.y > 180 && cam_.lld.y < (360-cam_.mmr.y)) cam_.lld.y = (360-cam_.mmr.y);
			if (cam_.lld.y < 180 && cam_.lld.y > cam_.mmr.y) cam_.lld.y = cam_.mmr.y;
		}
		// External View
		else {
			if (air_.GrdFlg && cam_.lld.x > -12.5) cam_.lld.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// Adjust Camera Rotators
	// In internal view, the camera is facing out - view matches rotation
	if (cam_.flg) {
		cam_.rot.rotation.x = Mod360(cam_.lld.x)*DegRad;
		cam_.rot.rotation.y = Mod360(-cam_.lld.y)*DegRad;
	}
	// In external view, the camera is facing in and the armature is pointing out:
	else {
		cam_.rot.rotation.x = Mod360(-cam_.lld.x+0.5*air_.AirRot.x)*DegRad;
		cam_.rot.rotation.y = Mod360(180-cam_.lld.y)*DegRad;		
	}
}

//= OUTPUTS ====================//==============================================

// Change HUD Values
function prntHUDval() {
	AC_Hite = air_.MapPos.y*Mtr2Ft; // Altitude (feet)
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);
	AC_Ptch = air_.AirRot.x;	// Pitch (deg)
	AC_PtchNode.nodeValue = AC_Ptch.toFixed(0);
	AC_SpdZ =  air_.AirSpd.z * 3.6 * Km2Mil; // Speed - Forward (mph)
	AC_SpdZNode.nodeValue = AC_SpdZ.toFixed(0);
	AC_Bank = air_.AirRot.z;	// Bank (deg)
	AC_BankNode.nodeValue = AC_Bank.toFixed(0);
	AC_SpdX = air_.AirSpd.x * 3.6 * Km2Mil; // Speed - Lateral (mph)
	AC_SpdXNode.nodeValue = AC_SpdX.toFixed(0);
	AC_Head = Mod360(Math.round(air_.AirRot.y)); // Heading (deg)
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_DFly = air_.DirFlt;		// Direction of Flight (deg)
	AC_DFlyNode.nodeValue = AC_DFly.toFixed(0);
}

//	Paused On
function PawsText(){
	if (PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//	Info
function InfoText() {
	if (!InfoOn) onInfo0();
	else if (InfoOn == 1) onInfo1();
	else if (InfoOn == 2) onInfo2();
}

//	Info Off
function onInfo0(){
	On_Info01Node.nodeValue = "Info : Press I";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

// Info On
function onInfo1(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "CONTROLS";
	On_Info03Node.nodeValue = "Mouse Wheel or Q/E Keys change Altitude";
	On_Info04Node.nodeValue = "Mouse, Arrow or W/S Keys change Pitch";
	On_Info05Node.nodeValue = "Mouse, Arrow or A/D Keys change Bank";
	On_Info06Node.nodeValue = "Mouse Buttons or Z/X Keys change Yaw";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "S Key toggles sound";
}

// Info On
function onInfo2(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "VIEW KEYS";
	On_Info03Node.nodeValue = "Shift Key and Mouse pans around aircraft";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "DELETE/PAGE DOWN Keys look left/right";
	On_Info06Node.nodeValue = "Above plus HOME Key looks up";
	On_Info07Node.nodeValue = "END Key plus DELETE/PAGE DOWN Keys look back";
	On_Info08Node.nodeValue = "All 3 Keys to look back";
	On_Info09Node.nodeValue = "";
}

//= INPUTS =====================================================================
// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//- MOUSE ----------------------------------------------------------------------

//- Mouse Buttons (Down) -------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		InpYaw = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		InpYaw = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ---------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		InpYaw = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		InpYaw = 0;
	}
}

// Mousewheel - Power
function onDocumentMouseWheel(event) {
	event.preventDefault();
	AltDif = - event.deltaY;
}

//- KEYBOARD -------------------------------------------------------------------

//- Keyboard (Down) ------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_AltU) InpAlt = 0.001;		// Altitude Up
	if (event.keyCode == K_AltD) InpAlt = -0.001;		// Altitude Down
	if (event.keyCode == A_PitU) InpACP = KeyVal.x;		// Pitch Up
	if (event.keyCode == A_PitD) InpACP = -KeyVal.x;	// Pitch Down
	if (event.keyCode == A_BnkL) InpACB = -KeyVal.z;	// Bank Left
	if (event.keyCode == A_BnkR) InpACB = KeyVal.z;		// Bank Right
	if (event.keyCode == K_PitU) InpACP = KeyVal.x;		// Pitch Up
	if (event.keyCode == K_PitD) InpACP = -KeyVal.x;	// Pitch Down
	if (event.keyCode == K_BnkL) InpACB = -KeyVal.z;	// Bank Left
	if (event.keyCode == K_BnkR) InpACB = KeyVal.z;		// Bank Right
	if (event.keyCode == K_YawL) InpYaw = -KeyVal.y;	// Yaw Left
	if (event.keyCode == K_YawR) InpYaw = KeyVal.y;		// Yaw Right
	// Views
	if (event.keyCode == K_VU45) D45flg = 1;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 1;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 1;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 1;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 1;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 1;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.pan = 1;			// Pan View
	// Toggle
	if (event.keyCode == K_Paws) toglPaws();			// Toggle Pause
	if (event.keyCode == K_Info) toglInfo();			// Toggle Information
	if (event.keyCode == K_Soun) toglSoun();			// Toggle Sound
}

//-	Keyboard (Up) --------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_AltU) InpAlt = 0;			// Altitude Up
	if (event.keyCode == K_AltD) InpAlt = 0;			// Altitude Down
	if (event.keyCode == A_PitU) InpACP = 0;			// Pitch Up
	if (event.keyCode == A_PitD) InpACP = 0;			// Pitch Down
	if (event.keyCode == A_BnkL) InpACB = 0;			// Bank Left
	if (event.keyCode == A_BnkR) InpACB = 0;			// Bank Right
	if (event.keyCode == K_PitU) InpACP = 0;			// Pitch Up
	if (event.keyCode == K_PitD) InpACP = 0;			// Pitch Down
	if (event.keyCode == K_BnkL) InpACB = 0;			// Bank Left
	if (event.keyCode == K_BnkR) InpACB = 0;			// Bank Right
	if (event.keyCode == K_YawL) InpYaw = 0;			// Yaw Left
	if (event.keyCode == K_YawR) InpYaw = 0;			// Yaw Right
	// Views
	if (event.keyCode == K_VU45) D45flg = 0;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 0;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 0;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 0;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 0;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 0;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.pan = 0;			// Pan View
}

//- Subroutines ----------------------------------------------------------------

//. Toggle Pause ...............................................................
function toglPaws() {
	PawsOn = 1 - PawsOn;
	if (PawsOn && SndFlg) {		//On to Off
		stopSounds();
	}
	if (!PawsOn && SndFlg) {	// Off to On
		playSounds();
	}
	PawsText();
}

//. Toggle AutoPilot ...........................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info ................................................................
function toglInfo() {
	InfoOn++
	if (InfoOn == 3) InfoOn = 0;
	InfoText();
}

//. Toggle Sound ...............................................................
function toglSoun() {
	if (!PawsOn) {
		SndFlg = 1 - SndFlg;
		if (SndFlg) {			// Off to On
			playSounds();
		}
		else {					// On to Off
			stopSounds();
		}
	}
}

//= WINDOW RESIZE ==============================================================
function onWindowResize() {
	CamAsp = window.innerWidth/window.innerHeight;
	camera.aspect = CamAsp;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>