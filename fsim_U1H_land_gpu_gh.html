<!doctype html>
<html>

<!--
/********************************************************************************
*
*	FSIM UH1 LAND GPU
*
*********************************************************************************

Copyright 2017-25, Phil Crowther <phil@philcrowther.com>
Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
Version dated 7 Nov 2025

A flight simulation of an animated helicopter model over procedural land using WebGPU
-->

<head>
<title>fsim U1H land gpu r181</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="https://PhilCrowther.github.io/Aviation/styles/body2a.css">
</head>

<body oncontextmenu="return false;">

<div id="container">
	<div class="overlay1">
		<div>Height: <span id="AC_Hite"></span> ft</div>
		<div>ACPtch: <span id="AC_Ptch"></span> deg</div>
		<div>SpeedZ: <span id="AC_SpdZ"></span> mph</div>
		<div>ACBank: <span id="AC_Bank"></span> deg</div>
		<div>SpeedX: <span id="AC_SpdX"></span> mph</div>	
		<div>Headng: <span id="AC_Head"></span> deg</div>
		<div>DirFly: <span id="AC_DFly"></span> deg</div>
	</div>
	<div class="overlay2">
		<p>
		<div><span id="On_Paws"></span></div>
		<div><span id="On_Info01"></span></div>
	</div>
	<div class="overlay3">
		<div><span id="On_Info02"></span></div>
		<div><span id="On_Info03"></span></div>
		<div><span id="On_Info04"></span></div>
		<div><span id="On_Info05"></span></div>
		<div><span id="On_Info06"></span></div>
		<div><span id="On_Info07"></span></div>
		<div><span id="On_Info08"></span></div>
		<div><span id="On_Info09"></span></div>
		</p>
	</div>
</div>

<div id="blocker">
	<div id="instructions">
		<span style="font-size:24px">Click to play</span><br>
		Fly: MOUSE<br>
		Pan: MOUSE + Shift<br>
		Out: ESC
	</div>
</div>

<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.js",
			"three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.js",
			"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.tsl.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/"
		}
	}
</script>

<script type="module">

/********************************************************************************
*
*	PROGRAM
*
********************************************************************************/

//= LOAD MODULES ================================================================
//- Basic Modules ---------------------------------------------------------------
import * as THREE from "three";
import {color,float,texture} from "three/tsl";
import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
import {LensflareMesh,LensflareElement } from "three/addons/objects/LensflareMesh.js";
import Stats from "three/addons/libs/stats.module.js";
// Special Modules
import {initGrdMat,GrdMap,
		initRoads,moveRoads,
		loadTreLin,moveTreLin
} from "https://PhilCrowther.github.io/Aviation/jsm/GrdLnd.js"; // r171

//= GENERAL ====================================================================

//	This flight simulation demo uses the most advanced version of three.js

//= CONTROLS
//	This simulation primarily relies on mouse controls:
//	* Mouse wheel sets altitude (like the throttle/collective control in a real helicopter)
//	* Mouse movement changes direction (like the cyclic control in a real helicopter)
//	* Mouse buttons cause yaw left/right (like tail rotor in real helicopter)

//=	SIMPLIFICATIONS
//	A Helicopter is extremely difficult to fly. Your "pilot personna" will handle the following:
//	* Adjust power for changes in collective.
//	* Adjust power/collective to maintain altitude in horizontal flight.
//  * Adjust tail rotor to offset changes in power/collective.

//=	TO DO:
//-	Flight Module:
//	* Fix Weathervane adjustment (YawAdj)
//	* Allow for greater pitch and bank adjustments where excess thrust available.
//	* Reduce excess thrust available as altitude increases.
//	* Reduce/increase excess thrust available as climb/descend

/********************************************************************************
*
*	VARIABLES
*
********************************************************************************/

//= INPUTS =====================//===============================================	
//- CAMERA ----------------------------------------------------------------------
let CamSel = 0;					// Camera Seletion (0 = External; 1 = Internal)
//- AIRPLANE: Start -------------------------------------------------------------
let BegPwr = 0;					// Initial Power Percent
let BegSpd = 0;					// Speed (kph)
let BegRot = new THREE.Euler(0,0,0); // Position (degrees) ### new
let BegPos = new THREE.Vector3(0,0,0); // Position (meters)
//- AIRPLANE: Inputs ------------------------------------------------------------
let PYBmul = new THREE.Vector3(0.1,1,0.1); // Basic airplane values
let	MosMul = new THREE.Vector3(1,1,1); // Adjustment to PYBmul (default = 1)
let AltMul = 0.0001;			// Power % Input - Mouse Multiplier
let AltDif = 0;					// Power % Input - Value
//- Mouse Delays ...............................................................-
//- (x = diverted, y = released, z = stored)
//let PwrMsD = new THREE.Vector3(1-1/30,1/15,0);	// Power
//let PitMsD = new THREE.Vector3(1-1/30,1/15,0);	// CfL
//let BnkMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//let YawMsD = new THREE.Vector3(1-1/30,1/15,0);	// Bank
//- Keys ------------------------------------------------------------------------
let KeyVal = new THREE.Vector3(0.5,0.4,0.5); // Key Values
let InpAlt = 0;					// Input Altitude
let InpACP = 0;					// Input Pitch
let InpACB = 0;					// Input Bank
let InpYaw = 0;					// Input Yaw

//- POINTER LOCK CONTROLS -------------------------------------------------------
let InpMos = new THREE.Vector2();	// Inputs - Mouse
let _changeEvent = {type: "change"};
let _lockEvent = {type: "lock"};
let _unlockEvent = {type: "unlock"};

//= 1. MAIN VARIABLES ==========//===============================================

//- CONSTANTS ------------------//-----------------------------------------------
//	Time
let	DLTime = 1/60;				// Delta Time (1/60 seconds)
let DLTim2 = DLTime*DLTime;		//
//	Conversions
let DegRad = Math.PI/180;		// Convert Degrees to Radians
let RadDeg = 180/Math.PI;		// Convert Radians to Degrees
let Ft2Mtr = 0.3048;			// Convert Feet to Meters
let Mtr2Ft = 1/0.3048;
let Km2Mil = 0.621371;
let Mil2Km = 1.60934;
//	Default Constants
let AirDen = 1.225;				// (kg/m3)
//	Starting Constants per frame
let BegTmp = 288.15;			// K = 59F

//- GENERAL VARIABLES ----------//-----------------------------------------------
let gen_ = {
		//- Display
		PawsOn:	0,				// Pause
		StatOn:	1,				// Stats (0 = off, 1 = on)
		LnFFlg:	1,				// Lensflare
		// Program Flags
		LodFlg:	0,				// Set at end of initialization
		LodSnd: 0,
		// Altitude Adjustment
		AltAdj:	0.99,			// Raises objects above map as altitude increases
		AltDif:	0,
		// Misc
		contxt: 0,
		canvas: 0,
		MaxAni: 0,
	}

let tim_ = {
		DLTime: 1/60,
	}

//= 2. SKY VARIABLES ===========//===============================================
let sky_ = {
		// Sun
		SunCol: "white",		// Sun
		SunInt: 3,
		// Fog
		FogCol: 0xbab4a6,		// Sky (for Fog only)
		// SkyBox
		SBxSrc: "https://PhilCrowther.github.io/Aviation/textures/cube/skyboxsun25deg/",
		envMap: 0,				// For this SkyBox
		// Sun (position in SkyBox)
		SunLat: 23,				// Direction - Vert (+/- 90) deg
		SunLon: 312,			// Direction - Horz (0->360) deg
		// LensFlare		
		LF0Src: "https://PhilCrowther.github.io/Aviation/textures/fx/lensflare1.png",
		LF1Src: "https://PhilCrowther.github.io/Aviation/textures/fx/lensflare3.png",
		LF0Txt: 0,
		LF1Txt: 0,
		// Shadow Beg Info
		SunDst: 50,				// Distance
		ShdBox: 6,				// Size of shadow box
		ShdBLR: 6.5,
		ShdBTB: 4,
		ShdDst: 1500,			// Shadow Distance (meters)
	}

//= SUN VALUES =================//===============================================
let SunSph = new THREE.Spherical(sky_.SunDst,(90-sky_.SunLat)*DegRad,Mod360(180-sky_.SunLon)*DegRad);
let	SunPos = new THREE.Vector3().setFromSpherical(SunSph);

//= STANDARD SETUP =============//===============================================
//- Scene
let scene = new THREE.Scene();
	scene.background = new THREE.Color("black");
//- Light
let ambLight = new THREE.AmbientLight(sky_.SunCol,0.2);
	scene.add(ambLight);
//- SunLight
let sunLight = new THREE.DirectionalLight(sky_.SunCol,sky_.SunInt);
	sunLight.position.copy(SunPos);
	sunLight.castShadow = true;
	sunLight.shadow.camera.near = sky_.SunDst*0.75;
	sunLight.shadow.camera.far = sky_.SunDst+sky_.ShdDst+sky_.ShdBox;
	sunLight.shadow.mapSize.width = 2048;
	sunLight.shadow.mapSize.height = 2048;
	sunLight.shadow.camera.left = -sky_.ShdBLR;
	sunLight.shadow.camera.right = sky_.ShdBLR;
	sunLight.shadow.camera.top = sky_.ShdBTB;
	sunLight.shadow.camera.bottom = -sky_.ShdBTB;
	sunLight.shadow.bias = -0.0002; // WebGPU (0 flashing; -0.0001 no wheels)
	scene.add(sunLight);
// 	Camera
let	CamAsp = window.innerWidth/window.innerHeight;
let camera = new THREE.PerspectiveCamera(45,CamAsp, 0.1,100000);
//	scene.add(new THREE.CameraHelper(sunLight.shadow.camera));
//- Renderer
let renderer = new THREE.WebGPURenderer({antialias: true});	// ### WebGPU
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setAnimationLoop(rendAll);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.autoUpdate = true;
	renderer.receiveShadow = true;	
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
	gen_.MaxAni = renderer.getMaxAnisotropy();
//- Clock
let clock = new THREE.Clock();
let oldTim, nowTim, difTim = 0;
//- Inputs
	document.addEventListener("mousedown", onDocumentMouseDown, false);
	document.addEventListener("mouseup", onDocumentMouseUp, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, {capture: false, passive: false});
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", onDocumentKeyUp, false);
	window.addEventListener("resize", onWindowResize, false);
//- Loading Manager
	// Create a loading manager to set RESOURCES_LOADED when appropriate.
	// Pass loadingManager to all resource loaders.
let loadingManager = new THREE.LoadingManager();
let RESOURCES_LOADED = false;
	loadingManager.onLoad = function(){
		console.log("loaded all resources");
		RESOURCES_LOADED = true;
		initAll();
	};
let txtrLoader = new THREE.TextureLoader(loadingManager);
let imagLoader = new THREE.ImageLoader(loadingManager);
let cubeLoader = new THREE.CubeTextureLoader(loadingManager);
let gltfLoader = new GLTFLoader(loadingManager);
//- Wait Screen
let loadingScreen = {
	scene: new THREE.Scene(),
	camera: new THREE.PerspectiveCamera(90, window.innerWidth, window.innerHeight, 0.1, 100),
	box: 0
};
let boxrot = 0;

//= GRIDS ======================//===============================================
let ImgSiz = 1024;
	gen_.canvas = document.createElement("canvas");
	gen_.canvas.width = ImgSiz;
	gen_.canvas.height = ImgSiz;
	gen_.contxt = gen_.canvas.getContext("2d",{willReadFrequently: true});

//= GRID MODULE ================//===============================================
//	This ocean map has 3 nested grids of squares.
//	Grid0 has 16x16 squares, each of size GrdSiz (e.g. 1 mile, range = 8 miles)
//	Grid1 has 16x16 squares, each of size GrdSi*4z (e.g. 4 miles, range = 32 miles)
//	Grid2 has 16x16 squares, each of size GrdSiz*16 (e.g. 16 miles, range = 128 miles))
let grids = 0;
let grd_ = {
		SPS: 0,					// MSX, MPY, MSZ (meters) (from Flight)
		RCs: 27,				// Squares in each of first 2 grids
		Siz: 804.67,			// Size of smallest square (1/4 section = 1/2 mile)
		Stp: 3,					// Squares in each of first 2 grids
		Grx: [],				// Index of Grids (0-2)
		Idx: [0],				// Index to Patterns
		Mat: [0],				// Index to Materials
	}
// Adjust
	grd_.SPS = new THREE.Vector3();

//= OBJECTS ====================//===============================================
//- Distances in Meters
let ObjNum = 2;					// number of objects
let ObjTyp = [0];				// Object Type
	ObjTyp[ObjNum - 1] = 0;
let ObjNam = [0];				// Object Name
	ObjNam[ObjNum - 1] = 0;
let ObjMdl = [0];				// Model source
	ObjMdl[ObjNum - 1] = 0;
let ObjTxt = [0];				// Model texture
	ObjTxt[ObjNum - 1] = 0;
let ObjMPX = [0];				// Ground X Value
	ObjMPX[ObjNum - 1] = 0;
let ObjMPY = [0];				// Ground Y Value
	ObjMPY[ObjNum - 1] = 0;
let ObjMPZ = [0];				// Ground Y Value
	ObjMPZ[ObjNum - 1] = 0;
let ObjPtr = [0];				// Object Address
	ObjPtr[ObjNum - 1] = 0;
// Index (allow for expanding list of objects)
let ObjIdx = 0;
//- Hangars
	ObjTyp[ObjIdx] = 0;			// 0 = No separate texture
	ObjNam[ObjIdx] = "hangar";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/hangar.glb";
	ObjTxt[ObjIdx] = 0; 	
	ObjMPX[ObjIdx] = 1000;		// [m]
	ObjMPY[ObjIdx] = Ft2Mtr;	// [m] 1 ft
	ObjMPZ[ObjIdx] = 1524;		// [m] 5000 ft
	ObjIdx = ObjIdx + 1;
//- Giaros Island
	ObjTyp[ObjIdx] = 1;			// 1 = Large feature
	ObjNam[ObjIdx] = "giaros";
	ObjMdl[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/models/giaros.glb";
	ObjTxt[ObjIdx] = "https://PhilCrowther.github.io/Aviation/scenery/textures/giaros.jpg";
	ObjMPX[ObjIdx] = -1609.344;	// [m] 1 mile
//	ObjMPY[ObjIdx] = 2*Ft2Mtr;	// [m] 2 ft
	ObjMPY[ObjIdx] = -50;		// [m]
	ObjMPZ[ObjIdx] = 8046.72;	// [m] 5 miles
	
//= MY HELICOPTER ==============//===============================================
let dat_ = {
		MaxThr: 32620,			// Level Flight Thrust (N = 7333 lbs)
		MaxAng: 30,				// Max Rotor and Body Angle (deg) [rotor moves +/-11 deg]
		MaxKPH: 217.26,			// Max Speed (mph = 135 mph)
		MinAng: 15,				// Min Rotor and Body Angle (deg) to main MaxKPH
		ACMass: 3326,			// Aircraft Mass (kg = 7333 lb / 2.2)
		FrntAr: 1.951,			// Frontal Area (m2 = 21 ft2)
		DrgCdz: 1.94,			// Coefficient of Drag (z-direction)
		DrgCdx: 43.525,			// Coefficient of Drag (x-direction)
		MdlAlt: 1.3,			// Model Center Height above Ground (meters)
	}
//= 
let air_ = {
		// General Variables
		DLTime: DLTime,			// Seconds per frame (can vary)
		AirDSL: AirDen,			// Air Density (varies with altitude)
		// Designators
		AirDat: dat_,			// Aircraft Type: 1 = Pup
		// Helicopter Rotation: Vertical Angle, Horizontal Angle, Bank Angle
		AirRot: new THREE.Euler(0,0,0).copy(BegRot), // Rotation (in degrees)
		AirObj: new THREE.Object3D,
		// Changes to Airplane Pitch Bank and Yaw
		RotDif: new THREE.Vector3(), // Change
		AltDif: 0,
		// Airplane Speed
		SpdKPH: BegSpd,			// Speed in KPH
		SpdMPS: BegSpd/3.6,		// Speed - meters per second
		AirSpd: new THREE.Vector3(), // Airspeed (mpf) ### new
		// Airplane Map Speed and Position
		DirFlt: BegRot.y,
		MapSpd: new THREE.Vector3(), // Map Speed (mpf)
		MapPos: new THREE.Vector3(), // Map Position (meters)
		MapSPS: new THREE.Vector3(), // MSX, MPY, MSZ (meters)
		// Variables
		PwrPct: BegPwr,			// % of Primary Power (0 to 1) (Main and Flight)
		// Variables Obtained from Flight
		GrdZed: 0,				// Ground level (default)
		GrdFlg: 0,				// Ground Flag (1 = on ground)
		ACPAdj: 0,				// Airplane pitch adjustment
		MovFlg: 0,				// If Sitting on a Moving Object
		// Variables Obtained from Data
		MaxThr: 0,				// Prop Maximum Power (kW = 17000 lbs X 4.445)
		MaxAng: 0,				// Max Rotor and Body Angle (deg)
		MaxKPH: 0,				// Max Speed (KPH)
		MinAng: 0,
		ACMass: 0,				// Airplane Mass
		FrntAr: 0,				// Frontal Area
		DrgCdz: 0,				// Coefficient of Drag (z-direction)
		DrgCdx: 0,				// Coefficient of Drag (x-direction)
		Weight: 0,				// Used by autopilots
		MdlAlt: 0,				// Model Center Height above Ground (meters)
	}
//- Adjustments
	air_.AirObj.rotation.order = "YXZ";
	scene.add(air_.AirObj);
//- Load Models and Animations -------------------------------------------------
//-	File Path
let ACPath = "https://PhilCrowther.github.io/Aviation/models/u1h/";	// Used to load models and sounds
//-	Animation Mixers - External Model
let ACFile = "u1h_flyt.glb"; // Name of aircraft model file (rotated blender file)
//- Aircraft Animations
let anmfps = 24;				// Blender FPS
let aoarng = 20;				// AoA range (model)
//	Animation Mixers - External Model
let mxRtrB = 0;					// Main Rotor - Blades
let mxRtrP = 0;					// Main Rotor - Pitch
let mxRtrK = 0;					// Main Rotor - Bank
let mxRtrV = 0;					// Main Rotor - Vertical
let mxRtrT = 0;					// Tail Rotor
let mxDorL = 0;					// Main Doors - Left
let mxDorR = 0;					// Main Doors - Right
//- All range from 0 to 360 with center at 180
let pitprp = 180;				// Main Rotor - Pitch
let bnkprp = 180;				// Main Rotor - Bank
let spnprp = 180;				// Main Rotor - Spin
let spnrtr = 180;				// Tail Rotor - Spin (not used)
let doormn = 0;					// Main Doors

//=	SOUNDS =====================//===============================================
let EngSrc = "xbell_rotor03a.wav"; // File (my engine)
let EngVol = 0.1;				// Volume
let EngSnd = 0;
let EngMsh = new THREE.Object3D;		// Aircraft Engine

//= POINTER LOCK CONTROL ========================================================
class PointerLockControls extends THREE.EventDispatcher {
	constructor(camera, domElement) {
		super();
		this.domElement = domElement;
		this.isLocked = false;
		const scope = this;
		function onMouseMove(event) {
			if (scope.isLocked === false) return;
			const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;		
			InpMos.x = movementX;
			InpMos.y = movementY;
		}
		function onPointerlockChange() {
			if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
				scope.dispatchEvent(_lockEvent);
				scope.isLocked = true;
			} else {
				scope.dispatchEvent(_unlockEvent);
				scope.isLocked = false;
			}
		}
		function onPointerlockError() {
			console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
		}
		this.connect = function () {
			scope.domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.addEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.addEventListener("pointerlockerror", onPointerlockError);
		};
		this.disconnect = function () {
			scope.domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
			scope.domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerlockChange);
			scope.domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerlockError);
		};
		this.dispose = function () {
			this.disconnect();
		};
		this.lock = function () {
			this.domElement.requestPointerLock();
		};
		this.unlock = function () {
			scope.domElement.ownerDocument.exitPointerLock();
		};
		this.connect();
	}
}
//- Setup -----------------------------------------------------------------------
let controls = new PointerLockControls(camera, renderer.domElement);
let blocker = document.getElementById("blocker");
let instructions = document.getElementById("instructions");
	instructions.addEventListener("click", function () {controls.lock();});
	controls.addEventListener("lock", function () {
		instructions.style.display = "none";
		blocker.style.display = "none";
	});
	controls.addEventListener("unlock", function () {
		blocker.style.display = "block";
		instructions.style.display = "";
	});

//= DEFAULT KEY BINDINGS =======//===============================================
let	K_AltU = 81;				// Altitude Up (q)
let	K_AltD = 69;				// Altitude Dn (e)
let	A_PitU = 40;				// Pitch up (down arrow)
let	A_PitD = 38;				// Pitch down (up arrow)
let	A_BnkL = 37;				// Bank Left (left arrow)
let	A_BnkR = 39;				// Bank Right (right arrow)
let	K_PitU = 88;				// Pitch up (w)
let	K_PitD = 83;				// Pitch down (s)
let	K_BnkL = 65;				// Bank Left (a)
let	K_BnkR = 68;				// Bank Right (d)
let	K_YawL = 90;				// Yaw Left (z)
let	K_YawR = 88;				// Yaw Right (x)
//	Views
let K_Look = 16;				// Pan (shift)
let K_VU45 = 36;				// View Up (alone or modifier)
let K_VD45 = 35;				// View Down (alone or modifier)
let K_VL45 = 33;				// Left 45 degrees
let K_VR45 = 45;				// Right 45 degrees
let K_VL90 = 34;				// Left 90 degrees
let K_VR90 = 46;				// Right 90 degrees
//	Toggle
let K_Soun = 83;				// Toggle sound (s)
let K_Paws = 80;				// Pause (p)
let K_Info = 73;				// Info (i)

//=	VIEW KEYS ==================//===============================================
let U45flg = 0;					// Up 45 degrees
let D45flg = 0;					// Down 45 degrees
let	L45flg = 0;					// Left 45 degrees
let R45flg = 0;					// Right 45 degrees
let L90flg = 0;					// Left 90 degrees
let R90flg = 0;					// Right 90 degrees

//= CAMERA =====================//===============================================
//- Create Cockpit Attach Point
let	CamPVC = new THREE.Object3D;
	CamPVC.rotation.order = "YXZ";
	CamPVC.position.set(0,1.0668,0.762);	// Cockpit view
	air_.AirObj.add(CamPVC); 	// Attach CamPVC to AirObj
//- Camera Inputs (External Camera linked to air_.AirObj; 1 Internal Camera Linked to cam_.PVC)
let CamNum = 2;
let CamLLD = [new THREE.Vector3(-10,0,30),
			  new THREE.Vector3(0,0,0.001)];
let CamAdj = [180,0];			// 180 = Looking In
let CamMMD = [new THREE.Vector3(CamLLD[0].z*0.5,CamLLD[0].z*2.0,0.1),	// In/Out - min,max,spd
			  new THREE.Vector3(0,1,0.001)];	// Cockpit View: Throttle - min,max,spd
let CamMMR = [new THREE.Vector3(80,0,0.5),	// Rotate - min/max Lat/Lon,rspd
			  new THREE.Vector3(45,110,0.5)];
let CamPar = [air_.AirObj,CamPVC];
let CamFlg = [0,1];				// 1 = cockpit view
let CamLnk = [1,1];				// 1 = Linked to Airplane
//- Shared Variables
let cam_ = {
		sel: CamSel,			// View Selector (0 = External, 1 = Internal)
		num: CamNum,
		pan: 0,					// Pan Flag (1 = panning)
		// Camera
		lld: new THREE.Vector3().copy(CamLLD[CamSel]),	// cam_.rot Lat, Lon, Dst
		llz: new THREE.Vector3(), // External LLZ
		adj: CamAdj[CamSel],	// Camera Adjustment (180 = look in)
		mmd: new THREE.Vector3().copy(CamMMD[CamSel]),	// In/Out - min,max,spd
		// Rotator
		rot: new THREE.Object3D,			// Camera Rotator
		mmr: new THREE.Vector3().copy(CamMMR[CamSel]),	// Rotate - min/max Lat/Lon,rspd
		// Center of Rotation
		par: CamPar[CamSel],	// Center of Rotation	
		flg: CamFlg[CamSel],	// View Flag (0 = External, 1 = Internal)
		// Linked Airplane
		lnk: CamLnk[CamSel],
		qat: new THREE.Quaternion(),
		obj: new THREE.Object3D,
		deg: new THREE.Object3D
	}
//- Adjustments
	camera.rotation.order = "YXZ";
	cam_.rot.rotation.order = "YXZ";
	cam_.obj.rotation.order = "YXZ";
	cam_.deg.rotation.order = "YXZ";
	cam_.par.add(cam_.rot);			// Attach Rotator
	cam_.obj.add(cam_.deg);

//= HTML OVERLAY TEXT ===========================================================
let AC_HiteElement = document.getElementById("AC_Hite");
let AC_HiteNode = document.createTextNode("");
	AC_HiteElement.appendChild(AC_HiteNode);
let AC_PtchElement = document.getElementById("AC_Ptch");
let AC_PtchNode = document.createTextNode("");
	AC_PtchElement.appendChild(AC_PtchNode);
let AC_SpdZElement = document.getElementById("AC_SpdZ");
let AC_SpdZNode = document.createTextNode("");
	AC_SpdZElement.appendChild(AC_SpdZNode);
let AC_BankElement = document.getElementById("AC_Bank");
let AC_BankNode = document.createTextNode("");
	AC_BankElement.appendChild(AC_BankNode);
let AC_SpdXElement = document.getElementById("AC_SpdX");
let AC_SpdXNode = document.createTextNode("");
	AC_SpdXElement.appendChild(AC_SpdXNode);
let AC_HeadElement = document.getElementById("AC_Head");
let AC_HeadNode = document.createTextNode("");
	AC_HeadElement.appendChild(AC_HeadNode);
let AC_DFlyElement = document.getElementById("AC_DFly");
let AC_DFlyNode = document.createTextNode("");
	AC_DFlyElement.appendChild(AC_DFlyNode);
let On_PawsElement = document.getElementById("On_Paws");
let On_PawsNode = document.createTextNode("");
	On_PawsElement.appendChild(On_PawsNode);
let On_Info01Element = document.getElementById("On_Info01");
let On_Info01Node = document.createTextNode("");
	On_Info01Element.appendChild(On_Info01Node);
let On_Info02Element = document.getElementById("On_Info02");
let On_Info02Node = document.createTextNode("");
	On_Info02Element.appendChild(On_Info02Node);
let On_Info03Element = document.getElementById("On_Info03");
let On_Info03Node = document.createTextNode("");
	On_Info03Element.appendChild(On_Info03Node);
let On_Info04Element = document.getElementById("On_Info04");
let On_Info04Node = document.createTextNode("");
	On_Info04Element.appendChild(On_Info04Node);
let On_Info05Element = document.getElementById("On_Info05");
let On_Info05Node = document.createTextNode("");
	On_Info05Element.appendChild(On_Info05Node);
let On_Info06Element = document.getElementById("On_Info06");
let On_Info06Node = document.createTextNode("");
	On_Info06Element.appendChild(On_Info06Node);
let On_Info07Element = document.getElementById("On_Info07");
let On_Info07Node = document.createTextNode("");
	On_Info07Element.appendChild(On_Info07Node);
let On_Info08Element = document.getElementById("On_Info08");
let On_Info08Node = document.createTextNode("");
	On_Info08Element.appendChild(On_Info08Node);
let On_Info09Element = document.getElementById("On_Info09");
let On_Info09Node = document.createTextNode("");
	On_Info09Element.appendChild(On_Info09Node);

let AC_Hite, AC_Ptch, AC_SpdZ, AC_Bank, AC_SpdX, AC_Head, AC_DFly;
let On_Paws, On_Info01, On_Info02, On_Info03, On_Info04, On_Info05, On_Info06, On_Info07, On_Info08;

/********************************************************************************
*
*	1. MAIN PROGRAM
*
********************************************************************************/

	loadAll();

//=	0 LOAD ALL =================//===============================================

function loadAll() {
	WaitScreen();				// init loading screen
	loadSkyBox();
	loadTreLin(grd_,gltfLoader,scene);
	loadObject();
	loadAirObj();
	// Load stats
	if (gen_.StatOn) {			// show stats
		gen_.StatOn = new Stats();
		document.body.appendChild(gen_.StatOn.dom);
		gen_.StatOn.domElement.style.cssText = "position:absolute;top:90%;left:95%;";
	}
}

//= WAIT SCREEN ================//===============================================

function WaitScreen() {
	// Set up the loading screen scene.
	// It can be treated just like our main scene.
	let BoxGeo = new THREE.PlaneGeometry(1,1);
	let BoxTxt = txtrLoader.load("https://PhilCrowther.github.io/Aviation/textures/wait/prop.jpg");
	let BoxMat = new THREE.MeshBasicNodeMaterial({colorNode: texture(BoxTxt)});
	loadingScreen.box = new THREE.Mesh(BoxGeo,BoxMat);
	loadingScreen.box.rotation.set(Math.PI,0,0);
	loadingScreen.box.position.set(0,0,5);
	loadingScreen.camera.lookAt(loadingScreen.box.position);
	loadingScreen.scene.add(loadingScreen.box);
}

//= 1 INITIALIZE ================//===============================================

function initAll() {
	initSkyBox();				// load skybox
	initAirObj();
	gen_.AltDif = air_.MapPos.y*gen_.AltAdj; // Used by everything
	initGrdMat(grd_,gen_);
	grd_.SPS.y = air_.MapPos.y;	// Init Position
	grids = new GrdMap(grd_,scene);	// Init Grid Map
	grids.update(grd_);			// Mode Grid Map
	initRoads(grd_,gen_,scene);
	moveTreLin(grd_,air_,gen_); // Add TreeLines
	initObject();				// Stationary Objects
	// Other
	initCamera(camera,cam_);	// position camera
	PawsText();
	InfoText();
	gen_.LodFlg = 1;
}

//= 2 RENDER ===================//===============================================

function rendAll() {
	// This block runs while resources are loading.
	if(RESOURCES_LOADED == false){
		boxrot = Mod360(boxrot - 3);
		loadingScreen.box.rotation.set(Math.PI,0,boxrot * DegRad);
		renderer.render(loadingScreen.scene, loadingScreen.camera);
		return;					// Stop the function here.
	}
	if (controls.isLocked === true && !gen_.LodSnd) loadSounds();
	if (!gen_.PawsOn && gen_.LodFlg && controls.isLocked === true) {
		moveCamera(camera,cam_);
		// Move AirObj
		moveAirObj();
		// Move Objects
		grd_.SPS.copy(air_.MapSPS);	// Update Position
		grids.update(grd_);		// Mode Grid Map
		moveRoads(grd_,gen_);
		moveTreLin(grd_,air_,gen_); // Add TreeLines		
		moveObject();			// Move objects
		moveSounds();
		prntHUDval();			// change HUD value
		if (gen_.StatOn) gen_.StatOn.update(); // update stats
	}
	if (controls.isLocked === false && gen_.LodSnd) {
		stopSounds();
		gen_.SndFlg = 0;
	}
	renderer.render(scene, camera);
}

/********************************************************************************
*
*	2. SKY
*
********************************************************************************/

function loadSkyBox() {
	let envMap = cubeLoader
		.setPath(sky_.SBxSrc)
		.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]);
	envMap.format = THREE.RGBAFormat;
	envMap.colorSpace = THREE.SRGBColorSpace; // ### r152
	scene.background = envMap;
	// LensFlare
	if (gen_.LnFFlg) {				// SunFlare	
		sky_.LF0Txt = txtrLoader.load(sky_.LF0Src);
		sky_.LF1Txt = txtrLoader.load(sky_.LF1Src);
	}
}

function initSkyBox() {
	// Scrolling Map Max Distance = 81,000 units (81,000 meters = 50.33 miles)
	// (=.5 * (27 outer squares * 3 inner per outer * 2000 inner square size))
	// Fog (doesn't work with Normal Material)
	scene.fog = new THREE.Fog(sky_.FogCol, 0.25, 95000);	// less than camera distance, sky colored fog
	// Lensflare
	if (gen_.LnFFlg) {				// SunFlare		
		let	spotLight = new THREE.PointLight(0xffffff);
		scene.add(spotLight);
		spotLight.position.copy(SunPos).normalize;
		spotLight.position.multiplyScalar(1000);	
		let LF = new LensflareMesh();
			LF.addElement(new LensflareElement(sky_.LF0Txt,256,0));
			LF.addElement(new LensflareElement(sky_.LF1Txt,32,0.2));
			LF.addElement(new LensflareElement(sky_.LF1Txt,256,0.9));
		spotLight.add(LF);
	}
}

/********************************************************************************
*
*	4. OBJECTS
*
********************************************************************************/
//= These objects include the airfield, mountains and hangar

function loadObject() {
	for (let i = 0; i < ObjNum; i++) {		// For Each Object
		if (ObjTyp[i] == 0) {
			gltfLoader.load(ObjMdl[i], function (gltf) {
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
		if (ObjTyp[i] == 1) {
			let texture = txtrLoader.load(ObjTxt[i]);
			texture.anisotropy = gen_.MaxAni;
			let material = new THREE.MeshLambertMaterial({map: texture, transparent: true});
			gltfLoader.load(ObjMdl[i], function (gltf) {
				gltf.scene.traverse(function (child) {
				// Note: Blender object must include a UV map
					if (child.isMesh) {				
						child.material = material;
						child.receiveShadow = true;
					}
				});
				ObjPtr[i] = gltf.scene;
				ObjPtr[i].scale.setScalar(32000*Ft2Mtr);
				ObjPtr[i].rotation.order = "ZXY";
			});
		}
	}
}

// Init Objects
function initObject() {
	for (let i = 0; i < ObjNum; i++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*gen_.AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
		scene.add(ObjPtr[i]);
	}
}

// Move Objects
function moveObject() {
	// Convert Distances into Meters to match landscape program
	for (let i = 0; i < ObjNum; i ++) {
		// Set Position (cause Objects to elevate above ground as we climb to prevent flicker)
		let X = ObjMPX[i]-air_.MapPos.x;
		let Y = ObjMPY[i]-air_.MapPos.y*gen_.AltAdj;
		let Z = air_.MapPos.z-ObjMPZ[i];
		ObjPtr[i].position.set(X,Y,Z);
	}
}

/********************************************************************************
*
*	5. HELICOPTER
*
********************************************************************************/

//- LOAD =======================//===============================================
function loadAirObj() {
	let fname = ACPath + ACFile;
	gltfLoader.load(fname, function (gltf) {			// The OnLoad function
		gltf.scene.traverse(function (child) {
			if (child.isMesh) {
				child.castShadow = true;
				child.receiveShadow = true;
			}
			if (
				child.name == "glass_fuse0" ||
				child.name == "glass_doors" ||
				child.name == "glass_doorL" ||
				child.name == "glass_doorR")
			{
				child.castShadow = false;
				child.receiveShadow = false;
			}
		});
		let AirExt = gltf.scene;
		AirExt.rotation.order = "YXZ";
		AirExt.scale.setScalar(Ft2Mtr);
		/* Animations ------------------------------------------------------------- */
		// Main Rotor - Bank
		let clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMKAction");
		mxRtrK = new THREE.AnimationMixer(AirExt);
		let actun = mxRtrK.clipAction(clip);
		actun.play();
		if (mxRtrK) mxRtrK.setTime(bnkprp/anmfps);
		// Main Rotor - Pitch
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMPAction");
		mxRtrP = new THREE.AnimationMixer(AirExt);
		actun = mxRtrP.clipAction(clip);
		actun.play();
		if (mxRtrP) mxRtrP.setTime(pitprp/anmfps);
		// Main Rotor - Blades
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMBAction");
		mxRtrB = new THREE.AnimationMixer(AirExt);
		actun = mxRtrB.clipAction(clip);
		actun.play();
		if (mxRtrB) mxRtrB.setTime(spnprp/anmfps);
		// Main Rotor - Vertical
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorMVAction");
		mxRtrV = new THREE.AnimationMixer(AirExt);
		actun = mxRtrV.clipAction(clip);
		actun.play();
		if (mxRtrV) mxRtrV.setTime(spnprp/anmfps);
		// Tail Rotor
		clip = THREE.AnimationClip.findByName(gltf.animations, "rotorTAction");
		mxRtrT = new THREE.AnimationMixer(AirExt);
		actun = mxRtrT.clipAction(clip);
		actun.play();
		if (mxRtrT) mxRtrT.setTime(spnrtr/anmfps);
		// DoorL
		clip = THREE.AnimationClip.findByName(gltf.animations, "doorLAction");
		mxDorL = new THREE.AnimationMixer(AirExt);
		actun = mxDorL.clipAction(clip);
		actun.play();
		if (mxDorL) mxDorL.setTime(doormn/anmfps);
		// DoorR
		clip = THREE.AnimationClip.findByName(gltf.animations, "doorRAction");
		mxDorR = new THREE.AnimationMixer(AirExt);
		actun = mxDorR.clipAction(clip);
		actun.play();
		if (mxDorR) mxDorR.setTime(doormn/anmfps);
		//- Save
		air_.AirObj.add(AirExt);
	});
}

//= INIT =======================//===============================================
function initAirObj() {
	initFlight();				// initalize variables
}

//= MOVE =======================//===============================================
function moveAirObj() {
	// Altitude Change
	air_.AltDif = AltDif * AltMul + InpAlt;
	AltDif = 0;					// Reset
	// Pitch Speed Change
	air_.RotDif.x = InpMos.y * PYBmul.x;
	air_.RotDif.x = PoM360(Mod360(air_.RotDif.x + InpACP));
	InpMos.y = 0;				// Reset
	// Bank Speed Change
	air_.RotDif.z = InpMos.x * PYBmul.z;
	air_.RotDif.z = PoM360(Mod360(air_.RotDif.z + InpACB)); // Inputs are +/-
	InpMos.x = 0;				// Reset
	// Input Yaw
	air_.RotDif.y = InpYaw;
	// Compute Rotation and Vectors
	moveFlight();
	//- Animations --------------------------------------------------------------
	// Rotors - Speed
	let prpspd = 33;
	spnprp = spnprp - prpspd;
	if (spnprp < 0) spnprp = 359; // A complete circle
	//- Aircraft ----------------------------------------------------------------
	// Rotate Aircraft (order:YXZ)
	air_.AirObj.rotation.y = Mod360(-air_.AirRot.y) * DegRad; // Heading
	// Pitch - exclude first 11 degrees
	let PitDfR = air_.AirRot.x;
	if (PitDfR > 0) {
		PitDfR = PitDfR - 11;
		if (PitDfR < 0) PitDfR = 0;
	}
	if (PitDfR < 0) {
		PitDfR = PitDfR + 11;
		if (PitDfR > 0) PitDfR = 0;
	}
	air_.AirObj.rotation.x = Mod360(PitDfR) * DegRad; // Pitch
	// Bank
	// Pitch - exclude first 11 degrees
	let BnkDfR = PoM360(air_.AirRot.z);
	if (BnkDfR > 0) {
		BnkDfR = BnkDfR - 11;
		if (BnkDfR < 0) BnkDfR = 0;
	}
	if (BnkDfR < 0) {
		BnkDfR = BnkDfR + 11;
		if (BnkDfR > 0) BnkDfR = 0;
	}
	air_.AirObj.rotation.z = Mod360(360 - BnkDfR) * DegRad; // Bank
	// Main Rotor - Speed
	if (mxRtrB) mxRtrB.setTime(spnprp/anmfps);
	if (mxRtrV) mxRtrV.setTime(spnprp/anmfps);
	// Main Rotor - Pitch
	pitprp = 180 + air_.AirRot.x * 179 / 5;
	if (pitprp > 359) pitprp = 359;
	if (pitprp < 1) pitprp = 1; 
	if (mxRtrP) mxRtrP.setTime(pitprp/anmfps);
	// Main Rotor - Bank
	bnkprp = 180 + PoM360(air_.AirRot.z) * 179 / 5;
	if (bnkprp > 359) bnkprp = 359;
	if (bnkprp < 1) bnkprp = 1; 
	if (mxRtrK) mxRtrK.setTime(bnkprp/anmfps);
	// Tail Rotor
	if (mxRtrT) mxRtrT.setTime(spnprp/anmfps);
	// Doors
//	if (mxDoor) mxDoor.setTime(doormn/anmfps);
	// View Keys ----------------------------------------------------------------
	if (cam_.pan < 1) {			// Only If Not Panning		
		// If No Keys Pressed, Set Default View
		if (U45flg+D45flg+L45flg+R45flg+L90flg+R90flg < 1)	{
			if (cam_.flg) cam_.lld.x = 0;	// Internal view
			else cam_.lld.x = -12.5;		// External view
			cam_.lld.y = 0;
		}
		// Down 45
		else if (D45flg) {
			cam_.lld.x = 0;
			// Look Back
			if ((L90flg) && (L90flg) && (R90flg)) cam_.lld.y = 180;
			// Look Back Left 90 + 45
			else if (L90flg) cam_.lld.y = 135;
			// Look Back Right 270 - 45
			else if (R90flg) cam_.lld.y = 225;
			// Look Down
			else {
				cam_.lld.y = 0;
				cam_.lld.x = 45;
			}
		}
		// Up 45
		else if (U45flg) {
			cam_.lld.x = 315;
			if (cam_.flg == 0 && (air_.GrdFlg)) cam_.lld.x = 0;
			// Look Up Left 45
			if (L45flg) cam_.lld.y = 45;
			// Look Up Right 45
			else if (R45flg) cam_.lld.y = 315;
			// Look Up Left 90
			else if (L90flg) cam_.lld.y = 90;
			// Look Up Right 90
			else if (R90flg) cam_.lld.y = 270;
			// Look Up
			else cam_.lld.y = 0;
		}
		// Level
		else {
			cam_.lld.x = 0;
			// Look Left 45
			if (L45flg) cam_.lld.y = 45;
			// Look Right 45
			else if (R45flg) cam_.lld.y = 315;
			// Look Left 90
			else if (L90flg) cam_.lld.y = 90;
			// Look Right 90
			else if (R90flg) cam_.lld.y = 270;
		}
	}
}

//= FLIGHT MODULE ==============//===============================================

function initFlight() {
	// Transfer Constants from dat_ to air_
	let dat_ = air_.AirDat;
	air_.MaxThr = dat_.MaxThr;	// Maximum Thrust
	air_.MaxAng = dat_.MaxAng;	// Maximum Rotor and Body Angle
	air_.MaxKPH = dat_.MaxKPH;	// Maximum Speed
	air_.MinAng = dat_.MinAng;	// Minimum Rotor and Body Angle for Max Speed
	air_.ACMass = dat_.ACMass;	// Airplane Mass
	air_.FrntAr = dat_.FrntAr;	// Frontal Area
	air_.DrgCdz = dat_.DrgCdz;	// Coefficient of Drag (z-direction)
	air_.DrgCdx = dat_.DrgCdx;	// Coefficient of Drag (x-direction)
	air_.MdlAlt = dat_.MdlAlt;	// Model Center Height above Ground (meters)
	// Starting Altitude
	let MinAlt = air_.GrdZed + air_.MdlAlt; // Minimum Altitude (ASL = GL+AGL)
	if (!air_.GrdFlg && air_.MapPos.y <= MinAlt) _landFlight(MinAlt);
	moveFlight();
}

//= MOVE =======================//===============================================
function moveFlight() {
// Inputs: air_.GrdFlg, GrdZed, air_.AltDif, air_.MapSpd.z, air_.AirRot.x, air_.AirRot.z
	// Compute Vectors
	DLTime = 1/60;				// Delta Time (1/60 seconds)
	DLTim2 = DLTime*DLTime;
	let FrcAcc = DLTim2 / air_.ACMass;
	if (air_.GrdFlg && air_.AltDif > 0) air_.GrdFlg = 0;	// If going to leave ground
	if (!air_.GrdFlg) {			// Compute Change in mps, convert MapSpd to mpf
		// 1. Recompute Horizontal Airspeed (mps) - since ACH (which redirects AirSpd.xz) may have changed
		// Use mps so that DynPrs and Drag is correct
		let ACHRad = air_.AirRot.y * DegRad;
		let PSpdZS = air_.MapSpd.z * Math.cos(-ACHRad) - air_.MapSpd.x * Math.sin(-ACHRad);
		let PSpdXS = air_.MapSpd.z * Math.sin(-ACHRad) + air_.MapSpd.x * Math.cos(-ACHRad);
		air_.AirSpd.z = PSpdZS / air_.DLTime; // Convert to mps
		air_.AirSpd.x = PSpdXS / air_.DLTime;
		// 2. Compute Total Drag at Those Speeds ................................
		// Forward/Backwards Drag Force
		let DynPrZ = 0.5 * air_.AirDSL * (air_.AirSpd.z * air_.AirSpd.z); // Dynamic Pressure (Absolute value)
		let PDrgZF = DynPrZ * air_.FrntAr * air_.DrgCdz; // Parasitic Drag
		if (PSpdZS < 0) PDrgZF = -DynPrZ * air_.DrgCdx/air_.DrgCdz; // Use large drag to limit max speed
		// Lateral Drag Force
		let DynPrX = (air_.AirSpd.x * air_.AirSpd.x) * air_.AirDSL / 2; // Dynamic Pressure
		let PDrgXF = DynPrX * air_.FrntAr * air_.DrgCdx; // Parasitic Drag
		if (PSpdXS < 0) PDrgXF = -PDrgXF; // If going left, drag = right
		// Total Drag
		let DrgTot = Math.abs(PDrgZF) + Math.abs(PDrgXF);
		// 3. Forward Speed (mps) ...............................................	
		// Thrust Force
		let ACPRad = -air_.AirRot.x * DegRad;
		let PThrZF = air_.MaxThr * Math.sin(ACPRad); // Propeller Acceleration - Forward
		// Net Force -> Net Acceleration and Speed (mpf)
		let PnetZF = PThrZF - PDrgZF; // Net Force
		let PnetZA = PnetZF * FrcAcc; // Net Acc (mpf)
		PSpdZS = PSpdZS + PnetZA; // new Speed (mpf)
		// 4. Lateral Speed (mps) ...............................................
		// Thrust Force
		let ACBRad = air_.AirRot.z * DegRad;
		let PThrXF = air_.MaxThr * Math.sin(ACBRad); // Propeller Acceleration - Lateral
		// Net Force -> Net Acceleration and Speed (mpf)
		let PnetXF = PThrXF - PDrgXF; // Net Force
		let PnetXA = PnetXF * FrcAcc; // Net Acc (mpf)
		PSpdXS = PSpdXS + PnetXA; // new Speed (mpf)
		// 5. Vertical Speed (mpf) ..............................................
		air_.AirSpd.y = air_.AirSpd.y + air_.AltDif;
		if (air_.AirSpd.y > KeyVal.y) air_.AirSpd.y = KeyVal.y; // Max Up
		if (air_.AirSpd.y < -KeyVal.y) air_.AirSpd.y = -KeyVal.y; // Max Down
		// 6. Compute MSpd (mps to mpf)
		air_.MapSpd.z = PSpdZS * Math.cos(ACHRad) - PSpdXS * Math.sin(ACHRad);
		air_.MapSpd.x = PSpdZS * Math.sin(ACHRad) + PSpdXS * Math.cos(ACHRad);
		air_.MapSpd.y = air_.AirSpd.y; // mpf
		//	Save for Display Only (mps)
		air_.AirSpd.z = PSpdZS / DLTime;
		air_.AirSpd.x = PSpdXS / DLTime;
		//- Rotate Helicopter --------------------------------------------------
		// ACPitch
		let MaxAng = air_.MinAng+(air_.MaxAng-air_.MinAng) * (1-air_.AirSpd.z/(air_.MaxKPH/3.6));
		air_.AirRot.x = air_.AirRot.x + air_.RotDif.x;
		if (air_.AirRot.x > MaxAng) air_.AirRot.x = MaxAng;
		else if (air_.AirRot.x < -MaxAng) air_.AirRot.x = -MaxAng;
		// ACBank
		air_.AirRot.z = Mod360(air_.AirRot.z + air_.RotDif.z);
		if (air_.AirRot.z > air_.MaxAng && air_.AirRot.z < 180) air_.AirRot.z = air_.MaxAng;
		else if (air_.AirRot.z < (360-air_.MaxAng) && air_.AirRot.z > 180) air_.AirRot.z = (360-air_.MaxAng);
		// ACYaw
		air_.AirRot.y = Mod360(air_.AirRot.y + air_.RotDif.y);
		// Weather-Vane Adjustment
		let YawAdj = 0;
		let TotSpd = Math.sqrt(air_.AirSpd.z*air_.AirSpd.z+air_.AirSpd.x*air_.AirSpd.x);
		TotSpd = Math.abs(TotSpd);
		if (TotSpd) { // if moving
			air_.DirFlt = Mod360(Math.atan2(air_.MapSpd.x,air_.MapSpd.z) * RadDeg);
			let DirDif = Mod360(air_.DirFlt-air_.AirRot.y);	// Difference
			DirDif = PoM360(DirDif)*DegRad;
			YawAdj = Math.sin(DirDif); // Range = 0, +1, 0, -1
			if (DirDif > 90) YawAdj = 1;
			if (DirDif < -90) YawAdj = -1;
			YawAdj = YawAdj * TotSpd / air_.MaxKPH;
			YawAdj = YawAdj * 10;
			air_.AirRot.y = air_.AirRot.y + YawAdj;
		}
//		air_.RotDif.y = air_.RotDif.y + YawAdj; // Why not work?
//		console.log(YawAdj);
	}
	// Compute Map Pos (MapSpd = mpf)
	air_.MapPos.z = air_.MapPos.z + air_.MapSpd.z;
	air_.MapPos.x = air_.MapPos.x + air_.MapSpd.x;
	air_.MapPos.y = air_.MapPos.y + air_.MapSpd.y; // ASL
	// Landing Altitude
	let MinAlt = air_.GrdZed + air_.MdlAlt; // Minimum Altitude (ASL = GL+AGL)
	if (!air_.GrdFlg && air_.MapPos.y <= MinAlt) _landFlight(MinAlt);
	// Compute Speeds
	air_.SpdKPH = air_.AirSpd.z/1000; // (KPH)
	air_.SpdMPS = air_.SpdKPH/1000; // (mps)
	air_.MapSPS.x = air_.MapSpd.x; // (mpf)
	air_.MapSPS.y = air_.MapPos.y; // (meters)
	air_.MapSPS.z = air_.MapSpd.z; // (mpf)
	air_.AirObj.rotation.set(air_.AirRot.x*DegRad,air_.AirRot.y*DegRad,air_.AirRot.z*DegRad);
}

function _landFlight(MinAlt) {
		air_.GrdFlg = 1;	// If Flag Not Set and Hit Ground
		air_.MapPos.y = MinAlt;	// Altitude = GL + AGL
		// Inputs
		air_.AltDif = 0;
		air_.RotDif.x = 0;
		air_.RotDif.z = 0;		
		// Rotation
		air_.AirRot.x = 0;
		air_.AirRot.z = 0;
		// AirSpeed
		air_.AirSpd.z = 0;
		air_.AirSpd.x = 0;
		air_.AirSpd.y = 0;
		// MapSpeed
		air_.MapSpd.z = 0;
		air_.MapSpd.x = 0;
		air_.MapSpd.y = 0;
		// DirFlt
		air_.DirFlt = air_.AirRot.y;	
}

/********************************************************************************
*
*	SUBROUTINES
*
********************************************************************************/

//- Convert degrees to 360
function Mod360(deg) {
	while (deg < 0) deg = deg+360; // Make deg a positive number
	deg = deg % 360;			// Compute remainder of any number divided by 360
return deg;}

//- Converts 360 degrees to +/- 180
function PoM360(deg) {
	if (deg > 180) deg = deg-360;
return deg;}

//- Limit Maximum +/- Value
function MaxVal(x, max) {
	if (x > 0 && x >  max) x =  max;
	if (x < 0 && x < -max) x = -max;
return x;}

/********************************************************************************
*
*	6. SOUNDS
*
********************************************************************************/

//= LOAD SOUNDS =================================================================

function loadSounds() {
	// Load Sounds ..............................................................
	let audioLoader = new THREE.AudioLoader();
	let RefDst = 25;			// Reference distance for Positional Audio
	// My Engine
	let fname = ACPath + "sounds/" + EngSrc;
	audioLoader.load(fname, function(buffer) {
		EngSnd.setBuffer(buffer);
		EngSnd.setRefDistance(RefDst);
		EngSnd.setLoop(true);
		EngSnd.setVolume(0);
	});
	// Init Sounds ..............................................................
	let	listener = new THREE.AudioListener();
	camera.add(listener);
	// My Engine
	EngSnd = new THREE.PositionalAudio(listener);
	EngMsh.add(EngSnd);			// Engine
	air_.AirObj.add(EngMsh);
	//- Set Flag
	gen_.LodSnd = 1;	
}

//= MOVE SOUNDS =================================================================

// Change Sounds
function moveSounds() {
	// My Engine
	EngSnd.setVolume(EngVol);
	EngSnd.setPlaybackRate(1);
}

//- Play Sounds -----------------------------------------------------------------
function playSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (!EngSnd.isPlaying) EngSnd.play();
}

//- Stop Sounds -----------------------------------------------------------------
function stopSounds() {
	// This leaves SndFlg and GunFlg unchanged.
	if (EngSnd.isPlaying) EngSnd.stop();
}

/********************************************************************************
*
*	7. CAMERA
*
********************************************************************************/

//== INIT CAMERA ===============//===============================================

function initCamera(camera,cam_) {
	camera.position.z = -cam_.lld.z;
	camera.rotation.y = cam_.adj*DegRad;
	cam_.rot.add(camera);		// Attach to rotator
	// Common Changes
	cam_.lld.copy(CamLLD[cam_.sel]);		// Restore Saved Values
	cam_.mmd.copy(CamMMD[cam_.sel]);		// In/Out - min, max, spd
	cam_.adj = CamAdj[cam_.sel];			// Load Adjustment
	camera.rotation.y = cam_.adj*DegRad;	// 180 = Looking in
	cam_.mmr.copy(CamMMR[cam_.sel]);		// Rotation min, max, spd
	cam_.par = CamPar[cam_.sel]				// Load New Parent
	cam_.par.add(cam_.rot);					// Attach Rotators
	cam_.flg = CamFlg[cam_.sel];			// 1 = cockpit
	cam_.lnk = CamLnk[cam_.sel];			// 1 = Linked to Airplane
	//
	moveCamera(camera,cam_);

}

//== MOVE CAMERA ===============//===============================================

function moveCamera(camera,cam_) {
	// Move Camera In/Out
	camera.position.z = -cam_.lld.z;
	// PointerLockControls
	if (cam_.pan) {
		cam_.lld.x = cam_.lld.x - InpMos.y * cam_.mmr.z;				// Camera Position (Lat)
		cam_.lld.x = MaxVal(cam_.lld.x,cam_.mmr.x);
		cam_.lld.y = Mod360(cam_.lld.y + InpMos.x * cam_.mmr.z);		// Camera Position (Lon)
		// Internal View
		if (cam_.flg) {											// Range: 250 to 360/0 to 110
			if (cam_.lld.y > 180 && cam_.lld.y < (360-cam_.mmr.y)) cam_.lld.y = (360-cam_.mmr.y);
			if (cam_.lld.y < 180 && cam_.lld.y > cam_.mmr.y) cam_.lld.y = cam_.mmr.y;
		}
		// External View
		else {
			if (air_.GrdFlg && cam_.lld.x > -12.5) cam_.lld.x = -12.5;
		}
		InpMos.x = 0;
		InpMos.y = 0;
	}
	// Adjust Camera Rotators
	// In internal view, the camera is facing out - view matches rotation
	if (cam_.flg) {
		cam_.rot.rotation.x = Mod360(cam_.lld.x)*DegRad;
		cam_.rot.rotation.y = Mod360(-cam_.lld.y)*DegRad;
	}
	// In external view, the camera is facing in and the armature is pointing out:
	else {
		cam_.rot.rotation.x = Mod360(-cam_.lld.x+0.5*air_.AirRot.x)*DegRad;
		cam_.rot.rotation.y = Mod360(180-cam_.lld.y)*DegRad;		
	}
}

/********************************************************************************
*
*	8. OUTPUTS
*
********************************************************************************/

// Change HUD Values
function prntHUDval() {
	AC_Hite = air_.MapPos.y*Mtr2Ft; // Altitude (feet)
	AC_HiteNode.nodeValue = AC_Hite.toFixed(0);
	AC_Ptch = air_.AirRot.x;	// Pitch (deg)
	AC_PtchNode.nodeValue = AC_Ptch.toFixed(0);
	AC_SpdZ =  air_.AirSpd.z * 3.6 * Km2Mil; // Speed - Forward (mph)
	AC_SpdZNode.nodeValue = AC_SpdZ.toFixed(0);
	AC_Bank = air_.AirRot.z;	// Bank (deg)
	AC_BankNode.nodeValue = AC_Bank.toFixed(0);
	AC_SpdX = air_.AirSpd.x * 3.6 * Km2Mil; // Speed - Lateral (mph)
	AC_SpdXNode.nodeValue = AC_SpdX.toFixed(0);
	AC_Head = Mod360(Math.round(air_.AirRot.y)); // Heading (deg)
	AC_HeadNode.nodeValue = AC_Head.toFixed(0);
	AC_DFly = air_.DirFlt;		// Direction of Flight (deg)
	AC_DFlyNode.nodeValue = AC_DFly.toFixed(0);
}

//	Paused On
function PawsText(){
	if (gen_.PawsOn) On_PawsNode.nodeValue = "Paused";
	else {On_PawsNode.nodeValue = "Pause: Press P";}
}

//	Info
function InfoText() {
	if (!gen_.InfoOn) onInfo0();
	else if (gen_.InfoOn == 1) onInfo1();
	else if (gen_.InfoOn == 2) onInfo2();
}

//	Info Off
function onInfo0(){
	On_Info01Node.nodeValue = "Info : Press I";
	On_Info02Node.nodeValue = "";
	On_Info03Node.nodeValue = "";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "";
	On_Info06Node.nodeValue = "";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "";
}

// Info On
function onInfo1(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "CONTROLS";
	On_Info03Node.nodeValue = "Mouse Wheel or Q/E Keys change Altitude";
	On_Info04Node.nodeValue = "Mouse, Arrow or W/S Keys change Pitch";
	On_Info05Node.nodeValue = "Mouse, Arrow or A/D Keys change Bank";
	On_Info06Node.nodeValue = "Mouse Buttons or Z/X Keys change Yaw";
	On_Info07Node.nodeValue = "";
	On_Info08Node.nodeValue = "";
	On_Info09Node.nodeValue = "S Key toggles sound";
}

// Info On
function onInfo2(){
	On_Info01Node.nodeValue = "";
	//
	On_Info02Node.nodeValue = "VIEW KEYS";
	On_Info03Node.nodeValue = "Shift Key and Mouse pans around aircraft";
	On_Info04Node.nodeValue = "";
	On_Info05Node.nodeValue = "DELETE/PAGE DOWN Keys look left/right";
	On_Info06Node.nodeValue = "Above plus HOME Key looks up";
	On_Info07Node.nodeValue = "END Key plus DELETE/PAGE DOWN Keys look back";
	On_Info08Node.nodeValue = "All 3 Keys to look back";
	On_Info09Node.nodeValue = "";
}

/********************************************************************************
*
*	9. INPUTS
*
********************************************************************************/

// The PointerLockControls creates inputs for mouse movement.
// This creates inputs for mouse buttons and keys.

//= MOUSE ======================//===============================================

//- Mouse Buttons (Down) --------------------------------------------------------
function onDocumentMouseDown(event) {
	event.preventDefault();
	if (event.button == 0) {	// Yaw Left
		InpYaw = -KeyVal.y;
	}
	if (event.button == 2) {	// Yaw Right
		InpYaw = KeyVal.y;
	}
}

//- Mouse Buttons (Up) ----------------------------------------------------------
function onDocumentMouseUp(event) {
	if (event.button == 0) {	// Yaw Left Off
		InpYaw = 0;
	}
	if (event.button == 2) {	// Yaw Right Off
		InpYaw = 0;
	}
}

// Mousewheel - Power
function onDocumentMouseWheel(event) {
	event.preventDefault();
	AltDif = - event.deltaY;
}

//- KEYBOARD ===================//===============================================

//- Keyboard (Down) -------------------------------------------------------------
function onDocumentKeyDown(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_AltU) InpAlt = 0.001;		// Altitude Up
	if (event.keyCode == K_AltD) InpAlt = -0.001;		// Altitude Down
	if (event.keyCode == A_PitU) InpACP = KeyVal.x;		// Pitch Up
	if (event.keyCode == A_PitD) InpACP = -KeyVal.x;	// Pitch Down
	if (event.keyCode == A_BnkL) InpACB = -KeyVal.z;	// Bank Left
	if (event.keyCode == A_BnkR) InpACB = KeyVal.z;		// Bank Right
	if (event.keyCode == K_PitU) InpACP = KeyVal.x;		// Pitch Up
	if (event.keyCode == K_PitD) InpACP = -KeyVal.x;	// Pitch Down
	if (event.keyCode == K_BnkL) InpACB = -KeyVal.z;	// Bank Left
	if (event.keyCode == K_BnkR) InpACB = KeyVal.z;		// Bank Right
	if (event.keyCode == K_YawL) InpYaw = -KeyVal.y;	// Yaw Left
	if (event.keyCode == K_YawR) InpYaw = KeyVal.y;		// Yaw Right
	// Views
	if (event.keyCode == K_VU45) D45flg = 1;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 1;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 1;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 1;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 1;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 1;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.pan = 1;			// Pan View
	// Toggle
	if (event.keyCode == K_Paws) toglPaws();			// Toggle Pause
	if (event.keyCode == K_Info) toglInfo();			// Toggle Information
	if (event.keyCode == K_Soun) toglSoun();			// Toggle Sound
}

//-	Keyboard (Up) ---------------------------------------------------------------
function onDocumentKeyUp(event) {
	let keyCode = event.which;
	// Basic
	if (event.keyCode == K_AltU) InpAlt = 0;			// Altitude Up
	if (event.keyCode == K_AltD) InpAlt = 0;			// Altitude Down
	if (event.keyCode == A_PitU) InpACP = 0;			// Pitch Up
	if (event.keyCode == A_PitD) InpACP = 0;			// Pitch Down
	if (event.keyCode == A_BnkL) InpACB = 0;			// Bank Left
	if (event.keyCode == A_BnkR) InpACB = 0;			// Bank Right
	if (event.keyCode == K_PitU) InpACP = 0;			// Pitch Up
	if (event.keyCode == K_PitD) InpACP = 0;			// Pitch Down
	if (event.keyCode == K_BnkL) InpACB = 0;			// Bank Left
	if (event.keyCode == K_BnkR) InpACB = 0;			// Bank Right
	if (event.keyCode == K_YawL) InpYaw = 0;			// Yaw Left
	if (event.keyCode == K_YawR) InpYaw = 0;			// Yaw Right
	// Views
	if (event.keyCode == K_VU45) D45flg = 0;			// View - 45 deg up
	if (event.keyCode == K_VD45) U45flg = 0;			// View - 45 deg down
	if (event.keyCode == K_VL45) L45flg = 0;			// View - 45 deg left
	if (event.keyCode == K_VR45) R45flg = 0;			// View - 45 deg right
	if (event.keyCode == K_VL90) L90flg = 0;			// View - 90 deg left
	if (event.keyCode == K_VR90) R90flg = 0;			// View - 90 deg right
	if (event.keyCode == K_Look) cam_.pan = 0;			// Pan View
}

//- Subroutines -----------------------------------------------------------------

//. Toggle Pause ................................................................
function toglPaws() {
	gen_.PawsOn = 1 - gen_.PawsOn;
	if (gen_.PawsOn && gen_.SndFlg) {		//On to Off
		stopSounds();
	}
	if (!gen_.PawsOn && gen_.SndFlg) {	// Off to On
		playSounds();
	}
	PawsText();
}

//. Toggle AutoPilot ............................................................
function toglAuto() {
	air_.AutoOn = 1 - air_.AutoOn;
	AutoText();
}

//. Toggle Info .................................................................
function toglInfo() {
	gen_.InfoOn++
	if (gen_.InfoOn == 3) gen_.InfoOn = 0;
	InfoText();
}

//. Toggle Sound ................................................................
function toglSoun() {
	if (!gen_.PawsOn) {
		gen_.SndFlg = 1 - gen_.SndFlg;
		if (gen_.SndFlg) {			// Off to On
			playSounds();
		}
		else {					// On to Off
			stopSounds();
		}
	}
}

//= WINDOW RESIZE ==============//==============================================

function onWindowResize() {
	camera.aspect = window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

/********************************************************************************
*
*	CHANGE LOG
*
*********************************************************************************
*/

</script>
</body>
</html>